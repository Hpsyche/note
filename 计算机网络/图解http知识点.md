# 1.了解Web及网络基础

## 确保可靠性的TCP协议

为了准确无误地将数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP一定会向对方确认是否成功发送。握手过程中使用了TCP的标志----SYN（synchronize）和ACK（acknowledgement）。

* 发送端首先发送一个带SYN标志的数据包给对方。
* 接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。
* 最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。



# 2.简单的HTTP协议

## 请求报文和响应报文

注意：先从客户端建立通信的，服务器端在没有接收到请求之前不会发送响应。

### 请求报文

请求报文是由**请求方法、请求URI、协议版本、可选的请求首部字段和内容实体**构成的。

如：

//请求方法、请求URI、协议版本

POST /index.html HTTP/1.1

//请求首部字段

Host:hackr.jp
Connection:keep-alive
Connection-Type:application/x-www-form-urlencoded
Content-Length:16

//内容实体

name=ueno&age=37

### 响应报文

响应报文是由**协议版本、状态码（表示成功或失败的数字的代码）、用以解释状态码的原因短语、可选的响应首部字段和内容实体**构成的。

如：

//协议版本、状态码、解释

HTTP/1.1 200 OK

//响应首部字段

Data:Tue, 19 Jan 2019 00:53:11 GMT
Connection-Type:text/html
Content-Length:16

//内容实体

<html>

...

</html>

## HTTP是不保存状态的协议

即无状态协议

注意：HTTP/1.1也是无状态协议，但引入了Cookie技术

## 告知服务器意图的HTTP方法

### GET

GET - 从指定的资源请求数据

### POST

POST - 向指定的资源提交要被处理的数据

### GET和POST的对比

|                  |                             GET                              |                             POST                             |
| :--------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|  后退按钮/刷新   |                             无害                             |   数据会被重新提交（浏览器应该告知用户数据会被重新提交）。   |
|       书签       |                         可收藏为书签                         |                        不可收藏为书签                        |
|       缓存       |                           能被缓存                           |                           不能缓存                           |
|     编码类型     |              application/x-www-form-urlencoded               | application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 |
|       历史       |                   参数保留在浏览器历史中。                   |                 参数不会保存在浏览器历史中。                 |
| 对数据长度的限制 | 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 |                           无限制。                           |
| 对数据类型的限制 |                     只允许 ASCII 字符。                      |                 没有限制。也允许二进制数据。                 |
|      安全性      | 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！ | POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 |
|      可见性      |              数据在 URL 中对所有人都是可见的。               |                   数据不会显示在 URL 中。                    |

### PUT

PUT方法用来传输文件。

由于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全问题，故一般web网站不使用该方法，但有时可能开放。

若传输成功，其响应返回状态码为204，表示：请求执行成功了，但无数据返回。

### HEAD

获取报文首部

如：

//请求

HEAD /index.html HTTP/1.1
HOST:www.hackr.jp

//响应

返回index.html有关的响应首部

### DELETE

删除文件，功能和PUT相反。（响应返回状态码也为204）

###  OPTIONS

询问支持的方法（1.0不支持）

如：

//请求

OPTIONS * HTTP/1.1
Host:www.hackr.jp

//响应

HTTP/1.1 200 ok
Allow:GET,POST,HEAD,OPTIONS

### TRACE

追踪路径（1.0不支持）

### CONNECT

使用隧道协议连接代理（1.0不支持）

## 持久连接

持久连接旨在建立1次TCP连接后进行多次请求和响应的交互

在HTTP/1.1中，所有的连接都默认是持久连接

要实现持久连接，客户端和服务器端都要支持

### 管线性

即客户端可同时并行发送多个请求，而不需要等待收到响应后再发出

### 使用Cookie的状态管理

HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。

因此，因此了Cookie技术，Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。

过程如下：

1. 请求报文（没有Cookie信息的状态）

GET /reader/ HTTP/1.1
Host:hackr.jp

（注意：此时首部字段中没有Cookie的相关信息）

2. 响应报文（服务端生成Cookie信息）

HTTP/1.1 200 OK
Data:Tue, 19 Jan 2019 00:53:11 GMT
<font color=red><Set-Cookie:sid=1234567890123456;。。。 ></font>
Content-Type:text/plain;charset=UTF-8

3. 请求报文（自动发送保存着的Cookie信息）

GET /reader/ HTTP/1.1
Host:hackr.jp
Cookie:sid=1234567890123456



# 3.HTTP报文内的HTTP信息

## 发送多种数据的多部分对象集合

多部分对象集合包含的对象如下。

* multipart/form-data

  在Web表单文件上传时使用

* multipart/byteranges

  状态码206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用

在HTTP报文中使用多部分对象集合时，需要在首部字段里加上Content-type。

## 内容协商返回最合适的内容

当浏览器的默认语言为英语或中文，访问相同的URI的Web页面时，则会显示对应的英文版和中文版的Web页面。这样的机制称为内容协商（Content Negotiaton)。

内容协商机制是指客户端和服务器端就响应的资源内容进行交涉、然后提供给客户端最为适合的资源。



# 4.返回结果的HTTP状态码

## 状态码的类别

|      | 类别                             | 原因短语                   |
| ---- | -------------------------------- | -------------------------- |
| 1XX  | Informational（信息性状态码）    | 接收的请求正在处理         |
| 2XX  | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX  | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX  | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX  | Server Error（服务器错误状态码） | 服务器处理请求出错         |

## 2XX成功

### 200 OK（返回全部内容）

表示从客户端发来的请求在服务器端被正常处理了。

### 204 No Content（没有内容返回）

该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。

### 206 Partial Content（返回部分内容）

响应报文中包含由Content-Range指定范围的实体内容

## 3XX重定向

### 301 Moved Permanently

永久性重定向。如，当指定资源路径的最后忘记添加斜杆”/"，就会产生301状态码。

### 302 Found

临时性重定向。

### 303 See Other

URI重定向。

### 304 Not Modified

未修改。自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。

### 307 Temporary Redirect

临时重定向。

## 4XX客户端错误

### 400 Bad Request

表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。

注意：浏览器会像200OK一样对待该状态码。

### 401 Unauthorized

该状态码表示发送的请求需要有通过HTTP认证的认证信息。另外若之前已进行过1次请求，则表示用户认证失败。

返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用以质询（challenge）用户信息。当浏览器初次接收到401响应，会弹出认证用的对话窗口。

### 403 Forbidden

该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。

未获得文件系统的访问授权，访问授权出现某些问题（从未授权的发送源IP地址试图访问）等列举的情况都可能是发生403的原因。

### 404 Not Found

该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。

## 5XX服务器错误

### 500 Internal Server Error

表明服务器端在执行请求时出现了错误、

### 503 Service Unavailable

表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。



# 5.与HTTP协作的Web服务器

## 通信数据转发程序：代理、网关、隧道

HTTP通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道。它们可以配合服务器工作。

* 代理

代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。

* 网关

网过关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉：自己的通信目标是一个网关。

* 隧道

隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。

### 代理

代理服务器的基本行为就是接受客户端发送的请求后转发给其他服务器。代理不改变请求URI，会直接发送给前方持有资源的目标服务器。

持有资源实体的服务器被称为源服务器。

代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文

* 缓存代理

  代理转发响应时，缓存代理会预先将资源的副本保存在代理服务器上。

  当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。

* 透明代理

  转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理。

### 网关

利用网关可以由HTTP请求转化为其他协议通信

网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非HTTP协议服务。

### 隧道

通过隧道的传输，可以和远距离的服务器安全通信。隧道本身是透明的，客户端不用在意隧道的存在。



# 6.HTTP首部

## HTTP报文首部

HTTP报文的结构

* 报文首部

  在客户端和服务器处理时起至关重要作用的信息几乎都在这边

* 空行

* 报文主体

  所需要的用户和资源的信息都在这边

## HTTP首部字段

HTTP首部字段是由首部字段和字段值构成的，中间用冒号：分割。

另外，一个字段值可以对应多个值。

若HTTP首部字段重复了会如何？

根据浏览器内部处理逻辑的不同，结果可能不一致，有些浏览器会优先处理第一次出现的首部字段，而有些则会优先处理最后出现的首部字段。

### End-to-end首部和Hop-by-hop首部

HTTP首部字段将定义成缓存代理和非缓存代理的行为，分成2种类型。

#### 端到端首部

分在此类别中的首部会转发给请求/响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。

#### 逐跳首部

分在此类别的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1和之后版本中，如果要使用hop-by-hop首部，需提供Connection首部字段。

下面列举了HTTP/1.1中的逐跳首部字段。 除这8个首部字段之外，其他所有字段都属于端到端首部。

* Connection
* Keep-Alive
* Proxy-Authenticate
* Proxy-Authorization
* Trailer
* TE
* Transfer-Encoding
* Upgrade

## HTTP/1.1通用首部字段

### Cache -Control

通过指定首部字段Cache-Control的指令，就能操作缓存的工作机制。

#### 表示是否能缓存的指令

* public指令

Cache-Control:public，当指定使用public指令时，则明确表明其他用户也可利用缓存。

* private指令

当指定private指令后，响应只以特定的用户作为对象，这与public指令的行为相反。缓存代理器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存。

* no-cache指令

使用no-cache指令的目的是为了防止从缓存中返回过期的资源。

客户端发送的请求如果包含no-cache指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。

如果服务器返回的响应中包含no-cache指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。   

 #### 控制可执行缓存的对象的指令

* no-store指令

Cache-Control:no-store

当使用no-store指令时，暗示请求或响应中包含机密信息。

因此，该指令规定缓存不能在本地存储请求或响应的任一部分。

#### 指令缓存期限和认证的指令

* s-maxage指令

指定公共缓存服务器响应的最大age值，s-maxage指令只适用于供多位用户使用的公共缓存服务器。也就是说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。-

* max-age指令

当客户端发送的请求中包含max-age指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源，另外，当指定max-age值为0，那么缓存服务器通常需要将请求转发给源服务器。

* min-fresh指令

min-fresh指令要求缓存服务器返回至少还未过指定时间的缓存资源。

### Connection

Connection首部字段具备如下两个作用:

* 控制不再转发给代理的首部字段
* 管理持久连接

#### 控制不再转发给代理的首部字段

在客户端发送请求和服务器返回响应内，使用Connection首部字段，可控制不再转发给代理的首部字段。

#### 管理持久连接

HTTP/1.1版本的默认连接都是持久连接，为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定Connection首部字段的值为Close。

而相反，HTTP/1.1之前的HTTP版本的默认连接都是非持久连接。为此，如果想在旧版本的HTTP协议上维持持续连接，则需要指定Connection首部字段的值为Keep-Alive。

### Transfer-Encoding

首部字段Transfer-Encoding规定了传输报文主体时采用的编码方式。

### Upgrade

首部字段Upgrade用于检测HTTP协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。

注意：在使用Upgrade首部字段时，还需要指定Connection的值为Upgrade

### Via

使用首部字段Via是为了追踪客户端与服务器之间的请求和响应报文的传输路径。

### Warning

该首部通常会告知用户一些与缓存相关的问题的警告。

#### Warning首部的格式如下，最后的日期时间部分可省略：

Warning:[警告码] [警告的主机：端口号] "[警告内容]" ([日期时间])

HTTP/1.1中定义了7种警告

| 警告码 | 警告内容                                         | 说明                                                         |
| ------ | ------------------------------------------------ | ------------------------------------------------------------ |
| 110    | Response is stale（响应已过期）                  | 代理返回已过期的资源                                         |
| 111    | Revalidation failed（再验证失败）                | 代理再验证资源有效性时失败（服务器无法到达等原因）           |
| 112    | Disconnection operation（断开连接操作）          | 代理与互联网连接被故意切断                                   |
| 113    | Heuristic expiration（试探性过期）               | 响应的使用期超过24小时（有效缓存的设定时间大于24小时的情况下） |
| 199    | Miscellaneous warning（杂项警告）                | 任意的警告内容                                               |
| 214    | Transformation applied（使用了转换）             | 代理对内容编码或媒体类型等执行了某些处理时                   |
| 299    | Miscellaneous persistent warning（持久杂项警告） | 任意的警告内容                                               |

## 请求首部字段

### Accept

Accept首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。

若想要给显示的媒体类型增加优先级，则是用q=来额外表示权重值。范围为0-1，不指定q值时，默认为0.

当服务器提供多种内容时，将会首先返回权重值最高的媒体类型。

### Accept-Charset

用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。

可用权重q值来表示相对优先级。

### Accept-Encoding

用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。

### Accept-Language

用来告知服务器用户代理能够处理的自然语言集以及自然语言集的相对优先级。

### Authorization

首部字段authorization是用来告知服务器。用户代理的认证信息。通常，想要通过服务器认证的用户代理会在接收到返回的401状态码响应后，把首部字段Authorization加入请求中。

### Expect

客户端使用首部字段Except来告知服务器，期望出现的某种特定行为。因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码417 Expectation Failed。

### From

用来告知服务器使用用户代理的用户的电子邮件地址。

### Host

告知服务器请求的资源所处的互联网主机名和端口号。Host首部字段在HTTP/1.1规范内是唯一一个必须被包含在请求内的首部字段。

### If-Match

服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。   



# 7.确保Web安全的HTTPS

## HTTP的缺点

* 通信使用明文（不加密），内容可能会被窃听
* 不验证通信方的身份，因此有可能遭遇伪装
* 无法证明报文的完整性，所以有可能已遭篡改

### 通信使用明文可能会被窃听

#### TCP/IP是可能被窃听的网络

窃听相同段上的通信并非难事。只需要收集在互联网上流动的数据包（帧）就行了，对于收集来的数据包的解析工作，可交给那些抓包（Packet Capture）或嗅探器（Sniffer）工具。

抓包工具：Wireshark

#### 加密处理防止被窃听

加密的对象可以有那么几个：

* 通信的加密

  HTTP协议中没有加密机制，但可以通过和SSL或TLS的组合使用，加密HTTP的通信内容。

  用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP被称为HTTPS或HTTP over SSL。

* 内容的加密

  为了做到有效的内容加密，前提是要求客户端和服务器同时具备加密和解密机制。

### 不验证通信方的身份就可能遭遇伪装

#### 任何人都可发起请求

在HTTP协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外，服务器只要接受到请求，不管对方是谁都会返回一个响应，因此存在各种隐患。

#### 查明对手的证书

虽然使用HTTP协议无法确定通信方，但如果使用SSL则可以。SSL不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定方。

证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。另外，伪造证书是一件异常困难的事情。

### 无法证明报文完整性，可能已遭篡改

####  接收到的内容可能有误

在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。

在请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击。

#### 如何防止篡改

常用的为MD5和SHA-1等散列值校验的方法，以及用来确认文件的数字签名方法。

以上，发现仅靠HTTP确保完整性是非常困难的，因此通过和其他协议组合使用来实现目标。

## HTTP+加密+认证+完整性保护=HTTPS

### HTTP加上加密处理和认证以及完整版保护后即使HTTPS

把添加了加密处理和认证以及完整版保护后的HTTP称为HTTPS（HTTP Secure，与之前的HTTP over SSH是一样的），都是HTTPS，其中文为"超文本传输安全协议"。

### HTTPS是身披SSL外壳的HTTP

在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。

SSL是独立于HTTP的协议，所以不光是HTTP协议，其他运行在应用层的SMTP和Telnet等协议均可配合SSL协议使用。

## 相互交互密钥的公开密钥加密技术

近代的加密方法中加密算法是公开的，而密钥却是保密的。

### 共享密钥加密的困境

加密和解密同用一个密钥的方式成为共享密钥加密，也被叫做对称密钥加密。

以共享密钥方式加密时必须将密钥也发给对方。可在转发密钥时，如果通信被监听那么密钥就可会落入攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。

### 使用两把密钥的公开密钥加密

公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。私有密钥不能让其他任何人知道，公开密钥则可以随意发布。

使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到加被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。

### HTTPS采用混合机密机制

共享密钥优点：处理速度快

公开密钥优点：实现安全交换

所以应充分利用两者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。

即：

1. 使用公开密钥加密方式安全地交换在稍后的共享密钥加密中要使用的密钥
2. 确保交换的密钥是安全的前提下，使用共享密钥加密方式进行通信

## 证明公开密钥正确性的证书

但是，公开密钥加密方式还是存在一些问题，就是无法证明公开密钥本身就是货真价实的公开密钥，可能会被攻击者替换掉。

为了解决上述问题，可以使用由数字证书认证机构和其相关机关颁发的公开密钥证书。

### 可证明组织真实性的EV SSL证书

证书的一个作用是用来证明作为通信一方的服务器是否规范，另外一个作用是可确认对方服务器背后运营的企业是否真实存在。拥有该特性的证书就是EV SSL证书。

### 由自认证机构颁发的证书称为自签名证书

独立构件的认证机构叫做自认证机构，由自认证机构颁发的“无用”的证书也被称为自签名证书。

浏览器访问该服务器时，会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告信息。

值得信赖的第三方机构介入认证，才能让已植入在浏览器内的认证机构颁布的公开密钥发挥作用，并借此证明服务器的真实性。

#### SSL速度慢吗

SSL的慢分两种。一种是指通信慢。另一种是由于大量消耗CPU及内存等资源，导致处理速度变慢。

另一点是SSL必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上将，比起HTTP会更多地消耗服务器和客户端的硬件资源，导致负载增加。

#### 既然HTTPS安全可靠，为什么不一直使用HTTPS？

HTTPS会消耗更多地CPU及内存资源。因此，如果是非敏感信息则使用HTTP通信，只有在包含个人信息等敏感数据时，才利用HTTPS加密通信。



# 8.确认访问用户身份的认证

HTTP使用的认证方式：

* BASIC认证（基本认证）
* DIGEST认证（摘要认证）
* SSL客户端认证
* FormBase认证（基于表单认证）

## BASIC认证

BASIC是从HTTP/1.0就定义的认证方式。现在使用不多。

### BASIC认证的认证步骤

1. 当请求的资源需要BASIC认证时，服务器会随状态码401，返回带WWW-Authenticate首部字段的响应；
2. 接收到状态码为401的客户端为了通过BASIC认证，需要将用户ID即密码发送给服务器。发送的字符串内容是由用户ID和密码构成，两者中间以冒号连接后，在经过Base64编码处理；
3. 接收到包含首部字段Authorization请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含Request-URI资源的响应。

虽然BASIC采用Base64编码，但这不是加密处理，不需要任何附加信息即可对其解码，安全等级低，因此不常用。

## DIGEST认证

DIGEST认证同样使用质询/响应的方式，但不会像BASIC认证那样直接发送明文密码。

质询/响应方式：一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码，最后将响应码返回给对方进行认证的方式。

### DIGEST认证的认证步骤

1. 客户端发送请求
2. 服务器发送临时的质询码（随机数：nonce）以及告知需要认证的状态码401
3. 客户端发送摘要以及由质询码计算出的响应码（response）
4. 认证成功返回状态码200，失败则再次发生状态码401

## SSL客户端认证

以上两种情况，如果用户ID和密码被盗，就很有可能被第三章冒充，因此SSL客户端认证则可以避免该情况的发生。

SSL客户端认证是借由HTTPS的客户端证书完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来自己登陆的客户端。

### SSL客户端认证的认证步骤

为达到SSL客户端认证的目的，需要事先将客户端证书发给客户端，且客户端必须安装此证书。

1. 接收到需要认证资源的请求，服务器会发送Certificate Request报文，要求客户端提供客户端证书；
2. 用户选择发送的客户端证书后，客户端会把客户端证书信息以Client Certificate报文方式发送给服务器；
3. 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始HTTPS加密通信

### SSL客户端认证采用双因素认证

在多数情况下，SSL客户端认证不会仅靠证书完成认证，一般会和基于表单认证组合形成一种双因素认证来使用。所谓双因素认证：认证过程中不仅需要密码这一个因素，还需要申请认证者提供其他持有信息；

### SSL客户端认证必要的费用

使用SSL客户端认证需要用到客户端证书，而客户端证书需要支付一定费用才能使用。

## 基于表单认证

多数情况下，输入已事先登录的用户ID和密码等登录信息后，发送给Web应用程序，基于认证结果来决定认证是否成功。

### 认证多半为基于表单认证

由于使用上的便利性及安全性问题，HTTP协议标准提供的BASIC认证和DIGEST认证几乎不怎么使用。另外，SSL客户端认证虽然具有较高的安全性，但因为导入和维持费用等问题，还尚未普及。

### Session管理及Cookie应用

基于表单认证的标准规范尚未有定论，一般会使用Cookie来管理Session（会话）。

基于表单认证本身是通过服务器端的Web应用，将客户端发送过来的用户ID和密码与之前登录过的信息做匹配来进行认证的。

但鉴于HTTP是无状态协议，于是我们使用Cookie来管理Session，以弥补HTTP协议不存在的状态管理功能。

### 基于表单认证的认证步骤

1. 客户端把用户ID和密码等登录信息放入报文的实体部分，通常是以POST方式把请求发送给服务器。（使用HTTPS通信来进行HTML表单画面的显示和用户输入数据的发送）

2. 服务器会发放用以识别用户的Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与Session ID绑定后记录在服务器。

   向客户端返回响应时，会在首部字段Set-Cookie内写入Session ID；

3. 客户端接收到从服务器端发来的Session ID后，会将其作为Cookie保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以Session ID也随之发送到服务器。服务器端可通过验证接收到的Session ID识别用户和其认证状态。



# 基于HTTP的功能追加协议

## 消除HTTP瓶颈的SPDY

### HTTP的瓶颈

在Facebook和Twitter等SNS网站上，几乎能够实时观察到海量用户公开发布的内容。当几百、几千万的用户发布内容时，Web网络为了保存这些新增内容，在很短的时间内就会发生大量的内容更新。|
为了尽可能实时地显示这些更新的内容，服务器一旦有内容更新，就需要直接把那些内容反馈到客户端上，使用HTTP协议探知服务器上是否有内容更新，就必须频繁地从客户端到服务器进行确认。如果服务器上没有内容更新，那么就会产生徒劳的通信。
即HTTP存在以下瓶颈：

* 一条连接上只可发送一个请求
* 请求只能从客户端开始。客户端不可以接收除响应以外的指令
* 请求/响应首部未经压缩就发送。首部信息越多延迟越大
* 发送冗长的首部。每次互相发送相同的首部造成的浪费较多
* 可任意选择数据压缩格式。非强制压缩发送

#### Ajax的解决方法

Ajax是一种有效利用JavaScript和DOM的操作，已达到局部Web页面替换加载的异步通信手段。和以前的同步通信相比，由于它只更新一部分页面。响应中传输的数据量会因此而减少，这一优点显而易见。

Ajax的核心技术是名为XMLHttpRequest的API，通过JavaScript脚本语言的调用就能和服务器进行HTTP通信。借由这种手段，就能从已加载完毕的Web页面上发起请求，只更新局部页面。

而利用Ajax实时地从服务器获取内容，有可能会导致大量请求产生。另外，Ajax仍为解决HTTP协议本身存在的问题。

#### Comet的解决方法

一旦服务器端有内容更新了，Comet不会让请求等待，而是直接给客户端返回响应。这是一种通过延迟应答，模拟实现服务器端向客户端推送的功能。

通常，服务器端接收到请求，在处理完毕后就会立即返回响应，但为了实现推送功能，Comet会先将响应置于挂起状态，当服务器端有内容更新时，再返回该响应。因此，服务器端一旦有更新，就可以立即反馈给客户端。

内容上虽然可以做到实时更新，但为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源。另外，Comet也仍未解决HTTP协议本身存在的问题。

#### SPDY的目标

陆续出现的Ajax和Comet等提高易用性的技术，一定程度上使HTTP得到了改善，但HTTP协议本身的限制也令人束手无策。因此，需要有一些协议层面上的改动。

### SPDY的设计与功能

SPDY没有完全改写HTTP协议，而是在TCP/IP的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY规定通信中使用SSL。

SPDY以会话层的形式加入，控制对数据的流动，但还是采用HTTP建立通信连接。因此，可照常使用HTTP的GET和POST等方法、Cookie以及HTTP报文等。

使用SPDY后，HTTP协议额外获得以下功能。

* 多路复用流

  通过单一的TCP连接，可以无限制处理多个HTTP请求。所有请求的处理都在一条TCP连接上完成，因此TCP的处理效率得到提高。

* 赋予请求优先级

  SPDY不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。

* 压缩HTTP首部

  压缩HTTP请求和响应的首部。这样一来，通信产生的数据包数量和发送的字节数就更少了。

* 推送功能

  支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送数据，而不必等待客户端的请求。

* 服务器提示功能

  服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。

### SPDY消除Web瓶颈了吗

因为SPDY基本上只是将单个域名（IP地址）的通信多路复用，所以当一个Web网站上使用多个域名下的资源，改善效果就会受到限制。

## 使用浏览器进行全双工通信的WebSocket

利用Ajax和Comet技术进行通信可以提升Web的浏览速度。但问题在于通信若使用HTTP协议，就无法彻底解决瓶颈问题。

### WebSocket的设计与功能

WebSocket，即Web浏览器与Web服务器之间全双工通信标准，其技术主要是为了解决Ajax和Comet里XMLHttpRequest附带的缺陷所引起的问题。

### WebSocket附议

一旦Web服务器与客户端之间建立起WebSocket协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON、XML、HTML或图片等任意格式的数据。

由于是建立在HTTP基础上的协议，因此连接的发起方仍是客户端，而一旦确立WebSocket通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。

WebSocket协议的主要特点如下：

* 推送功能

  支持由服务器向客户端推送数据的推送功能。这样，服务器可直接发送数据，而不必等待客户端的请求。

* 减少通信量

  只要建立起WebSocket连接，就希望一直保持连接状态。和HTTP相比，不但每次连接时的总开销减少，而且由于WebSocket的首部信息很小，通信量也相应减少了。

为了实现WebSocket通信，在HTTP连接建立之后，需要完成一次“握手”的步骤：

* 握手-请求

  为了实现WebSocket通信，需要用到HTTP的Upgrade首部字段，告知服务器通信协议发生改变，已达到握手的目的。

* 握手-响应

  对于之前的请求，返回状态码101 Switching Protocols的响应。

  成功握手确立WebSocket连接之后，通信时不再使用HTTP的数据帧，而采用WebSocket独立的数据帧。

## Web服务器管理文件的WebDAV

WebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）是一个可对Web服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统。





