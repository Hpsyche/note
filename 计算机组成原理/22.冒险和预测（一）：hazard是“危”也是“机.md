任何一本讲解CPU的流水线设计的教科书，都会提到流水线设计需要解决的三大冒险，分别是结构冒险（Structural Harzard）、数据冒险（Data Harzard）以及控制冒险（Control Harzard）。

## 结构冒险

**CPU在同一个时钟周期，同时在运行两条计算机指令的不同阶段。但是这两个不同的阶段，可能会用到同样的硬件电路。**

可以看到，在第1条指令执行到访存（MEM）阶段的时候，流水线里的第4条指令，在执行取指令（Fetch）的操作。访存和取指令，都要进行内存数据的读取。我们的内存，只有一个地址译码器的作为地址输入，那就只能在一个时钟周期里面读取一条数据，没办法同时执行第1条指令的读取内存数据和第4条指令的读取指令代码。

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\22-1.jpg)

“全键无冲”这样的资源冲突解决方案，其实本质就是增加资源。同样的方案，我们一样可以用在CPU的结构冒险里面。对于访问内存数据和取指令的冲突，**一个直观的解决方案就是把我们的内存分成两部分**，让它们各有各的地址译码器。**这两部分分别是存放指令的程序内存和存放数据的数据内存。**

这样把内存拆成两部分的解决方案，在计算机体系结构里叫作哈佛架构。

*不过，我们今天使用的CPU，仍然是冯·诺依曼体系结构的，并没有把内存拆成程序内存和数据内存这两部分。*因为如果那样拆的话，**对程序指令和数据需要的内存空间，我们就没有办法根据实际的应用去动态分配了。虽然解决了资源冲突的问题，但是也失去了灵活性。**

不过，借鉴了哈佛结构的思路，现代的CPU虽然没有在内存层面进行对应的拆分，却在CPU内部的高速缓存部分进行了区分，把**高速缓存分成了指令缓存（Instruction Cache）和数据缓存（Data Cache）两部分。**

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\22-2.jpg)

内存的访问速度远比CPU的速度要慢，**所以现代的CPU并不会直接读取主内存。它会从主内存把指令和数据加载到高速缓存中，这样后续的访问都是访问高速缓存。**而指令缓存和数据缓存的拆分，使得我们的CPU在进行数据访问和取指令的时候，不会再发生资源冲突的问题了。

## 数据冒险：三种不同的依赖关系

数据冒险，其实就是同时在执行的多个指令之间，有数据依赖的情况。这些数据依赖，我们可以分成三大类，分别是先写后读（Read After Write，RAW）、先读后写（Write After Read，WAR）和写后再写（Write After Write，WAW）。

### 先写后读

我们需要保证，在内存地址为16的指令读取rbp-0x4里面的值之前，内存地址12的指令写入到rbp0x4的操作须完成。这就是先写后读所面临的数据依赖。如果这个顺序保证不了，我们的程序就会出错。

这个先写后读的依赖关系，我们一般被称之为**数据依赖**，也就是Data Dependency。

### 先读后写

如果我们在内存地址18的eax的写入先完成了，在内存地址为15的代码里面取出 eax 才发生，我们的程序计算就会出错。这里，我们同样要保障对于eax的先读后写的操作顺序。

这个先读后写的依赖，一般被叫作**反依赖**，也就是Anti-Dependency。

### 写后再写

在这个情况下，你会看到，内存地址4所在的指令和内存地址b所在的指令，都是将对应的数据写入到 rbp0x4的内存地址里面。如果内存地址b的指令在内存地址4的指令之后写入。那么这些指令完成之后，rbp0x4 里数据就是错误的。这就会导致后续需要使用这个内存地址里的数据指令，没有办法拿到正确的值。所以，我们也需要保障内存地址4的指令的写入，在内存地址b的指令的写入之前完成。

这个写后再写的依赖，一般被叫作**输出依赖**，也就是Output Dependency。

## 再等等：通过流水线停顿解决数据冒险

如果我们发现了后面执行的指令，会对前面执行的指令有数据层面的依赖关系，那最简单的办法就是“再等等”。**我们在进行指令译码的时候，会拿到对应指令所需要访问的寄存器和内存地址。所以，在这个时候，我们能够判断出来，这个指令是否会触发数据冒险。**如果会触发数据冒险，我们就可以决定，让整个流水线停顿一个或者多个周期。

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\22-3.jpg)

我在前面说过，时钟信号会不停地在0和1之前自动切换。*其实，我们并没有办法真的停顿下来。流水线的每一个操作步骤必须要干点儿事情。所以，在实践过程中，我们并不是让流水线停下来，而是在执行后面的操作步骤前面，插入一个NOP操作，也就是执行一个其实什么都不干的操作。*

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\22-4.jpg)

## 总结

一方面，我们可以通过增加资源来解决结构冒险问题。我们现代的CPU的体系结构，其实也是在冯·诺依曼体系结构下，借鉴哈佛结构的一个混合结构的解决方案。我们的内存虽然没有按照功能拆分，但是**在高速缓存层面进行了拆分，也就是拆分成指令缓存和数据缓存这样的方式，从硬件层面，使得同一个时钟下对于相同资源的竞争不再发生。**

另一方面，我们也可以通过“等待”，也就是插入无效的NOP操作的方式，来解决冒险问题。这就是所谓的流水线停顿。不过，**流水线停顿这样的解决方案，是以牺牲CPU性能为代价的。因为，实际上在最差的情况下，我们的流水线架构的CPU，又会退化成单指令周期的CPU了。**