## 为什么我们需要程序栈？

从一个非常简单的C程序function_example.c看起。

```c++
#include<stdio.h>
int static add(int a,int b){
    return a+b;
}
int main(){
    int x=5;
    int y=10;
    int u=add(x,y)
}
```

把这个程序编译之后，objdump出来。我们来看一看对应的汇编代码。

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\7-1.jpg)

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\7-2.jpg)

可以看到，add函数编译之后，代码先执行了一条push指令和一条mov指令；在函数执行结束的时候，又执行了一条pop和一条ret指令。这四条指令的执行，其实就是在进行我们接下来要讲压栈（Push）和出栈（Pop）操作。

跳转区别：if…else和for/while的跳转，是跳转走了就不再回来了，就在跳转后的新地址开始顺序地执行指令。

那我们有没有一个可以不跳转回到原来开始的地方，来实现函数的调用呢？

#### 方法一

直觉上似乎有这么一个解决办法。你可以把调用的函数指令，直接插入在调用函数的地方，替换掉对应的call指令，然后在编译器编译代码的时候，直接就把函数调用变成对应的指令替换掉。

不过，仔细琢磨一下，你会发现这个方法有些问题。**如果函数A调用了函数B，然后函数B再调用函数A，我们就得面临在A里面插入B的指令，然后在B里面插入A的指令，这样就会产生无穷无尽地替换。**

#### 方法二

看来，把被调用函数的指令直接插入在调用处的方法行不通。那我们就换一个思路，能不能**把后面要跳回来执行的指令地址给记录下来**呢？就像前面讲PC寄存器一样，我们可以**专门设立一个“程序调用寄存器”，来存储接下来要跳转回来执行的指令地址。等到函数调用结束，从这个寄存器里取出地址，再跳转到这个记录的地址**，继续执行就好了。

但是在多层函数调用里，简单只记录一个地址也是不够的。我们在调用函数A之后，A还可以调用函数B，B还能调用函数C。这一层又一层的调用并没有数量上的限制。在所有函数调用返回之前，每一次调用的返回地址都要记录下来，但是我们**CPU里的寄存器数量并不多。像我们一般使用的Intel	i7	CPU只有16个64位寄存器，调用的层数一多就存不下了。**

#### 方法三

**在内存里面开辟一段空间，用栈这个后进先出（LIFO，Last	In	First	Out）的数据结构。**栈就像一个乒乓球桶，每次程序调用函数之前，我们都把调用返回后的地址写在一个乒乓球上，然后塞进这个球桶。这个操作其实就是我们常说的压栈。如果函数执行完了，我们就从球桶里取出最上面的那个乒乓球，很显然，这就是出栈。

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\7-3.jpg)

实际的程序栈布局，顶和底与我们的乒乓球桶相比是倒过来的。**底在最上面，顶在最下面，这样的布局是因为栈底的内存地址是在一开始就固定的。而一层层压栈之后，栈顶的内存地址是在逐渐变小而不是变大。**

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\7-4.jpg)

**add函数的第0行，push	rbp这个指令，就是在进行压栈。这里的rbp又叫栈帧指针（Frame	Pointer），是一个存放了当前栈帧位置的寄存器。push	rbp就把之前调用函数的返回地址，压到栈顶。接着，第1行的一条命令mov	rbp,	rsp里，则是把rsp这个栈指针（Stack	Pointer）的值复制到rbp里，而rsp始终会指向栈顶。这个命令意味着，rbp这个栈帧指针指向的返回地址，变成当前最新的栈顶，也就是add函数的返回地址了。**

**而在函数add执行完成之后，又会分别调用第12行的pop	rbp来将当前的栈顶出栈，然后调用第13行的ret指令，将程序的控制权返回到出栈后的栈顶，也就是main函数的返回地址。**

## 如何利用函数内联进行性能优化？

上面我们提到一个方法，把一个实际调用的函数产生的指令，直接插入到的位置，来替换对应的函数调用指令。尽管这个通用的函数调用方案，被我们否决了，但是**如果被调用的函数里，没有调用其他函数，这个方法还是可以行得通的。**

这就是一个常见的编译器进行自动优化的场景，我们通常叫**函数内联（Inline）**。我们只要在GCC编译的时候，加上对应的一个让编译器自动优化的参数-O，编译器就会在可行的情况下，进行这样的指令替换。

```c++
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
int static add(int a, int b){
	return a+b;
}
int main(){
    srand(time(NULL));
    int x = rand() % 5
    int y = rand() % 10;
    int u = add(x, y)
    printf("u = %d\n", u)
}
```

上面的function_example_inline.c的编译出来的汇编代码，没有把add函数单独编译成一段指令顺序，而是在调用u	=	add(x,	y)的时候，直接替换成了一个add指令。

> ​	4c:			01	de																			add				esi,ebx

内联带来的优化是，**CPU需要执行的指令数变少了，根据地址跳转的过程不需要了，压栈和出栈的过程也不用了。**

不过内联并不是没有代价，内联意味着，我们把可以复用的程序指令在调用它的地方完全展开了。**如果一个函数在很多地方都被调用了，那么就会展开很多次，整个程序占用的空间就会变大了。**

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\7-5.jpg)

这样没有调用其他函数，只会被调用的函数，我们一般称之为**叶子函数（或叶子过程）。**

## 总结

我们可以方便地通过压栈和出栈操作，使得程序在不同的函数调用过程中进行转移。而函数内联和栈溢出，一个是我们常常可以选择的优化方案，另一个则是我们会常遇到的程序Bug。

通过加入了程序栈，我们相当于在指令跳转的过程种，加入了一个“记忆”的功能，能在跳转去运行新的指令之后，再回到跳出去的位置，能够实现更加丰富和灵活的指令执行流程。这个也为我们在程序开发的过程中，提供了“函数”这样一个抽象，使得我们在软件开发的过程中，可以复用代码和指令，而不是只能简单粗暴地复制、粘贴代码和指令。