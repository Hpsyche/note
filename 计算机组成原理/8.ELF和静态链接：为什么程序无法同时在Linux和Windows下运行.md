## 编译、链接和装载：拆解程序执行

写好的C语言代码，可以通过编译器编译成汇编代码，然后汇编代码再通过汇编器变成CPU可以理解的机器码，于是CPU就可以执行这些机器码了。你现在对这个过程应该不陌生了，但是这个描述把过程大大简化了。下面，我们一起具体来看，**C语言程序是如何变成一个可执行程序**的。

首先有两个函数

```c++
int	add(int	a,	int	b){
	return	a+b;
}

```

```c++
#include	<stdio.h>
int	main(){
    int	a	=	10;
    int	b	=	5;
    int	c	=	add(a,	b);
    printf("c	=	%d\n",	c);
}
```

通过gcc来编译这两个文件，然后通过objdump命令看看它们的汇编代码。

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\8-1.jpg)

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\8-2.jpg)

再仔细看一下objdump出来的两个文件的代码，会发现两个程序的地址都是从0开始的。如果地址是一样的，程序如果需要通过call指令调用函数的话，它怎么知道应该跳转到哪一个文件里呢？

以上的add_lib.o 以及 link_example.o并不是一个可执行文件（Executable Program），而是目标文件（Object File）。**只有通过链接器（Linker）把多个目标文件以及调用的各种函数库链接起来，我们才能得到一个可执行文件。**

**实际上，“C语言代码-汇编代码-机器码”	这个过程，在我们的计算机上进行的时候是由两部分组成的。**

* 第一个部分由编译（Compile）、汇编（Assemble）以及链接（Link）三个阶段组成。在这三个阶段完成之后，我们就生成了一个可执行文件。
* 第二部分，我们通过装载器（Loader）把可执行文件装载（Load）到内存中。CPU从内存中读取指令和数据，来开始真正执行程序。

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\8-3.jpg)

## ELF格式和链接：理解链接过程

程序最终是通过装载器变成指令和数据的，所以其实我们生成的可执行代码也并不仅仅是一条条的指令。我们还是通过objdump指令，把可执行文件的内容拿出来看看。

你会发现，可执行代码dump出来内容，和之前的目标代码长得差不多，但是长了很多。因为**在Linux下，可执行文件和目标文件所使用的都是一种叫ELF（Execuatable and Linkable File Format）的文件格式，中文名字叫可执行与可链接文件格式，这里面不仅存放了编译成的汇编指令，还保留了很多别的数据。**

比如我们过去所有objdump出来的代码里，你都可以看到对应的函数名称，像add、main等等，乃至你自己定义的全局可以访问的变量名称，都存放在这个ELF格式文件里。*这些名字和它们对应的地址，在ELF文件里面，存储在一个叫作符号表（Symbols Table）的位置里。*符号表相当于一个地址簿，把名字和地址关联了起来。

我们先只关注和我们的add以及main函数相关的部分。你会发现，这里面，**main函数里调用add的跳转地址，不再是下一条指令的地址了，而是add函数的入口地址了，这就是EFL格式和链接器的功劳。**

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\8-4.jpg)

ELF文件格式把各种信息，分成一个一个的Section保存起来。**ELF有一个基本的文件头（File	Header），用来表示这个文件的基本属性，比如是否是可执行文件，对应的CPU、操作系统等等。**除了这些基本属性之外，大部分程序还有这么一些Section：

* .text Section，也叫作代码段或者指令段（Code Section），**用来保存程序的代码和指令；**
* .data Section，也叫作数据段（Data Section），用来**保存程序里面设置好的初始化数据信息；**
* .rel.text Secion，叫作重定位表（Relocation	Table）。**重定位表里，保留的是当前的文件里面，哪些跳转地址其实是我们不知道的。**比如上面的link_example.o	里面，我们在main函数里面调用了add和printf这两个函数，但是在链接发生之前，我们并不知道该跳转到哪里，这些信息就会存储在重定位表里；
* .symtab	Section，叫作符号表（Symbol	Table）。符号表保留了我们所说的**当前文件里面定义的函数名称和对应地址的地址簿。**

**链接器会扫描所有输入的目标文件，然后把所有符号表里的信息收集起来，构成一个全局的符号表。然后再根据重定位表，把所有不确定要跳转地址的代码，根据符号表里面存储的地址，进行一次修正。最后，把所有的目标文件的对应段进行一次合并，变成了最终的可执行代码。这也是为什么，可执行文件里面的函数调用的地址都是正确的。**

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\8-5.jpg)

在链接器把程序变成可执行文件之后，要装载器去执行程序就容易多了。**装载器不再需要考虑地址跳转的问题，只需要解析 ELF 文件，把对应的指令和数据，加载到内存里面供CPU执行就可以了。**

## 总结延伸

讲到这里，相信你已经猜到，为什么同样一个程序，在Linux下可以执行而在Windows下不能执行了。其中一个非常重要的原因就是，**两个操作系统下可执行文件的格式不一样。**

**Linux下的是ELF文件格式，而Windows的可执行文件格式是一种叫作PE（Portable ExecutableFormat）的文件格式。Linux下的装载器只能解析ELF格式而不能解析PE格式。**





