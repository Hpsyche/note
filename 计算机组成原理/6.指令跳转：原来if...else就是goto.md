## CPU是如何执行指令的？

拿我们用的Intel	CPU来说，里面差不多有几百亿个晶体管。实际上，一条条计算机指令执行起来非常复杂。好在CPU在软件层面已经为我们做好了封装。对于我们这些做软件的程序员来说，我们只要知道，写好的代码变成了指令之后，是一条一条顺序执行的就可以了。

我们先不管几百亿的晶体管的背后是怎么通过电路运转起来的，逻辑上，我们可以认为，**CPU其实就是由一堆寄存器组成的。而寄存器就是CPU内部，由多个触发器（Flip-Flop）或者锁存器（Latches）组成的简单电路。**

N个触发器或者锁存器，就可以组成一个N位（Bit）的寄存器，能够保存N位的数据。比方说，我们用的64位Intel服务器，寄存器就是64位的。

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\6-1.PNG)

一个CPU里面会有很多种不同功能的寄存器。

* PC寄存器（Program	Counter	Register），我们也叫指令地址寄存器（Instruction Address Register）。顾名思义，它就是用来存放下一条需要执行的计算机指令的内存地址。
* 指令寄存器（Instruction Register），用来存放当前正在执行的指令。
* 条件码寄存器（Status Register），用里面的一个一个标记位（Flag），存放CPU进行算术或者逻辑计算的结果。
* 除了这些特殊的寄存器，CPU里面还有更多用来存储数据和内存地址的寄存器。这些寄存器既可以存放数据，又能存放地址，我们就叫它通用寄存器。

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\6-2.PNG)

一个程序执行的时候，CPU会根据PC寄存器里的地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。可以看到，一个程序的一条条指令，在内存里面是连续保存的，也会一条条顺序加载。

而有些特殊指令，比如上一讲我们讲到J类指令，也就是**跳转指令，会修改PC寄存器里面的地址值。这样，下一条要执行的指令就不是从内存里面顺序加载的了**。**事实上，这些跳转指令的存在，也是我们可以在写程序的时候，使用if…else条件语句和while/for循环语句的原因。**

## 从if…else来看程序的执行和跳转

```c
#include<time.h>
#include<stdlib.h>

int main(){
    srand(time(NULL));
    int r=rand()%2;
    int a=10;
    if(r==0){
        a=1;
    }else{
        a=2;
    }
}
```

我们把这个程序编译成汇编代码。你可以忽略前后无关的代码，只关注于这里的if…else条件判断语句。对应的汇编代码是这样的：

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\6-3.PNG)

可以看到，这里对于r	==	0的条件判断，被编译成了cmp和jne这两条指令。

cmp指令比较了前后两个操作数的值，这里的DWORD	PTR代表操作的数据类型是32位的整数，而[rbp-0x4]则是一个寄存器的地址。所以，**第一个操作数就是从寄存器里拿到的变量r的值。第二个操作数0x0就是我们设定的常量0的16进制表示。cmp指令的比较结果，会存入到<font color=red>条件码寄存器</font>当中去。**

在这里，**如果比较的结果是False，也就是0，就把零标志条件码（对应的条件码是ZF，Zero	Flag）设置为1。**除了零标志之外，Intel的CPU下还有进位标志（CF，Carry	Flag）、符号标志（SF，Sign	Flag）以及出标志（OF，Overflow	Flag），用在不同的判断条件下。

**cmp指令执行完成之后，PC寄存器会自动自增，开始执行下一条jne的指令。**

跟着的jne指令，**是jump	if	not	equal的意思，它会查看对应的零标志位。如果为0，会跳转到后面跟着的操作数4a的位置。**这个4a，对应这里汇编代码的行号，也就是上面设置的else条件里的第一条指令。当跳转发生的时候，PC寄存器就不再是自增变成下一条指令的地址，而是被直接设置成这里的4a这个地址。这个时候，CPU再把4a地址里的指令加载到指令寄存器中来执行。

跳转到执行地址为4a的指令，实际是一条mov指令，第一个操作数和前面的cmp指令一样，是另一个32位整型的寄存器地址，以及对应的2的16进制值0x2。**mov指令把2设置到对应的寄存器里去，相当于一个赋值操作**。然后，**PC寄存器里的值继续自增，执行下一条mov指令。**

mov指令的第一个操作数eax，代表累加寄存器，第二个操作数0x0则是16进制的0的表示。这条指令其实没有实际的作用，它的作用是一个占位符。我们回过头去看前面的if条件，如果满足的话，在赋值的mov指令执行完成之后，有一个jmp的无条件跳转指令。跳转的地址就是这一行的地址51。

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\6-4.PNG)

读取打孔卡的机器会顺序地一段一段地读取指令，然后执行。执行完一条指令，它会自动地顺序读取下一条指令。如果执行的当前指令带有跳转的地址，比如往后跳10个指令，那么机器会自动将卡片带往后移动10个指令的位置，再来执行指令。同样的，机器也能向前移动，去读取之前已经执行过的指令。这也就是我们的while/for循环实现的原理。

## 如何通过if…else和goto来实现循环？

```c
int main(){
    int a=0;
    for(int i=0;i<3;i++){
        a+=1;
    }
}
```

对应的Intel汇编代码就是这样的：

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\6-5.PNG)

可以看到，对应的循环也是用1e这个地址上的cmp比较指令，和紧接着的jle条件跳转指令来实现的。主要的差别在于，这里的jle跳转的地址，在这条指令之前的地址14，而非if…else编译出来的跳转指令之后。往前跳转使得条件满足的时候，PC寄存器会把指令地址设置到之前执行过的指令位置，重新执行之前执行过的指令，直到条件不满足，顺序往下执行jle之后的指令，整个循环才结束。

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\6-6.PNG)

如果你看一长条打孔卡的话，就会看到卡片往后移动一段，执行了之后，又反向移动，去重新执行前面的指
令。

## 总结

你会发现，虽然我们可以用高级语言，可以用不同的语法，比如	if…else	这样的条件分支，或者	while/for这样的循环方式，来实现不用的程序运行流程，但是回归到计算机可以识别的机器指令级别，其实都只是一个简单的地址跳转而已，也就是一个类似于goto的语句。

想要在硬件层面实现这个goto语句，除了本身需要用来保存下一条指令地址，以及当前正要执行指令的PC寄存器、指令寄存器外，我们只需要再增加一个条件码寄存器，来保留条件判断的状态。这样简简单单的三个寄存器，就可以实现条件判断和循环重复执行代码的功能。

