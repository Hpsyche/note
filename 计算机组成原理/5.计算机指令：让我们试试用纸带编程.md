## 在软硬件接口中，CPU帮我们做了什么事？

从硬件的角度来看，CPU就是一个超大规模集成电路，通过电路实现了加法、乘法乃至各种各样的处理逻辑。

从软件工程师的角度来讲，CPU就是一个执行各种计算机指令（Instruction	Code）的逻辑机器。这里的计算机指令，就好比一门CPU能够听得懂的语言，我们也可以把它叫作机器语言（Machine Language）。

一个计算机程序，不可能只有一条指令，而是由成千上万条指令组成的。但是CPU里不能一直放着所有指令，所以计算机程序平时是存储在存储器中的。这种程序指令存储在存储器里面的计算机，我们就叫作存储程序型计算机（Stored-program Computer）。

## 从编译到汇编，代码怎么变成机器码？

平时编写的代码，到底是怎么变成一条条计算机指令，最后被CPU执行的呢？我们拿一小段真实的C语言程序来看看。

```c
int main()
{
    int	a	=	1;	
    int	b	=	2;
    a	=	a	+	b;
}

```

要让这段程序在一个Linux操作系统上跑起来，我们需要把整个程序翻译成一个汇编语言（ASM，Assembly Language）的程序，这个过程我们一般叫**编译（Compile）成汇编代码。**

**针对汇编代码，我们可以再用汇编器（Assembler）翻译成机器码（Machine	Code）。这些机器码由“0”和“1”组成的机器语言表示。**这一条条机器码，就是一条条的计算机指令。这样一串串的16进制数字，就是我们CPU能够真正认识的计算机指令。

在一个Linux操作系统上，我们可以简单地使用gcc和objdump这样两条命令，把对应的汇编代码和机器码都打印出来。

```shell
$	gcc	-g	-c	test.c
$	objdump	-d	-M	intel	-S	test.o
```

可以看到，左侧有一堆数字，这些就是一条条机器码；右边有一系列的push、mov、add、pop等，这些就是对应的汇编代码。一行C语言代码，有时候只对应一条机器码和汇编代码，有时候则是对应两条机器码和汇编代码。汇编代码和机器码之间是一一对应的。

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\5-1.png)

这个时候你可能又要问了，我们实际在用GCC（GUC编译器套装，GUI	Compiler	Collectipon）编译器的时候，可以直接把代码编译成机器码呀，为什么还需要汇编代码呢？原因很简单，**因为汇编代码其实就是“给程序员看的机器码”**，也正因为这样，机器码和汇编代码是一一对应的。

从高级语言到汇编代码，再到机器码，就是一个日常开发程序，最终变成了CPU可以执行的计算机指令的过程。

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\5-3.png)

## 解析指令和机器码

一般来说，常见的指令可以分成五大类。

* 算术类指令。我们的加减乘除，在CPU层面，都会变成一条条算术类指令。
* 数据传输类指令。给变量赋值、在内存里读写数据，用的都是数据传输类指令。
* 逻辑类指令。逻辑上的与或非，都是这一类指令。
* 条件分支类指令。日常我们写的“if/else”，其实都是条件分支类指令。
* 无条件跳转指令。写一些大一点的程序，我们常常需要写一些函数或者方法。在调用函数的时
  候，其实就是发起了一个无条件跳转指令。

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\5-2.png)

下面我们来看看，汇编器是怎么把对应的汇编代码，翻译成为机器码的。

我们选用最简单的MIPS指令集，来看看机器码是如何生成的。

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\5-4.png)

以一个简单的加法算术指令add $t0, $s1, $s2,为例，给你解释。为了方便，我们下面都用十进制来表示对应的代码。

MIPS的指令是一个32位的整数，高6位叫操作码（Opcode），也就是代表这条指令具体是一条什么样的指令，剩下的26位有三种格式，分别是R、I和J。

**R指令**是一般用来做算术和逻辑操作，里面有读取和写入数据的寄存器的地址。如果是逻辑位移操作，后面还有位移操作的位移量，而最后的功能码，则是在前面的操作码不够的时候，扩展操作码表示对应的具体指令的。

**I指令**，则通常是用在数据传输、条件分支，以及在运算的时候使用的并非变量还是常数的时候。这个时候，没有了位移量和操作码，也没有了第三个寄存器，而是把这三部分直接合并成了一个地址值或者一个常数。

**J指令**就是一个跳转指令，高6位之外的26位都是一个跳转后的地址。

以一个简单的加法算术指令add $t0, $s1, $s2,为例，给你解释。为了方便，我们下面都用十进制来表示对应的代码。

假设rs代表第一个寄存器s1的地址是17，rt代表第二个寄存器s2的地址是18，rd代表目标的临时寄存器t0的地址，是8。因为不是位移操作，所以位移量是0。把这些数字拼在一起，就变成了一个MIPS的加法指令。

为了读起来方便，我们一般把对应的二进制数，用16进制表示出来。在这里，也就是0X02324020。**这个数字也就是这条指令对应的机器码。**

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\5-5.png)

回到开头我们说的打孔带。如果我们用打孔代表1，没有打孔代表0，用4行8列代表一条指令来打一个穿孔纸带，那么这条命令大概就长这样：

![](D:\Work\TyporaNotes\note\计算机组成原理\pict\5-6.png)

## 总结

这一讲里，我们看到了一个C语言程序，是怎么被编译成为汇编语言，乃至通过汇编器再翻译成机器码的。

除了C这样的编译型的语言之外，不管是Python这样的解释型语言，还是Java这样使用虚拟机的语言，其实最终都是由不同形式的程序，把我们写好的代码，转换成CPU能够理解的机器码来执行的。

只是解释型语言，是通过解释器在程序运行的时候逐句翻译，而**Java这样使用虚拟机的语言，则是由虚拟机对编译出来的中间代码进行解释，或者即时编译成为机器码来最终执行。**

