之前开发过一个秒杀系统：

1. 前端限流，5 秒内只提交一个请求，静态资源存放于 CDN。
2. 后端 redis 对 uid 限流，同样 5 秒内提交一个请求。
3. 请求保存队列，队列长度为库存 2 倍。为什么是 2 倍呢？拍脑门决定的，防止前面预订失败，后面补上。
4. 队列满后，后续请求直接返回秒杀结束。
5. 消费线程消费队列内容，下订单，直接操作 MySQL 扣库存。

## 秒杀系统设计关键点  

**秒杀其实主要解决两个问题，一个是并发读，一个是并发写**。并发读的核心优化理念是尽量减少用户到服务端来“读”数据，或者让他们读更少的数据；并发写的处理原则也一样，它要求我们在数据库层面独立出来一个库，做特殊的处理。

**秒杀的整体架构可以概括为“稳、准、快”几个关键字。**

所谓“稳”，就是整个系统架构要满足高可用，流量符合预期时肯定要稳定，就是超出预期时也同样不能掉链子，你要保证秒杀活动顺利完成，即秒杀商品顺利地卖出去，这个是最基本的前提。

然后就是“准”，就是秒杀 10 台 iPhone，那就只能成交 10 台，多一台少一台都不行。一旦库存不对，那平台就要承担损失，所以“准”就是要求保证数据的一致性。

最后再看“快”，“快”其实很好理解，它就是说系统的性能要足够高，否则你怎么支撑这么大的流量呢？不光是服务端要做极致的性能优化，而且在整个请求链路上都要做协同的优化，每个地方快一点，整个系统就完美了。

## 动静分离

最早的秒杀系统其实是要刷新整体页面的，但后来秒杀的时候，你只要点击“刷新抢宝”按钮就够了，这种变化的本质就是动静分离，分离之后，客户端大幅度减少了请求的数据量。这不自然就“快”了吗？

那到底什么才是动静分离呢？所谓“动静分离”，其实就是把用户请求的数据（如 HTML 页面）划分为“动态数据”和“静态数据”。

简单来说，**“动态数据”和“静态数据”的主要区别就是看页面中输出的数据是否和 URL、浏览者、时间、地域相关，以及是否含有 Cookie 等私密数据**。比如说：

那么，怎样对静态数据做缓存呢？我在这里总结了几个重点。

**第一，你应该把静态数据缓存到离用户最近的地方**。静态数据就是那些相对不会变化的数据，因此我们可以把它们缓存起来。缓存到哪里呢？常见的就三种，用户浏览器里、CDN 上或者在服务端的 Cache 中。你应该根据情况，把它们尽量缓存到离用户最近的地方。

**第二，静态化改造就是要直接缓存 HTTP 连接**。相较于普通的数据缓存而言，你肯定还听过系统的静态化改造。静态化改造是直接缓存 HTTP 连接而不是仅仅缓存数据，如下图所示，Web 代理服务器根据请求 URL，直接取出对应的 HTTP 响应头和响应体然后直接返回，这个响应过程简单得连 HTTP 协议都不用重新组装，甚至连 HTTP 请求头也不需要解析。

## 流量削峰

流量削峰的一些操作思路：排队、答题、分层过滤。这几种方式都是无损（即不会损失用户的发出请求）的实现方案，当然还有些有损的实现方案，包括我们后面要介绍的关于稳定性的一些办法，比如限流和机器负载保护等一些强制措施也能达到削峰保护的目的，当然这都是不得已的一些措施，因此就不归类到这里了。

### 排队

要对流量进行削峰，最容易想到的解决方案就是用消息队列来缓冲瞬时流量，把同步的直接调用转换成异步的间接推送，中间通过一个队列在一端承接瞬时的流量洪峰，在另一端平滑地将消息推送出去。在这里，消息队列就像“水库”一样，	拦蓄上游的洪水，削减进入下游河道的洪峰流量，从而达到减免洪水灾害的目的。

除了消息队列，类似的排队方式还有很多，例如：

1. 利用线程池加锁等待也是一种常用的排队方式；
2. 先进先出、先进后出等常用的内存排队算法的实现方式；
3. 把请求序列化到文件中，然后再顺序地读文件（例如基于 MySQL binlog 的同步机制）来恢复请求等方式。

### 分层过滤

请求分别经过 CDN、前台读系统（如商品详情系统）、后台系统（如交易系统）和数据库这几层，那么：

- 大部分数据和流量在用户浏览器或者 CDN 上获取，这一层可以拦截大部分数据的读取；
- 经过第二层（即前台系统）时数据（包括强一致性的数据）尽量得走 Cache，过滤一些无效的请求；
- 再到第三层后台系统，主要做数据的二次检验，对系统做好保护和限流，这样数据量和请求就进一步减少；
- 最后在数据层完成数据的强一致性校验。

## 减库存

### 减库存有哪几种方式

在正常的电商平台购物场景中，用户的实际购买过程一般分为两步：下单和付款。你想买一台 iPhone 手机，在商品页面点了“立即购买”按钮，核对信息之后点击“提交订单”，这一步称为下单操作。下单之后，你只有真正完成付款操作才能算真正购买，也就是俗话说的“落袋为安”。

那如果你是架构师，你会在哪个环节完成减库存的操作呢？总结来说，减库存操作一般有如下几个方式：

- **下单减库存**，即当买家下单后，在商品的总库存中减去买家购买数量。下单减库存是最简单的减库存方式，也是控制最精确的一种，下单时直接通过数据库的事务机制控制商品库存，这样一定不会出现超卖的情况。但是你要知道，有些人下完单可能并不会付款。
- **付款减库存**，即买家下单后，并不立即减库存，而是等到有用户付款后才真正减库存，否则库存一直保留给其他买家。但因为付款时才减库存，如果并发比较高，有可能出现买家下单后付不了款的情况，因为可能商品已经被其他人买走了。
- **预扣库存**，这种方式相对复杂一些，买家下单后，库存为其保留一定的时间（如 10 分钟），超过这个时间，库存将会自动释放，释放后其他买家就可以继续购买。在买家付款前，系统会校验该订单的库存是否还有保留：如果没有保留，则再次尝试预扣；如果库存不足（也就是预扣失败）则不允许继续付款；如果预扣成功，则完成付款并实际地减去库存。

### 减库存可能存在的问题

“下单减库存”的方式，即用户下单后就减去库存，正常情况下，买家下单后付款的概率会很高，所以不会有太大问题。但是有一种场景例外，就是当卖家参加某个活动时，此时活动的有效时间是商品的黄金售卖时间，如果有竞争对手通过恶意下单的方式将该卖家的商品全部下单，让这款商品的库存减为零，那么这款商品就不能正常售卖了。

"付款减库存”问题：假如有 100 件商品，就可能出现 300 人下单成功的情况，因为下单时不会减库存，所以也就可能出现下单成功数远远超过真正库存数的情况，这尤其会发生在做活动的热门商品上。这样一来，就会导致很多买家下单成功但是付不了款，买家的购物体验自然比较差。

“预扣库存”：针对恶意下单这种情况，虽然把有效的付款时间设置为 10 分钟，但是恶意买家完全可以在 10 分钟后再次下单，或者采用一次下单很多件的方式把库存减完。针对这种情况，解决办法还是要结合安全和反作弊的措施来制止。
例如，给经常下单不付款的买家进行识别打标（可以在被打标的买家下单时不减库存）、给某些类目设置最大购买件数（例如，参加活动的商品一人最多只能买 3 件），以及对重复下单不付款的操作进行次数限制等。

### 大型秒杀中如何减库存？

目前来看，业务系统中最常见的就是预扣库存方案，像你在买机票、买电影票时，下单后一般都有个“有效付款时间”，超过这个时间订单自动释放，这都是典型的预扣库存方案。而具体到秒杀这个场景，应该采用哪种方案比较好呢？

由于参加秒杀的商品，一般都是“抢到就是赚到”，所以成功下单后却不付款的情况比较少，再加上卖家对秒杀商品的库存有严格限制，所以秒杀商品采用“下单减库存”更加合理。另外，理论上由于“下单减库存”比“预扣库存”以及涉及第三方支付的“付款减库存”在逻辑上更为简单，所以性能上更占优势。

“下单减库存”在数据一致性上，主要就是保证大并发请求时库存数据不能为负数，也就是要保证数据库中的库存字段值不能为负数，一般我们有多种解决方案：一种是在应用程序中通过事务来判断，即保证减后库存不能为负数，否则就回滚；另一种办法是直接设置数据库的字段数据为无符号整数，这样减后库存字段值小于零时会直接执行 SQL 语句来报错；再有一种就是使用 CASE WHEN 判断语句，例如这样的 SQL 语句：

```sql
UPDATE item SET inventory = CASE WHEN inventory >= xxx THEN inventory-xxx ELSE inventory END
```

## 秒杀减库存的极致优化

秒杀商品和普通商品的减库存还是有些差异的，例如商品数量比较少，交易时间段也比较短，因此这里有一个大胆的假设，即能否把秒杀商品减库存直接放到缓存系统中实现，也就是直接在缓存中减库存或者在一个带有持久化功能的缓存系统（如 Redis）中完成呢？

如果你的秒杀商品的减库存逻辑非常单一，比如没有复杂的 SKU 库存和总库存这种联动关系的话，我觉得完全可以。但是如果有比较复杂的减库存逻辑，或者需要使用事务，你还是必须在数据库中完成减库存。

由于 MySQL 存储数据的特点，同一数据在数据库里肯定是一行存储（MySQL），因此会有**大量线程来竞争 InnoDB 行锁**，而并发度越高时等待线程会越多，TPS（Transaction Per Second，即每秒处理的消息数）会下降，响应时间（RT）会上升，数据库的吞吐量就会严重受影响。

这就可能引发一个问题，就是单个热点商品会影响整个数据库的性能， **导致 0.01% 的商品影响 99.99% 的商品的售卖**，这是我们不愿意看到的情况。一个解决思路是遵循前面介绍的原则进行隔离，**把热点商品放到单独的热点库中**。但是这无疑会带来维护上的麻烦，比如要做热点数据的动态迁移以及单独的数据库等。

而分离热点商品到单独的数据库还是没有解决并发锁的问题，我们应该怎么办呢？要解决并发锁的问题，有两种办法：

- **应用层做排队**。按照商品维度设置队列顺序执行，这样能减少同一台机器对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用数据库连接的数量，防止热点商品占用太多的数据库连接。
- **数据库层做排队**。应用层只能做到单机的排队，但是应用机器数本身很多，这种排队方式控制并发的能力仍然有限，所以如果能在数据库层做全局排队是最理想的。阿里的数据库团队开发了针对这种 MySQL 的 InnoDB 层上的补丁程序（patch），可以在数据库层上对单行记录做到并发排队。

## 库存超卖的解决方案

1.数据库层面解决方案：

    这种方式实现起来最简单，就是利用乐观锁。
    
    update product set num=num-1 where num-1>0 and pid=#{pid}
    
    使用此方法一定要注意，set num 时一定不要使用，set num=#{num},这样做的话不能保证原子化操作，并发还是会有问题（覆盖更新）。
    
    缺点：数据库存在瓶颈，首先是连接数，更重要是多个请求更新一条数据，会互相检查是否死锁（笛卡尔积）。而秒杀问题就是请求量大并发高。那怎么办？继续看小老弟说咯。

2.使用缓存（Redis等）解决方案：

    使用缓存确实可以解决数据库瓶颈的问题，例如Redis天然的串行化操作（Redis单线程），并且在数据内存中做操作很快。
    
    使用Redis的自增incr或自减decr操作库存，判断返回结果是否为0，如果为0表示秒杀失败。这样不就保证了库存的不超卖。
1.每次我们通过Redis查询库存都是通过远程连接的方式，虽然很快，但是并发大的时候，这里还是要优化一下的。

怎么优化？简单的说就是，当发现Redis库存为0时，我们在程序中设置一个标识位，秒杀逻辑中每次进来先判断标志位。这样库存为0时就直接返回，而不用再远程连接查询Redis了。

你可能会说这样就行了吧？对于一般的秒杀来说应该可以了，但我还要和大家说说更多的优化和优化时的问题。

2.每次当我们秒杀成功后，会创建订单、通知库房、通知快递等一系列操作，如果我们把这些操作也放在秒杀时来处理，那么我们程序处理起来可想而知，会很慢的。那么这时我们就要优化，怎么优化？

实现异步处理，我们可以通过MQ（RocketMQ等消息队列）来实现异步处理，当用户秒杀成功后，我们发送消息给其他服务，然后返回给用户秒杀结果，这样是不是就很快了呢。对是快了。

那么问题来了：用户秒杀成功后需要付款，但是此时是异步操作，队列可能并没有处理完消息，怎么办怎么办？哈哈，这时我们需要在前端加一个轮询，轮询什么？轮询查询秒杀的结果（象征的意思意思用户，排队中什么什么的了）。下面代码

![](D:\Work\TyporaNotes\note\面试题\pict\32-1.png)

简单讲讲这段代码：首先判断登录就不说了，后面通过用户名查询下当前用户是否秒杀成功了，然后然后问题来了，哈哈为什么我下面要使用了数据库查询？而不是查询缓存中的商品数量是否为0，**因为还是之前的问题，队列没有消化完，用户秒杀成功的记录还没有生成，如果查询数据库商品没有了，那就代表队列已经处理完了，代表你秒杀失败了GG。**如果还有库存，那么返回**success(0)告诉用户排队中**。直到数据库中库存没有了，那么代表队列处理完了，这时候你在查询Redis应该有订单信息的，如果没有那么你真的是秒杀失败了。讲到这里可能大家理会的差不多了，但是这段代码中还是存在问题？什么问题呢，那就是当他查询Redis时队列消息还是没处理她的消息，当他查询数据库之前，队列处理完了，这样你查数据库发现库存没有了，你就会返回秒杀失败，但其实你是秒杀成功的。这样还是会影响用户体验的。你可能会说不能吧，那么巧。哈哈我就是要和你说高并发下这种情况出现很正常。所以呢，我们要防止，怎么防止呢？

终极解决方案：

![](D:\Work\TyporaNotes\note\面试题\pict\32-3.png)

我们在查数据库判断库存为0时(标记：数据库库存为0，消息肯定处理完了，也就是redis肯定有订单了，因为有妹子问了，我必须更新一下哈哈)，我们再次查询Redis里是否已经有生成的订单了，这样就避免了问题咯。这也就是江湖中传闻的江湖秘诀，双重校验锁，哈哈，其实关于秒杀啊高并发的问题还有很多，这类问题每一行代码都是要考虑很多情况的，希望我再这里能给大家一个抛砖引玉的作用。

