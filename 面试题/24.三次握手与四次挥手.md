# 三次握手

## 三次握手简单描述

1、第一次握手：客户端给服务器发送一个 SYN 报文。

2、第二次握手：服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文。

3、第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。

4、服务器收到 ACK 报文之后，三次握手建立完成。

作用是为了**确认双方的接收与发送能力是否正常。**

> 这里我顺便解释一下为啥只有三次握手才能确认双方的接受与发送能力是否正常，而两次却不可以
>
> *  第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。 
> * 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过<font color=red>此时服务器并不能确认客户端的接收能力是否正常。</font>
> * 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

## 三次握手详细

**刚开始客户端处于 closed 的状态，服务端处于 listen 状态**。然后

1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号**ISN(c)**。此时客户端处于 **SYN_Send** 状态。

2、第二次握手：服务器收到客户端的 SYN 报文之后，会<font color=red>以自己的 SYN 报文作为应答</font>，并且也是指定了自己的初始化序列号 ISN(s)，同时<font color=red>会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN</font>，此时服务器处于 **SYN_REVD** 的状态。

3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样<font color=red>把服务器的 ISN + 1 作为 ACK 的值</font>，表示已经收到了服务端的 SYN 报文，此时客户端处于 **establised** 状态。

4、服务器收到 ACK 报文之后，也处于 **establised 状态**，此时，双方以建立起了链接。

![](D:\Work\TyporaNotes\note\面试题\pict\三次握手.jpg)

**三次握手的作用**

1、确认双方的接受能力、发送能力是否正常。

2、指定自己的初始化序列号，为后面的可靠传送做准备。

3、如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到。

## 问答

* **（ISN）是固定的吗**

  三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。

  如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

* **什么是半连接队列**

  服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为**半连接队列**。当然还有一个**全连接队列**，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

* **三次握手过程中可以携带数据吗**

  很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。也就是说，<font color=red>第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。</font>

  为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。

  而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。

# 四次挥手

当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次挥手”。

1. 第一次挥手：主机1（可以使客户端，也可以是服务器端），设置`Sequence Number`和`Acknowledgment Number`，向主机2发送一个`FIN`报文段；此时，<font color=red>主机1进入`FIN_WAIT_1`状态；这表示主机1没有数据要发送给主机2了；</font>
2. 第二次挥手：主机2收到了主机1发送的`FIN`报文段，向主机1回一个`ACK`报文段，<font color=red>`Acknowledgment Number`为`Sequence Number`加1；主机1进入`FIN_WAIT_2`状态</font>；主机2告诉主机1，我“同意”你的关闭请求，此时服务器进入CLOSE_WAIT状态；
3. 第三次挥手：主机2向主机1发送`FIN`报文段，请求关闭连接，同时<font color=red>主机2进入`LAST_ACK`状态；</font>
4. 第四次挥手：<font color=red>主机1收到主机2发送的`FIN`报文段，向主机2发送`ACK`报文段，然后主机1进入`TIME_WAIT`状态；主机2收到主机1的`ACK`报文段以后，就关闭连接；此时，主机1等待2MSL（Maximum Segment Lifetime：报文最大生存时间）后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</font>

![](D:\Work\TyporaNotes\note\面试题\pict\四次挥手.jpg)

## 问答

* **这里特别需要主要的就是TIME_WAIT这个状态了，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭**

  这其中的原因就是，*要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。*

  至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。

* **为什么连接的时候是三次握手，关闭的时候却是四次握手？**

  因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。**只有等到我Server端所有的报文都发送完了，我才能发送FIN报文**，因此不能一起发送。故需要四步握手。

* **如果已经建立了连接，但是客户端突然出现故障了怎么办？**

  TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

  

