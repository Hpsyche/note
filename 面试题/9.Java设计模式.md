# 设计模式

## 普通工厂模式

### 举例说明

例如，有个IProduct的产品接口，它下面有5个实现类Product1-5，它们属于一个大类，可以通过一个工厂去管它们的生成，但是由于类型不同，所以初始化有所不同。为了方便使用产品工厂类来创建这些产品的对象，用户可以通过产品号来确定需要哪种产品。

组装电脑时（只考虑CPU和主板），有以下步骤：

 	1. 用户首先找工程师说明自己的需求1,1，此时工程师会通过相应的工厂去获取相应的实例对象；
 	2. 工程师通知CPU和主办工厂生产1号CPU和1号主办；
 	3. CPU工厂获取到1，生产出了Inter的Cpu，MainBoard工厂获取到1，生产出了Inter的主主板；

上面的时候，用户只需要知道CPU和主板的编号，调用工程师的makeComputer(1,1)方法，即可实现装机的过程；但有以下几个问题没有解决，

* CPU对象和主板对象其实是有关系的，需要相互匹配的，而上面的实现，并没有维护这种关联关系，CPU和主板的选择是客户任意定的；
* 若CPU工厂中有很多产品，过于冗杂。

## 抽象工程模式

由以上，我们引入了抽象工程模式。

首先明白两个概念：产品族和产品等级。

所谓产品族，是指位于不同产品等级结构中，功能相关联的产品组成的家族。比如AMD的主板、芯片组、CPU组成一个家族，Intel的主板、芯片组、CPU组成一个家族。

而这两个家族都来自于三个产品等级：主板、芯片组、CPU。

假设一个子系统需要一些产品对象，而这些产品又属于一个以上的产品等级结构。那么为了将消费这些产品对象的责任和创建这些产品对象的责任分割开来，可以引进抽象工厂模式。

### 举例说明

如：可以抽取一个抽象工程，用以生产CPU和主板，此时在抽象工厂下有intel工厂和amd工厂，专门负责各自产品的生产，客户只需要在选择时选择好自己需要的产品“intel"or"amd"即可组装自己的电脑，不会出现普通工厂的错乱问题。

具体过程如下：

```java
//抽象工厂类
public interface AbstractFactory {
    /**
     * 创建CPU对象
     * @return CPU对象
     */
    public Cpu createCpu();
    /**
     * 创建主板对象
     * @return 主板对象
     */
    public Mainboard createMainboard();
}

//inter工厂
public class IntelFactory implements AbstractFactory {
    @Override
    public Cpu createCpu() {
        // TODO Auto-generated method stub
        return new IntelCpu(755);
    }
    @Override
    public Mainboard createMainboard() {
        // TODO Auto-generated method stub
        return new IntelMainboard(755);
    }
}

//amd工厂
public class AmdFactory implements AbstractFactory {
    @Override
    public Cpu createCpu() {
        // TODO Auto-generated method stub
        return new IntelCpu(938);
    }

    @Override
    public Mainboard createMainboard() {
        // TODO Auto-generated method stub
        return new IntelMainboard(938);
    }
}

//计算机工程师
public class ComputerEngineer {
    /**
     * 定义组装机需要的CPU
     */
    private Cpu cpu = null;
    /**
     * 定义组装机需要的主板
     */
    private Mainboard mainboard = null;
    public void makeComputer(AbstractFactory af){
        /**
         * 组装机器的基本步骤
         */
        //1:首先准备好装机所需要的配件
        prepareHardwares(af);
        //2:组装机器
        //3:测试机器
        //4：交付客户
    }
    private void prepareHardwares(AbstractFactory af){
        //这里要去准备CPU和主板的具体实现，为了示例简单，这里只准备这两个
        //可是，装机工程师并不知道如何去创建，怎么办呢？
        //直接找相应的工厂获取
        this.cpu = af.createCpu();
        this.mainboard = af.createMainboard();
        //测试配件是否好用
        this.cpu.calculate();
        this.mainboard.installCPU();
    }
}

//客户端
public class Client {
    public static void main(String[]args){
        //创建装机工程师对象
        ComputerEngineer cf = new ComputerEngineer();
        //客户选择并创建需要使用的产品对象
        AbstractFactory af = new IntelFactory();
        //告诉装机工程师自己选择的产品，让装机工程师组装电脑
        cf.makeComputer(af);
    }
}
```

抽象工厂的功能是为一系列相关对象或相互依赖的对象创建一个接口。一定要注意，这个接口内的方法不是任意堆砌的，而是一系列相关或相互依赖的方法。比如上面例子中的主板和CPU，都是为了组装一台电脑的相关对象。不同的装机方案，代表一种具体的电脑系列。

### 使用抽象工厂的情况

1.一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的。

2.这个系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。

3.同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。（比如：Intel主板必须使用Intel CPU、Intel芯片组）

4.系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。

### 抽象工厂模式的优点

- **分离接口和实现**

　　客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，客户端只是面向产品的接口编程而已。也就是说，客户端从具体的产品实现中解耦。

- **使切换产品族变得容易**

　　因为一个具体的工厂实现代表的是一个产品族，比如上面例子的从Intel系列到AMD系列只需要切换一下具体工厂。

### 抽象工厂模式的缺点

- **不太容易扩展新的产品**

　　如果需要给整个产品族添加一个新的产品，那么就需要修改抽象工厂，这样就会导致修改所有的工厂实现类。

## 建造者模式

建造模式是对象的创建模式。建造模式可以将一个产品的内部表象（internal representation）与产品的生产过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。

### 建造者模式中四个角色

**Product（产品角色）：** 一个具体的产品对象。

**Builder（抽象建造者）：** 创建一个Product对象的各个部件指定的抽象接口。

**ConcreteBuilder（具体建造者）：** 实现抽象接口，构建和装配各个部件。

**Director（指挥者）：** 构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。

### 实例分析

**1 ) 一个典型的复杂对象其类代码示例如下：**

```java
public class Product 
{
    private String partA; //可以是任意类型
    private String partB;
    private String partC;
    //partA的Getter方法和Setter方法省略
    //partB的Getter方法和Setter方法省略
    //partC的Getter方法和Setter方法省略
}
```

**2 ) 抽象建造者类中定义了产品的创建方法和返回方法，其典型代码如下：**

```java
public abstract class Builder
{
    protected Product product=new Product();
    
    public abstract void buildPartA();
    public abstract void buildPartB();
    public abstract void buildPartC();
    
    public Product getResult()
    {
        return product;
    }
} 
```

**3 ) 具体建造者。实现抽象接口，构建和装配各个部件,实例代码如下：**

```java
public class ConcreteBuilder extends Builder{
    public void buildPartA(){
    ...
    }
    public void buildPartB(){
    ...
    }
    public void buildPartC(){
    ...
    }
}
```

**4）指挥者类的代码示例如下：**

建造者模式的结构中还引入了一个指挥者类Director，该类的作用主要有两个：一方面<font color=red>它隔离了客户与生产过程</font>；另一方面它负责控制产品的生成过程。<font color=red>指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即**可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。**</font>

```java
public class Director
{
    private Builder builder;
    //1 构造方法的方式注入builder对象
    public Director(Builder builder)
    {
        this.builder=builder;
    }
    //2 set方法注入builder对象
    public void setBuilder(Builder builder)
    {
        this.builder=builer;
    }
    
    public Product construct()
    {
        builder.buildPartA();
        builder.buildPartB();
        builder.buildPartC();
        return builder.getResult();
    }
} 
```

**5 ) 客户端类代码片段：**

在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，**建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现**。

```java
……
Builder builder = new ConcreteBuilder();
Director director = new Director(builder);
Product product = director.construct();
…… 
```

### 建造者模式的优点

1) 客户端不必知道产品内部组成的细节，将**产品本身与产品的创建过程解耦**，使得相同的创建过程可以创建不同的产品对象。

**2)** 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很**方便地替换具体建造者或增加新的具体建造者**， 用户使用不同的具体建造者即可得到不同的产品对象 。

3) **可以更加精细地控制产品的创建过程**。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。

**4) 增加新的具体建造者无须修改原有类库的代码**，指挥者类针对抽象建造者类编程，系统扩展方便，符合开闭原则

* *何为“开闭原则”*

  在面向对象编程领域中，开闭原则规定**“软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的”**，这意味着一个实体是允许在不改变它的源代码的前提下变更它的行为。

### 建造者模式适合什么情况（局限、缺点）

**1) 产品之间差异性很大的情况：** 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。

**2) 产品内部变化很复杂的情况：** 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。

### 抽象工厂模式VS建造者模式

抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。

而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。



## 原型模式

原型模式就是将一个对象作为原型，使用clone()方法来创建新的实例。

要求对象实现一个可以“克隆”自身的接口，这样就可以通过复制一个实例对象本身来创建一个新的实例。这样一来，通过原型实例创建新的对象，就不再需要关心这个实例本身的类型，只要实现了克隆自身的方法，就可以通过这个方法来获取新的对象，而无须再去通过new来创建。

原型模式有两种表现形式：（1）简单形式、（2）登记形式，这两种表现形式仅仅是原型模式的不同实现。

### 简单形式

![](D:\Work\TyporaNotes\note\面试题\pict\原型模式1.png)

这种形式涉及到三个角色：

　　（1）客户(Client)角色：客户类提出创建对象的请求。

　　（2）抽象原型(Prototype)角色：这是一个抽象角色，通常由一个Java接口或Java抽象类实现。此角色给出所有的具体原型类所需的接口。

　　（3）具体原型（Concrete Prototype）角色：被复制的对象。此角色需要实现抽象的原型角色所要求的接口。

### 登记形式

![](D:\Work\TyporaNotes\note\面试题\pict\原型模式2.png)

作为原型模式的第二种形式，它多了一个原型管理器(PrototypeManager)角色，该角色的作用是：创建具体原型类的对象，并记录每一个被创建的对象。

原型管理器角色保持一个聚集，作为对所有原型对象的登记，这个角色<font color=red>提供必要的方法，供外界增加新的原型对象和取得已经登记过的原型对象。</font>

如下：

```java
public class PrototypeManager {
    /**
     * 用来记录原型的编号和原型实例的对应关系
     */
    private static Map<String,Prototype> map = new HashMap<String,Prototype>();
    /**
     * 私有化构造方法，避免外部创建实例
     */
    private PrototypeManager(){}
    /**
     * 向原型管理器里面添加或是修改某个原型注册
     * @param prototypeId 原型编号
     * @param prototype    原型实例
     */
    public synchronized static void setPrototype(String prototypeId , Prototype prototype){
        map.put(prototypeId, prototype);
    }
    /**
     * 从原型管理器里面删除某个原型注册
     * @param prototypeId 原型编号
     */
    public synchronized static void removePrototype(String prototypeId){
        map.remove(prototypeId);
    }
    /**
     * 获取某个原型编号对应的原型实例
     * @param prototypeId    原型编号
     * @return    原型编号对应的原型实例
     * @throws Exception    如果原型编号对应的实例不存在，则抛出异常
     */
    public synchronized static Prototype getPrototype(String prototypeId) throws Exception{
        Prototype prototype = map.get(prototypeId);
        if(prototype == null){
            throw new Exception("您希望获取的原型还没有注册或已被销毁");
        }
        return prototype;
    }
}
```

测试：

```java
public class Client {
    public static void main(String[]args){
        try{
            Prototype p1 = new ConcretePrototype1();
            PrototypeManager.setPrototype("p1", p1);
            //获取原型来创建对象
            Prototype p3 = PrototypeManager.getPrototype("p1").clone();
            p3.setName("张三");
            System.out.println("第一个实例：" + p3);
            //有人动态的切换了实现
            Prototype p2 = new ConcretePrototype2();
            PrototypeManager.setPrototype("p1", p2);
            //重新获取原型来创建对象
            Prototype p4 = PrototypeManager.getPrototype("p1").clone();
            p4.setName("李四");
            System.out.println("第二个实例：" + p4);
            //有人注销了这个原型
            PrototypeManager.removePrototype("p1");
            //再次获取原型来创建对象
            Prototype p5 = PrototypeManager.getPrototype("p1").clone();
            p5.setName("王五");
            System.out.println("第三个实例：" + p5);
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
```

此处使用的是浅拷贝，关于深浅拷贝，看见“12.浅克隆、深克隆”

### 两种形式的比较

​	简单形式和登记形式的原型模式各有其长处和短处。

　　如果需要创建的原型对象数目较少而且比较固定的话，可以采取第一种形式。在这种情况下，原型对象的引用可以由客户端自己保存。

　　如果要创建的原型对象数目不固定的话，可以采取第二种形式。在这种情况下，客户端不保存对原型对象的引用，这个任务被交给管理员对象。在复制一个原型对象之前，客户端可以查看管理员对象是否已经有一个满足要求的原型对象。如果有，可以直接从管理员类取得这个对象引用；如果没有，客户端就需要自行复制此原型对象。



## 单例模式

​	作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。

### 单例模式的特点

* 单例类只能有一个实例。
* 单例类必须自己创建自己的唯一实例。
* 单例类必须给所有其他对象提供这一实例。

### 饿汉式单例

```java
public class EagerSingleton {
    private static EagerSingleton instance = new EagerSingleton();
    /**
     * 私有默认构造子
     */
    private EagerSingleton(){}
    /**
     * 静态工厂方法
     */
    public static EagerSingleton getInstance(){
        return instance;
    }
}
```

上面的例子中，在这个<font color=red>类被加载时，静态变量instance会被初始化</font>(若不了解类加载过程，可见"JVM/JAVA类加载过程"，此时类的<font color=red>私有构造方法</font>会被调用。这时候，单例类的唯一实例就被创建出来了。

**饿汉式是典型的空间换时间**，当类装载的时候就会创建类的实例，不管你用不用，先创建出来，然后每次调用的时候，就不需要再判断，节省了运行时间。

### 懒汉式单例

```java
public class LazySingleton {
    private static LazySingleton instance = null;
    /**
     * 私有默认构造子
     */
    private LazySingleton(){}
    /**
     * 静态工厂方法
     */
    public static synchronized LazySingleton getInstance(){
        if(instance == null){
            instance = new LazySingleton();
        }
        return instance;
    }
}
```

上面的懒汉式单例类实现里对静态工厂方法使用了同步化，以处理多线程环境。

**懒汉式是典型的时间换空间**,就是每次获取实例都会进行判断，看是否需要创建实例，浪费判断的时间。当然，如果一直没有人使用的话，那就不会创建实例，则节约内存空间。

由于懒汉式的实现是线程安全的，这样会降低整个访问的速度，而且每次都要判断。那么有没有更好的方式实现呢？

#### 双重检查加锁

所谓“双重检查加锁”机制，指的是：并不是每次进入getInstance方法都需要同步，而是先不同步，进入方法后，先检查实例是否存在，如果不存在才进行下面的同步块，这是第一重检查，进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。

“双重检查加锁”机制的实现会使用关键字volatile（不稳定的），它的意思是：**<font color=red>被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。</font>**

```java
public class Singleton {
    private volatile static Singleton instance = null;
    private Singleton(){}
    public static Singleton getInstance(){
        //先检查实例是否存在，如果不存在才进入下面的同步块
        if(instance == null){
            //同步块，线程安全的创建实例
            synchronized (Singleton.class) {
                //再次检查实例是否存在，如果不存在才真正的创建实例
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

这种实现方式既可以实现线程安全地创建实例，而又不会对性能造成太大的影响。它只是第一次创建实例的时候同步，以后就不需要同步了，从而加快了运行速度。

*注意：由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高。因此一般建议，没有特别的需要，不要使用。。*也就是说，虽然可以使用“双重检查加锁”机制来实现线程安全的单例，但并不建议大量采用，可以根据情况来选用。

根据上面的分析，常见的两种单例实现方式都存在小小的缺陷，那么有没有一种方案，<font color=red>既能实现延迟加载，又能实现线程安全呢？</font>

## Lazy initialization holder class模式

### 基础知识

#### 类级内部器

类级内部器：由static修饰的成员式内部类。（如果没有static修饰的成员式内部类被称为对象级内部类。）

类级内部类相当于其外部类的static成分，<font color=red>它的对象与外部类对象间不存在依赖关系，</font>因此可直接创建。而对象级内部类的实例，是绑定在外部对象实例中的。

类级内部类相当于其外部类的成员，只有在第一次被使用的时候才被会装载。

#### 多线程缺省同步锁

大家都知道，在多线程开发中，为了解决并发问题，主要是通过使用synchronized来加互斥锁进行同步控制。但是在某些情况中，JVM已经隐含地为您执行了同步，这些情况下就不用自己再来进行同步控制了。这些情况包括：

* <font color=red>由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时</font>
* 访问final字段时
* 在创建线程之前创建对象时
* 线程可以看见它将要处理的对象时

### 解决方案的思路

​	要想很简单地实现线程安全，可以采用静态初始化器的方式，它可以由JVM来保证线程的安全性。比如前面的饿汉式实现方式。但是这样一来，不是会浪费一定的空间吗？因为这种实现方式，会在类装载的时候就初始化对象，不管你需不需要。

　　如果现在有一种方法能够让类装载的时候不去初始化对象，那不就解决问题了？一种可行的方式就是采用类级内部类，**<font color=red>在这个类级内部类里面去创建对象实例。这样一来，只要不使用到这个类级内部类，那就不会创建对象实例，从而同时实现延迟加载和线程安全。</font>**

​	示例代码：

```java
public class Singleton {
    private Singleton(){}
    /**
     *    类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例
     *    没有绑定关系，而且只有被调用到时才会装载，从而实现了延迟加载。
     */
    private static class SingletonHolder{
        /**
         * 静态初始化器，由JVM来保证线程安全
         */
        private static Singleton instance = new Singleton();
    }
    public static Singleton getInstance(){
        return SingletonHolder.instance;
    }
}
```

**当getInstance方法第一次被调用的时候，它第一次读取SingletonHolder.instance，导致SingletonHolder类得到初始化；而这个类在装载并被初始化的时候，会初始化它的静态域，从而创建Singleton的实例，由于是静态的域，因此只会在虚拟机装载类的时候初始化一次，并由虚拟机来保证它的线程安全性。**

这个模式的优势在于，getInstance方法并没有被同步，并且只是执行一个域的访问，因此延迟初始化并没有增加任何访问成本。

## 单例和枚举

单元素的枚举类型已经成为实现Singleton的最佳方法。用枚举来实现单例非常简单，只需要编写一个包含单个元素的枚举类型即可。

```java
public enum Singleton {
    /**
     * 定义一个枚举的元素，它就代表了Singleton的一个实例。
     */
    uniqueInstance;
   
    /**
     * 单例可以有自己的操作
     */
    public void singletonOperation(){
        //功能处理
    }
}
```

使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。



