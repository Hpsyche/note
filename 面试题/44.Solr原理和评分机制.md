## Solr原理

首先来看为什么顺序扫描的速度慢：其实由于我们想要搜索的信息和非结构化数据中存储的信息不一致造成的。

非结构化数据中存储的信息是每个文件包含哪些字符串，也即已知文件，欲求字符串相对容易，也即从文件到字符串的映射。而我们想搜索的信息是哪些文件包含此字符串，也即已知字符串到文件的映射。两者恰恰相反。于是如果索引总能够保存从字符串到文件的映射，则会大大提高搜索速度。

由于**从字符串到文件的映射**是文件到字符串映射的反向过程，于是保存这种信息的索引称为**反向索引**。

反向索引的保存的信息一般如下：假设文档集合里有100篇文档，为了方便表示，我们为文档编号从1到100，得到下面的结构。

![](D:\Work\TyporaNotes\note\面试题\pict\44-1.png)

左边保存的是一系列字符串，成为字典。

每个字符串只想包含此字符串的文档链表，此文档链表称为倒排表（posting list）。有了索引，便使保存的信息和要搜索的信息一致，可以大大加快搜索的速度。

比如说，我们要寻找既包含字符串“Lucene”又包含字符串“solr”的文档，只需要以下几个步骤：

- 取出包含字符串“Lucene”的文档链表；
- 取出包含字符串“solr”的文档链表；
- 通过合并链表，找出既包含“Lucene”又包含“solr”的文件。

![](D:\Work\TyporaNotes\note\面试题\pict\44-2.png)

### 为什么创建索引慢

看到这个地方，有人可能会说，全文索引的确加快了搜索的速度，但是多了索引的过程，两者加起来不一定比顺序扫描快多少。的确，加上索引的过程，全文检索不一定比顺序扫描快，尤其是在数据量小的时候更是如此。而对一个很大量的数据创建索引也是一个很慢的过程。

然后两者还是有区别的，**顺序扫描是每次都要扫描，而创建索引的过程仅仅需要一次，以后便一劳永逸了**，每次搜索，创建索引的过程不必经过，仅仅搜索已经创建好的索引就可以了。**这也是全文搜索相对于顺序扫描的优势之一：一次索引，多次使用**。

### 评分机制

coord(q,d)      ——      相关性，表示搜索结果d中出现了几个查询q中的关键词t；

搜索结果d中出现的查询q中的关键词t越多评分越高。

 tf(t in d)            ——      关键词频率，关键词t在搜索结果d中出现的次数；

t在d中出现的频率越多评分越高。

idf(t)                  ——      结果量反比，结果量指出现关键词t的搜索结果d的数量；

                     出现关键词t的结果d越少，结果率反比越高。

t.getBoost()     ——      取t的加权值，可以在程序中使用 setBoost()方法来给词加权。

norm(t,d)       ——      封装索引其间的加权，由加权因子(Field boost)和长度因子(lengthNorm)得。

                     Field boost通过调用 field.setBoost()为字段加权。
    
                     lengthNorm关键词t的字段越短，评分越高。
defType配置函数

sum(linear(vip,1000,0),linear(sqrt(log(linear(point,1,2))),100,0),sqrt(log(ms(createTime))))

以上三个值相加得出最统权重分从高到低排序