[TOC]

# 高并发业务

高并发系统的几大方向
1.请求数据尽量少，从而减少cpu消耗
2.访问路径尽量短，减少节点消耗
3.强依赖尽量少，减少加载时间
4.不要有单点，要有备份
5.减少额外请求，减少加载时间

## 互联系统应用架构基础分析

正常的请求通过防火墙之后，最先到达的是负载均衡器，其有以下几个功能：

- 对业务请求做初步分析，分析其是否允许到达Web服务器，<font color=red>即可以通过配置禁止一些无效的请求</font>，比如封禁经常作弊的ip地址等；
- 提高路由算法，<font color=red>提供一些负载均衡的算法，根据各个服务器的负载能力进行合理分发，</font>每一个Web服务器得到比较均衡的请求，从而降低单个服务器的压力，提高系统的响应能力；
- 限流，对于一些高并发时刻，如双十一、新产品上线，需要通过限流来处理，因为可能某个时刻通过上述的算法让有效的请求过多的到达服务器，使得一些Web服务器或者数据库服务器产生宕机。当某台服务器宕机后，其他服务器将承受更大的压力，将会导致更多的服务器产生宕机，持久下去就会引发服务器雪崩。因此，在这种情况下，<font color=red>负载均衡有限流的算法，对于请求过多的时刻，可以告知用户系统繁忙，稍后再试，从而保证系统持续可用。</font>

## 高并发系统的分析和设计

### 有效请求和无效请求

- 一个账号连续请求，甚至在一秒内发送成百上千个请求，使得后台压力变大，无疑这种认为是无效请求，应对它的方法很多，常见的做法：
  - 加入验证码，首次无验证码以便用户减少录入，第二次请求开始加入验证码；
  - 使用短信服务器，对于企业应用，这类问题的逻辑判断，不应该放在，应该放在负载均衡器上完成，即在进入web服务器之前完成，做完这一步就能避免大量的无效请求，对保证高并发服务器可用性很有效果。
- 对于一个人多个账号的场景，可以通过提高账户的等级来压制多个请求，比如对于支付交易的网址，可以通过银行卡验证，实名制获取相关证件号码，从而使用证件号码使得多个账号归结为一人，这样就有效地规避了一个人多账号的频繁请求。
- 对于有组织的请求，考虑使用“僵尸账号排除法”

## 系统设计

高并发业务需要分布式的系统分摊请求的压力，此时就需要使用负载均衡服务。

### 按业务划分

如分为产品维护、交易维护、资金维护等模块，按照功能模块划分，降低数据的复杂度，或者称为**水平分法**。

按照业务划分的好处是：首先，一个服务管理一个业务，提供了开发效率；其实，数据库的设计也方便很多。

此时，由于各个系统业务也存在着关联，还要通过RPC（远程过程调用协议）处理这些关联信息，比较流行的RPC是dubbo、thrift和hessian。其原理是：**每一个服务都会暴露一些公共的接口给RPC服务，这样对于任何一个服务器都能够通过RPC服务获取其他服务器对应的接口，去调度各个服务器的逻辑来完成功能，但是接口的相互调用也会造成一定的缓慢。**

### 垂直分法

不按子系统划分，而是将它们按照互不相干的几个同样的系统分摊下去。

### 水平和垂直结合

首先将系统按照业务区分为多个子系统，然后在每一个子系统下再分多个服务器，通过每一个子系统的路由器找到对应的子系统服务器提供服务。

尽管多种分布，但原则不变：

- 服务器的负载均衡，使得每一个服务器都能比较平均地得到请求数量，从而提供系统的吞吐和性能；
- 业务简化，按照模块划分可以使得系统划分为各个子系统，这样开发者的业务单一化，也容易理解和开发了。

## 数据库设计

### 分表

- 在一个数据库内本来一张表可以保存的数据，设计多张表去保存。

  如，2016年数据用表t_transaction_2016存储，可以开发中只需要根据查询的年份确定查询某张表即可

#### 水平分割

例：QQ的登录表。假设QQ的用户有100亿，如果只有一张表，每个用户登录的时候数据库都要从这100亿中查找，会很慢很慢。如果将这一张表分成100份，每张表有1亿条，就小了很多，比如qq0,qq1,qq1...qq99表。

用户登录的时候，可以将用户的id%100，那么会得到0-99的数，查询表的时候，将表名qq跟取模的数连接起来，就构建了表名。比如123456789用户，取模的89，那么就到qq89表查询，查询的时间将会大大缩短。

这就是水平分割。

#### 垂直分割

垂直分割指的是：表的记录并不多，但是字段却很长，表占用空间很大，检索表的时候需要执行大量的IO，严重降低了性能。这时需要把大的字段拆分到另一个表，并且该表与原表是一对一的关系。

例如学生答题表tt：有如下字段：

Id name 分数 题目 回答

其中题目和回答是比较大的字段，id name 分数比较小。

如果我们只想查询id为8的学生的分数：select 分数 from tt where id = 8;虽然知识查询分数，但是题目和回答这两个大字段也是要被扫描的，很消耗性能。但是我们只关心分数，并不想查询题目和回答。这就可以使用垂直分割。我们可以把题目单独放到一张表中，通过id与tt表建立一对一的关系，同样将回答单独放到一张表中。这样我们插叙tt中的分数的时候就不会扫描题目和回答了。

### 分库

- 把表分配在不同的数据库上，此时需要一个路由算法来确定数据存贮在那个数据库上。

### 分区

* 数据库分区，把一张表的数据分成N多个区块，这些区块可以在同一个磁盘（服务器）上，也可以在不同的（服务器）磁盘上，负载均衡，但是在用户上来看，只有一个服务器。

### 分区和分表の区别

分区和分表的区别与联系

  1）分区和分表的目的都是减少数据库的负担，提高表的增删改查效率

  2）分区只是一张表中的数据的存储位置发生变化，还是在一张表中，分表是将一张表分成多张表

  3）当访问量大，且表数据比较火时，两种方式可以相互配合使用

  4）当访问量不大，但表数据比较多时，可以只进行分区

### 分库和分表存在的问题

  1）**事务问题**

​	在执行分库分表之后，由于数据存储到了不同的库上，数据库事务管理出现了困难。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出昂贵的性能代价，如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。

 2）**跨库跨表的join问题**

​	在执行了分库分表之后，难以避免会将原本逻辑关联性很强的数据划分到不同的表，不同的库上，这是，标的关联操作将会受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表，结果一次查询能够完成的业务，可能需要多次查询才能完成

  3）**额外的数据管理负担和数据运算压力**

​	额外的数据管理负担，就是数据的定位问题和数据的增删改查的重复执行问题，这些都可以通过应用程序解决，但必然会引起额外的逻辑运算，例如，对于一个记录用户乘积的用户数据表userTable，业务要求查出成绩最好的100位，在进行分表之前，只需要一个order by语句就可以搞定，但是在进行分表之后，将需要n个order by语句，分别查出每一个分表的前100名用户数据，然后再对这些数据进行合并计算，才能得出结果

### 优化sql

- 比如，更新用户的生日，可以使用以下两条sql的任意一条：

  ```sql
  update t_user set birthday=#{birthday} where id=#{id}
  update t_user set birthday=#{birthday} where user_name=#{username}
  ```

  若username也是唯一索引，以上逻辑都是正常的，但是<font color=red>优先使用主键更新</font>，原因是在Mysql的运行过程中，**第二句sql会锁表，即不仅锁定更新的数据，而且锁定其他表的数据，从而影响并发，而使用主键的更新则是行锁定；**

  - 使用连接查询代替子查询，not in (exists)等性能低下，应该全部修改为连接语句去执行，从而提供sql的性能；
  - 读写分离技术，进一步的优化，一台主机主要负责写数据，一台或者多台备机负责读数据。

## 动静分离技术

- 对于有条件的企业可以考虑CDN（Content Delivery Network，即内容分发网络）

  它允许企业将自己的静态数据缓存到网络CDN的节点中，比如企业将数据缓存在北京的节点上，当在天津的客户发送请求时，通过一定的算法，会找到北京的CDN节点，从而把CDN缓存的数据发送给天津的客户；而深圳的客户，会找到广州的CDN节点，即就近取出缓存的数据，所以速度会很快。

- 一些企业也许需要自己的静态http服务器，将静态数据分离到静态http服务器上。

  就是将资源分配到静态服务器上，这样图片、html、脚本等资源就可以从静态服务器上获取，尽量使用cookie等技术，让客户端缓存能够缓存数据，避免多次请求，降低服务器压力。

##  锁和高并发

- 由于在一个瞬间产生很高的并发，因此除了保证数据一致性。我们还要尽可能地保证系统的性能，加锁会影响并发，而不加锁就难以保证数据的一致性，这就是高并发和锁的矛盾。

### 悲观锁（独占锁）

悲观锁是一种利用数据库内部机制提供的锁的方法，也就是对更新的数据加锁，这样在并发期间一旦有一个事务持有了数据库记录的锁，其他的线程将不能再对进行进行更新了。

```sql
select * from user where uid=#{uid} for update
```

注意：这里的sql加入的for update语句，意味着将持有对数据库记录的行更新时（**因为这里使用主键查询，所以只会对行加锁；若使用非主键查询，考虑是否对全表加锁，加锁可能会引起其他查询的阻塞**）；

对于悲观锁来说，当一条线程抢占了资源后，其他的线程将得不到资源，那么这个时候，CPU将会把这些得不到资源的线程挂起，挂起的线程也会消耗CPU的资源，尤其是在高并发的请求中。频繁挂起，等待持久锁线程释放资源，造成并发能力的下降，从而导致CPU频繁切换线程上下文，造成性能低下。

为了克服这个问题，提高并发的能力，避免大量线程因为阻塞导致CPU进行大量的上下文切换，提出以下的乐观锁。

### 乐观锁（非阻塞锁）

乐观锁使用的是CAS原理，详见“16.CAS.md“

#### 概述

CAS原理并不排斥并发，也不独占资源，只是在线程开始阶段读入线程共享数据，保存为旧值。

当处理完逻辑，需要更新数据时，会进行一次比较，即比较各个线程当前共享的数据是否和旧值一致，若一致，开始更新数据；若不一致，则认为数据已被修改，不更新数据，考虑重试或放弃，有时候可以重试，这样就是一个可重入锁。

#### 乐观锁实现抢红包业务

```sql
<!--
通过版本号扣减抢红包，每更新一次，版本+1，其次增加对版本号的判断
-->
<update id="decreaseRedPacketForVersion">
	update t_red_packet set ....,version=version+1 
	where id=#{id}
	and version=#{version}
</update>
```

在java中有：

```java
//判断是否被修改过
int update=redPacketDao.decreaseRedPacketForVersion(...,redPacket.getVersion());
//如果没有更新过，则说明其他线程修改过，本次抢红包失败
if(update==0){
    return FAILED;
}
```

#### 问题：

此方法会造成很多失败请求，故考虑使用可重入机制。一旦因为版本问题没有抢到红包，则重新尝试抢红包，但是过多的冲入会造成大量sql执行，加入两种限制：

* 按时间戳的重入，也就是在一定时间戳内（如ms），不成功会循环到成功为止，直到超过时间戳为止；
* 一种是限定次数，程序尝试超过3此抢红包后，就判定请求失效

#### 乐观锁重入机制

按时间戳的重入，在java中有：

```java
long start=System.currentTimeMills();
while(true){
    long end=System.currentTimeMills();
    if(end-start>100){
        return FAILED;
    }
    //获取红包信息，注意version值
    ...
}
```

按次数的重入，在java中有：

```java
for(int i=0;i<3;i++){
    ...........
}
```

### 使用redis实现抢红包

对于实现redis实现抢红包，首先我们要知道redis功能步入数据库强大，事务不完整，因此要保证数据的正确性。而redis的Lua语言是原子性的，且功能更为强大，所以优先选择使用Lua语言来实现抢红包，但是无论如何对于数据而言，在redis当中存储，始终不是长久之计，因为redis并非一个长久储存数据的地方，它存储的数据是非严格和安全的环境，更多时候只是为了提供更为快速的缓存，所以当红包金额为0或者红包超时的时候，会将红包数据保存到数据库中，这样才能保证数据的安全性和严格性。

## 总结

使用乐观锁有助于提高系统并发性能，但是由于版本号冲突，乐观锁导致多次请求服务失败的概率大大提高，而我们通过重入（时间戳或次数）来提高成功的概率，这样对于乐观锁而言实现的方式就相对复杂了，其性能也会随之版本号的冲突的概率提升而提升，并不稳定。

使用乐观锁的弊端在于，导致大量的SQL被执行，对于数据库的性能要求比较高，容易引起数据库性能的瓶颈，而且对于开发还要考虑重入机制，从而导致开发难度加大。

使用redis去实现高并发，通过redis提供的Lua脚本的原子性，消除了数据不一致性，并且在整个过程中只有最后一次设计数据库，而且是使用了新的线程，在实际的操作中，更倾向于使用JMS（Java Message Servcie）启动另外的服务器进行操作，但是这样使用的风险在于redis的不稳定性，因为其事务和存储都存在不稳定的因素，所以更多的时候，建议<font color=red>使用独立redis服务器做高并发业务，一方面可以提高redis性能，另一方面即使在高并发的场合，redis服务器宕机也不影响现有的其他业务，同时也可以使用备机等设备提高系统的高可用，保证网站的安全稳定。</font>















