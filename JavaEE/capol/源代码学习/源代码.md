## @Transient作用

一般来说用@Transient是希望该属性不会在数据表中产生字段，但又可以在程序中使用它。

```java
package com.capol.entity;

import java.sql.Timestamp;

import javax.persistence.Column;
import javax.persistence.Id;
import javax.persistence.Table;
import javax.persistence.Transient;

import lombok.Data;

/**
 * 流程分类实体
 * @author hongshiping
 *
 */
@Data
@Table(name="t_bus_process_classify")//设置数据库中表名字
public class ProcessClassify {

	// 分类Id
	@Id
	@Column(name = "f_id")
	private String fId;

	//当前所在层级
	@Transient
	private int currLevel;
	
	//是否有子级
	@Transient
	private boolean hasSon;
}	

```

## sqlServer在建表时表名前加dno

DBO是每个数据库的默认用户，具有所有者权限，即DbOwner通过用DBO作为所有者来定义对象，能够使数据库中的任何用户引用而不必提供所有者名称。比如：你以User1登录进去并建表Table，而未指定DBO，当用户User2登进去想访问Table时就得知道这个Table是你User1建立的，要写上User1.Table，如果他不知道是你建的，则访问会有问题。如果你建表时把所有者指给了Dbo，则别的用户进来时写上Dbo.Table就行了，不必知道User1。

不光表是如此，视图等等数据库对象建立时也要如此才算是好。

## Cachebale使用

```java
@Cacheable(value = "PERSON",key = "#tagId+'_'+#zz")
public List<Person> getPersonByTagid(Long tagId,String zz)
```

1. 其中value表示该方法返回的参数的缓存存在那个Cache里(即为缓存块的名字)
2. 缓存结果以一个键值对存放在缓存中,注解中key即为键值对的key;value即为方法返回的结果
3. key用双引号,里面#加上方法的参数:获取方法的参数,  ''表示在参数之间添加分隔符

- 常规使用方法
  - 在springboot的启动类上使用@EnableCaching
  - 开启缓存在方法上直接使用@Cacheable()使用缓存

## Activity中的表

#### Activity框架提供的Service对象

- RepositoryService 操作静态的资源（bpmn、png等）
- RuntimeService操作流程实例（启动流程实例、查询、删除）
- TaskService操作任务（查询、办理任务）
- HistoryService操作历史数据

### Activity框架提供的对象

- Deployment--act_re_deployment
- ProcessDefinition--act_re_procdef
- ProcessInstance--act_ru_excution
- Task--act_ru_task

```java
/**
	 * 根据申请单ID查询相应的审批记录，不分页，根据审批记录的createTime倒序排序
	 * @param userId
	 * @param billId
	 * @return
	 * @throws Exception
	 */
public List<ApproveRecord> getApproveRecordByBillId(String billId,boolean asc) throws Exception;

//boolean类型作用：点击 该列名 时 能够实现 排序反转！！
```

## lombok @EqualsAndHashCode 注解的影响

原文中提到的大致有以下几点： 

1. 此注解会生成equals(Object other) 和 hashCode()方法。 
2. 它默认使用非静态，非瞬态的属性 
3. 可通过参数exclude排除一些属性 
4. 可通过参数of指定仅使用哪些属性 
5. 它默认仅使用该类中定义的属性且不调用父类的方法 
6. 可通过callSuper=true解决上一点问题。让其生成的方法中调用父类的方法。

另：@Data相当于@Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode这5个注解的合集。

通过官方文档，可以得知，当使用@Data注解时，则有了@EqualsAndHashCode注解，那么就会在此类中存在equals(Object other) 和 hashCode()方法，且不会使用父类的属性，这就导致了可能的问题。 
比如，有多个类有相同的部分属性，把它们定义到父类中，恰好id（数据库主键）也在父类中，那么就会存在部分对象在比较时，它们并不相等，却因为lombok自动生成的equals(Object other) 和 hashCode()方法判定为相等，从而导致出错。

修复此问题的方法很简单： 

1. 使用@Getter @Setter @ToString代替@Data并且自定义equals(Object other) 和 hashCode()方法，比如有些类只需要判断主键id是否相等即足矣。 
2. 或者在使用@Data时同时加上@EqualsAndHashCode(callSuper=true)注解。

源代码如下：

```java
import lombok.Data;
import lombok.EqualsAndHashCode;

/**
 * 基本实体类，所有实体都必须继承自本类
 */
@Data
@EqualsAndHashCode(callSuper=false)
public class BaseData extends BaseEntity{

	/**
	 * 主键
	 */
	@Column(name = "f_id")
	@Id
	private String fId;
	
	/**
	 * 其他字段
	 */
}
```

主要是因为主键fId在此类中，即决定是否相等的关键字段在此类中，则
`@EqualsAndHashCode(callSuper=false)`并不影响。

### 注意

当使用@Data注解的实体有父类（非Object）时，eclipse会有警告提示 

警告的大概意思是自动生成的equals和hashCode方法没有调用父类，如果是故意不掉用父类的话，可以加上@EqualsAndHashCode(callSuper=false)注解。 

因为这个是实体，继承父类主要也是需要使用父类的元素，所以生成的equals和hashCode方法应该包含父类在内，因此可以把callSuper设为true。 
通过反编译来查看callSuper为true和false的区别。 

当callSuper为true时，在equals方法中会多出一个判断，如下

```java
if (!super.equals(o)) {
    return false;
}
```

## 技巧

### 封装通用BaseService

使用mybatis-plus实现BaseMapper，同时，自己也封装了一个通用BaseService，封装Service接口的通用CURD和分页查询方法的实现 建议所有的Service实现类都继承该抽象类 在继承时注入具体mapper对象，再写入自己额外的方法

```java
package com.capol.base.impl;

import java.util.List;

import com.capol.base.BaseMapper;
import com.capol.base.BaseService;
import com.github.pagehelper.PageHelper;
import com.github.pagehelper.PageInfo;

import lombok.extern.slf4j.Slf4j;

/**
 * 封装Service接口的通用CURD和分页查询方法的实现 建议所有的Service实现类都继承该抽象类 在继承时注入具体mapper对象
 * 
 * @author likai
 * @date 2018年7月28日
 */
@Slf4j
public abstract class BaseServiceImpl<T> implements BaseService<T> {

	protected abstract BaseMapper<T> getMapper();

	@Override
	public int insert(T record) {
		return getMapper().insert(record);
	}

	@Override
	public int insertSelective(T record) {
		return getMapper().insertSelective(record);
	}

	@Override
	public int delete(T record) {
		return getMapper().delete(record);
	}

	@Override
	public int updateByPrimaryKey(T record) {
		return getMapper().updateByPrimaryKey(record);
	}

	@Override
	public int updateByPrimaryKeySelective(T record) {
		return getMapper().updateByPrimaryKeySelective(record);
	}

	@Override
	public List<T> select(T record) {
		return getMapper().select(record);
	}

	@Override
	public List<T> selectAll() {
		return getMapper().selectAll();
	}

	@Override
	public T selectOne(T record) {
		return getMapper().selectOne(record);
	}

	/**
	 * 根据实体中的属性查询总数，查询条件使用等号
	 */
	@Override
	public int selectCount(T record) {
		return getMapper().selectCount(record);
	}

	@Override
	public boolean existsWithPrimaryKey(Object key) {
		return getMapper().existsWithPrimaryKey(key);
	}

	@Override
	public T selectByPrimaryKey(Object key) {
		return getMapper().selectByPrimaryKey(key);
	}

	@Override
	public int deleteByPrimaryKey(Object key) {
		return getMapper().deleteByPrimaryKey(key);
	}

	/**
	 * 分页查询
	 */
	@Override
	public PageInfo<T> selectListByPage(T record, int pageNum, int pageSize) {
		return selectListByPage(record, pageNum, pageSize, "");
	}
	
	@Override
	public PageInfo<T> selectListByPage(T record, int pageNum, int pageSize, String orderBy) {
		PageInfo<T> pageInfo = null;

		try {
			PageHelper.startPage(pageNum, pageSize, orderBy);
			
			List<T> tList = getMapper().select(record);
			pageInfo = new PageInfo<T>(tList);
		} catch (Exception e) {
			log.error("class:BaseServiceImpl ->method:show->message:" + e.getMessage());
			e.printStackTrace();
		}

		return pageInfo;
	}
	
	public List<T> selectByIds(String id) {
		return getMapper().selectByIds(id);
	}

	public int deleteByIds(String id) {
		return getMapper().deleteByIds(id);
	}
	
	@Override
	public List<T> selectByExample(Object example) {
		return getMapper().selectByExample(example);
	}


	@Override
	public T selectOneByExample(Object example) {
		return getMapper().selectOneByExample(example);
	}


	@Override
	public int selectCountByExample(Object example) {
		return getMapper().selectCountByExample(example);
	}


	@Override
	public int deleteByExample(Object example) {
		return getMapper().deleteByExample(example);
	}


	@Override
	public int updateByExample(T record, Object example) {
		return getMapper().updateByExample(record, example);
	}


	@Override
	public int updateByExampleSelective(T record, Object example) {
		return getMapper().updateByExampleSelective(record, example);
	}
	
	@Override
	public PageInfo<T> selectByExampleByPage(Object example, int pageNum, int pageSize) {
		return selectByExampleByPage(example, pageNum, pageSize, "");
	}
	
	@Override
	public PageInfo<T> selectByExampleByPage(Object example, int pageNum, int pageSize, String orderBy) {
		PageInfo<T> pageInfo = null;

		try {
			PageHelper.startPage(pageNum, pageSize, orderBy);
			List<T> tList = getMapper().selectByExample(example);
			pageInfo = new PageInfo<T>(tList);
		} catch (Exception e) {
			log.error("class:BaseServiceImpl ->method:show->message:" + e.getMessage());
			e.printStackTrace();
		}

		return pageInfo;
	}
	

}

```

### 使用Slf4j而不是log4j

在很多类头部，经常看到注解`@Slf4j`，作用如下：

使用`@Slf4j`可以替代如下：

```0
private static final Logger log = LoggerFactory.getLogger(SummerGiftController.class);
```

使用时候可以直接log.info()、log.error()

Slf4j对比log4j，优势如下：

https://www.jianshu.com/p/32e2a7254c03

### 封装抽象类BaseProcessController

#### BaseProcesController继承BaseController

在BaseController中：

- @InitBinder

在BaseController中，有@InitBinder，其代码如下：

```java
@InitBinder
protected void initBinder(WebDataBinder binder) {
    //参数一：页面发送过来的String类型的数据最终要转换的类型
    //参数二：具体的转换方式
    binder.registerCustomEditor(Date.class,
                                new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"), true));
    binder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd"), true));
}
```

主要是进行日期格式转换，日期格式转换的方法有如下：https://www.jianshu.com/p/c7ca5b6fda22

即将前台 传过来的字符串日期 转换为Date格式

- @ExceptionHandler

统一处理异常信息

```java
@ExceptionHandler({ UnauthorizedException.class, AuthorizationException.class })
public String authorizationException(HttpServletRequest request, HttpServletResponse response) {
    if (isAjaxRequest(request)) {
        Map<String, Object> map = Maps.newHashMap();
        map.put("code", "403");
        map.put("message", "无权限");
        return JSON.toJSONString(map);
    } else {
        String message = "权限不足";
        try {
            message = URLEncoder.encode(message, "utf-8");
        } catch (UnsupportedEncodingException e) {
            log.error("BaseController：" + e.getMessage());
            e.printStackTrace();
        }
        return "redirect:/error/403?message=" + message;
    }
}

private static boolean isAjaxRequest(HttpServletRequest request) {
    String requestedWith = request.getHeader("x-requested-with");
    return requestedWith != null && requestedWith.equalsIgnoreCase("XMLHttpRequest");
}
```

对于指定的两个Exception，会有统一异常处理，同时对Ajax请求和POST请求做了不同的处理。

### 配置文件自动注入事务

```java
public class TransactionalConfig {

  private static final String  PROPAGATION_REQUIRED="PROPAGATION_REQUIRED,-Throwable";
  private static final String  PROPAGATION_REQUIRED_READ="PROPAGATION_REQUIRED,-Throwable,readOnly";
  private static final String[]  REQUIRED_RULE_TRANSACTION={"insert*","add*","update*","del*","create*"};
  private static final String[]  READ_RULE_TRANSACTION={"select*","get*","count*","find*"};

  /**
   *aop
   * @param platformTransactionManager 自动注入 无需手动
   * @return
   */
  @Bean(name="transactionInterceptor")
  public TransactionInterceptor transactionInterceptor(PlatformTransactionManager platformTransactionManager) {
    TransactionInterceptor interceptor = new TransactionInterceptor();
    Properties properties = new Properties();
    for(String s:REQUIRED_RULE_TRANSACTION){
      properties.setProperty(s, PROPAGATION_REQUIRED);
    }
    for(String s:READ_RULE_TRANSACTION){
      properties.setProperty(s, PROPAGATION_REQUIRED_READ);
    }
    interceptor.setTransactionManager(platformTransactionManager);
    interceptor.setTransactionAttributes(properties);
    return interceptor;
  }
  @Bean
    public BeanNameAutoProxyCreator getBeanNameAutoProxyCreator(){
      BeanNameAutoProxyCreator proxyCreator=new BeanNameAutoProxyCreator();
      proxyCreator.setProxyTargetClass(true);
      //设置拦截的Bean名称
      proxyCreator.setBeanNames("*ServiceImpl","*Controller");
      //即设置上面配置的 事务拦截器
      proxyCreator.setInterceptorNames("transactionInterceptor");
      return proxyCreator;
  }

}
```

与以下xml配置方式原理是一致的，只是改在了java文件中配置

```xml
<bean id="transactionInterceptor"
   class="org.springframework.transaction.interceptor.TransactionInterceptor"> 
   <property name="transactionManager">
    <ref bean="transactionManager" />
   </property>
   <!-- 配置事务属性 -->
   <property name="transactionAttributes">
    <props>
     <prop key="delete*">PROPAGATION_REQUIRED</prop>
     <prop key="add*">PROPAGATION_REQUIRED</prop>
     <prop key="update*">PROPAGATION_REQUIRED</prop>
     <prop key="save*">PROPAGATION_REQUIRED</prop>
     <prop key="find*">PROPAGATION_REQUIRED,readOnly</prop>
    </props>
   </property>
</bean> 
<bean
   class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator">
   <property name="beanNames">
    <list>
     <value>*Service</value>
    </list>
   </property>
   <property name="interceptorNames">
    <list>
     <value>transactionInterceptor</value>
    </list>
   </property>
</bean>
```

### 初始化bean对象时打印日志

```java
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.context.annotation.Configuration;

import lombok.extern.slf4j.Slf4j;

/**
 * ApplicationContext会自动检查是否在定义文件中有实现了BeanPostProcessor接口的类，
 * 如果有的话，Spring容器会在每个Bean(其他的Bean)被初始化之前和初始化之后，
 * 分别调用实现了BeanPostProcessor接口的类的postProcessAfterInitialization()方法
 * 和postProcessBeforeInitialization()方法
 * 之所以用z开头是因为 初始化有顺序
 */
@Configuration
@Slf4j
public class ZBeanFactory implements BeanPostProcessor {

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName)
            throws BeansException {
        log.info("对象---" + beanName + "---初始化开始");
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        log.info("对象---" + beanName + "---初始化成功");
        return bean;
    }
}
```

## 使用雪花算法做主键

主键id,Snowflake雪花算法，优点：生成有顺序的id，提高数据库的性能,现在大部分都不用uuid作为主键，因为不规则，每向数据库插入一条数据就要重新排列，使数据库性能降低。

首先这个算法核心是依靠时间戳然后结合自增序列以及机器号等等构成，我们说的连续应该是指在一个毫秒内他是相对连续的，

随着时间的增长，生成的id总体趋势是增长的，但是增长规律并不像mysql自增主键那样是严格自增的。

其次，这个算法是可以进行扩展的，我们可以对算法进行一些改进，使其生成的id在单位时间内并不是“连续的”（如将自增序列打乱等等手段），这样可以增加其安全性，防止被外部“猜到”我们业务数据的规模。

如果我们作为mysql主键来用（innodb），相对连续的主键索引性能也更好嘛。

所以，主要还是结合我们自身的业务场景来使用，如果是内部系统做主键，那连续生成也无所谓的，如果是作为业务单号，暴露到外部，可以对算法做适当的改进，增加安全性。希望能帮到你，纯手打。^^

