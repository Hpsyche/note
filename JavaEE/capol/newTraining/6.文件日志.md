使用slf4j+logback实现日志管理

引入maven

```xml
<properties>
    <slf4j-api.version>1.7.25</slf4j-api.version>
    <lombok.version>1.16.20</lombok.version>
    <logback-classic.version>1.2.3</logback-classic.version>
</properties>
<!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>${lombok.version}</version>
    <scope>provided</scope>
</dependency>
<!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api -->
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>${slf4j-api.version}</version>
</dependency>
<!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic -->
<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>
    <version>${logback-classic.version}</version>
</dependency>
```

logback配置文件

```xml
<?xml version="1.0" encoding="utf-8" ?>
<!--debug="true" : 打印logback内部状态（默认当logback运行出错时才会打印内部状态 ），配置该属性后打印条件如下（同时满足）：
    1、找到配置文件 2、配置文件是一个格式正确的xml文件 也可编程实现打印内部状态，例如： LoggerContext lc = (LoggerContext)
    LoggerFactory.getILoggerFactory(); StatusPrinter.print(lc); -->
<!-- scan="true" ： 自动扫描该配置文件，若有修改则重新加载该配置文件 -->
<!-- scanPeriod="30 seconds" : 配置自动扫描时间间隔（单位可以是：milliseconds, seconds, minutes
    or hours，默认为：milliseconds）， 默认为1分钟，scan="true"时该配置才会生效 -->
<configuration debug="false" scan="true" scanPeriod="30 seconds" packagingData="true">
    <!-- 设置 logger context 名称，默认为default -->
    <contextName>training-newemployee-server</contextName>
    <!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径-->
    <property name="LOG_HOME" value="d:/log" />
    <appender name="consoleLog" class="ch.qos.logback.core.ConsoleAppender">
        <layout class="ch.qos.logback.classic.PatternLayout">
            <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符-->
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n
            </pattern>
        </layout>
    </appender>

    <appender name="fileInfoLog" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <!--要拦截的日志级别-->
            <level>ERROR</level>
            <!--如果匹配，则禁止-->
            <onMatch>DENY</onMatch>
            <!--如果不匹配，则允许记录-->
            <onMismatch>ACCEPT</onMismatch>
        </filter>
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
        <!--滚动策略-->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 归档文件名“.zip或.gz结尾”,表示归档文件自动压缩 -->
            <FileNamePattern>${LOG_HOME}/capol-admin-info-%d{yyyyMMdd}.log.zip</FileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <!--日志文件最大的大小-->
        <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
            <MaxFileSize>10MB</MaxFileSize>
        </triggeringPolicy>
    </appender>

    <appender name="fileErrorLog" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!--添加 范围 过滤-->
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>ERROR</level>
        </filter>
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <FileNamePattern>${LOG_HOME}/capol-admin-error-%d{yyyyMMdd}.log.zip</FileNamePattern>
        </rollingPolicy>
        <!--日志文件最大的大小-->
        <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
            <MaxFileSize>10MB</MaxFileSize>
        </triggeringPolicy>
    </appender>

    <root level="info">
        <appender-ref ref="consoleLog" />
        <appender-ref ref="fileInfoLog"/>
        <appender-ref ref="fileErrorLog"/>
    </root>
</configuration>
```

至此，我们就可以在代码中加入日志了

在类名使用`@Slf4j`

```java
/**
 * @author fuzihao
 * @date 2019/8/8 17:16
 */
@Slf4j
@RestController
@RequestMapping("/notice")
public class NoticeController {
    @AuthorityAnno(AuthorityEnum.SUPER_ADMIN)
    @PutMapping("/updateEntryNow")
    public BaseResponse updateEntryNow(){
        log.info("刷新缓存");
        redisService.delete(TrainingConstant.REDIS_HKEY_TRAIN_ENTRYNOTICE);
        redisService.delete(TrainingConstant.REDIS_HKEY_TRAIN_ENTRYNOTICE_TOTAL);
        return new BaseResponse(ResponseCode.RESPONSE_CODE_200, MessageConstant.EDIT_SUCCESS);
    }
}
```

## 扩展

SLF4J和Logback和Log4j和Logging的区别与联系

《码农翻身》刘欣---->个人总结

### Log4J

Log4j ：Log for Java

 由于Log4j有着良好的设计，优异的性能，拥有三大维度的特性：

* Appender ： 暗含了可以不断追加日志的意思。同时日志可以输出到不同的地方，控制台、文件、邮件等等（设计模式——模板方法）

  ![](D:\Work\TyporaNotes\note\JavaEE\capol\newTraining\pict\6-1.jpg)

* Formatter：日志内容可以格式化，例如变成纯文本，XML, HTML格式等等
* Logger：对于不同的Java class，不同的 package ， 还有不同级别的日志，应该可以灵活地输出到不同的文件中。

如果把Logger, Appender, Formatter看成坐标系中的X轴，Y轴，Z轴， 你看看，这三者可以独立变化而不互相影响，即可以任意扩展Appender接口而影响不到Logger和Formatter， 无论有多少个Logger 都影响不了Appender和Formatter 。

### Logging

到了第四代国王(JDK1.4)，臣民们终于看到了帝国提供的java.util.logging包，也是用来记录日志的，并且其中的核心概念Logger, Formatter, Handler 和 Log4j非常相似，只是为时已晚， Log4j早已深入人心了， 不可撼动了。

### Logback

 Log4j 在Apache开源以后，该作者又创建了新的日志服务，叫做logback, 有了之前的经验，这logback 比log4j 还要快。

### SLF4J

如今的日志世界有了很多的选择 ，除了java.util.logging, log4j 之外，还有logback，tinylog 等其他工具。

这么多日志工具，用户如果想切换了怎么办?不想用log4j了，能换到logback吗?

该作者又提供了一个抽象层， 用户用这个抽象层的API来写日志， 底层具体用什么日志工具不用关心，这样就可以移植了。

此抽象层叫做Simple Logging Facade for Java，简称SLF4J。

![](D:\Work\TyporaNotes\note\JavaEE\capol\newTraining\pict\6-2.jpg)

 对于Log4j , JDK logging, tinylog 等工具， 需要一个适配层， 把SLF4J 的API转化成具体工具的调用接口。

由于Logback这个工具也是同个人之手， 直接实现了SLF4J的API，所以连适配层都不需要了， 用起来速度飞快，效率最高，SLFJ4+Logback 成为了很多人的最爱， 大有超越Apache Common Logging + Log4j 之势。