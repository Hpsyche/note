在项目的系统中，需要写一个日志管理，即将每次用户的增删改操作都存储于数据库中，此时，通过拦截器来设置，通过判断用户的请求，由于项目符合restful风格，当请求method为put、delete或post时，获取用户信息及请求信息，插入数据库中

首先是定义一个拦截器

```java
package com.capol.training.newemployee.server.interceptor;

import com.capol.base.utils.EntityUtil;
import com.capol.training.newemployee.common.entity.dto.ElementDTO;
import com.capol.training.newemployee.common.entity.dto.LogDTO;
import com.capol.training.newemployee.server.enums.HttpMethodEnum;
import com.capol.training.newemployee.server.helpers.config.SpringContextUtils;
import com.capol.training.newemployee.server.service.IElementService;
import com.capol.training.newemployee.server.service.ILogService;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.List;
import java.util.regex.Pattern;

/**
 * @author fuzihao
 * @date 2019/8/14 16:03
 */
public class OperationLogInterceptor extends HandlerInterceptorAdapter {
    @Autowired
    private ILogService logService;
    @Autowired
    private IElementService elementService;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        if(handler instanceof HandlerMethod){
            String methodType = request.getMethod();
            System.out.println(request.getRequestURI());
            //如果是post、delete或put
            if(StringUtils.equalsIgnoreCase(HttpMethodEnum.POST.name(),methodType)||
                    StringUtils.equalsIgnoreCase(HttpMethodEnum.DELETE.name(),methodType)||
                    StringUtils.equalsIgnoreCase(HttpMethodEnum.PUT.name(),methodType)){
                //插入记录到日志表中
                insertToLog(methodType,request.getRequestURI());
            }
        }
        return true;
    }

    private void insertToLog(String methodType, String requestURI) {
        methodType=methodType.toLowerCase();
        List<ElementDTO> elementDTOList = elementService.selectElementAndMenuByMethod(methodType);
        for(ElementDTO elementDTO:elementDTOList){
            if(Pattern.matches(elementDTO.getUri(),requestURI)){
                LogDTO logDTO=new LogDTO();
                logDTO.setMenu(elementDTO.getTitle());
                logDTO.setOperation(elementDTO.getName());
                logDTO.setUri(requestURI);
                EntityUtil.setCreateInfo(logDTO);
                //插入日志表
                logService.insert(logDTO);
            }
        }
    }
}
```

在WebMvcConfigurer全局配置文件中配置拦截器

```java
package com.capol.training.newemployee.server.helpers.config;

import com.capol.base.exception.handle.GlobalExceptionHandler;
import com.capol.training.newemployee.server.interceptor.OperationLogInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * @author fuzihao
 * @date 2019/8/14 16:13
 * 全局拦截器，用于日志操作
 */
@Configuration
public class TrainWebConfig implements WebMvcConfigurer {
    //全局异常处理
    @Bean
    GlobalExceptionHandler globalExceptionHandler(){
        return new GlobalExceptionHandler();
    }
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new OperationLogInterceptor())
                .addPathPatterns("/**")
                .excludePathPatterns("/api/**");
    }
}
```

此时put等操作时，发现elementService报错NPE，

```tex
new Interceptor() 即是我们定义的拦截器。此时若是在Interceptor类内使用@Autowired注解引入bean实例，必然导致无法注入，实例为null的情况。即如果类A中存在成员属性b, b是通过@Autowired自动注入，而类A的实例是通过new的方式产生的，那么自动注入会失效的。

网上传说:了解SpringBoot的都知道SpringBoot的目录格式有着明确的规定,它减轻编程人员负担的同时,更加要求了编程的规范化,SpringBoot初始化的时候,会加载com.boot.app下的bean,一层一层加载,当注册LoggerInterceptor的时候,发现LoggerInterceptor中有@Autowired注解,就会去另外一个spring管理器中索取另外一个LoggerJpa,而这时候LoggerJpa根本没有初始化.所以就无法注入LoggerJpa的bean类完成相应的操作.

自我理解:注册拦截器时直接通过new LoggerInterceptor(),并没有触发Spring去管理bean,所以@Autowired没有生效.

转自简书：https://www.jianshu.com/p/60ff6d0dae7f
```

此时我们手动初始化Bean对象

```java
package com.capol.training.newemployee.server.helpers.config;

import com.capol.base.exception.handle.GlobalExceptionHandler;
import com.capol.training.newemployee.server.interceptor.OperationLogInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * @author fuzihao
 * @date 2019/8/14 16:13
 * 全局拦截器，用于日志操作
 */
@Configuration
public class TrainWebConfig implements WebMvcConfigurer {
    @Bean
    GlobalExceptionHandler globalExceptionHandler(){
        return new GlobalExceptionHandler();
    }
    @Bean
    public OperationLogInterceptor operationLogInterceptor(){
        return new OperationLogInterceptor();
    }
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new OperationLogInterceptor())
                .addPathPatterns("/**")
                .excludePathPatterns("/api/**");
    }
}
```

即可运行，当然为了如果不想每个拦截器都手动注入一遍的话，也可以设置一个SpringContextUtils，在拦截器中手动注入各属性

```java
package com.capol.training.newemployee.server.helpers.config;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;

/**
 * @author fuzihao
 * @date 2019/8/14 16:52
 */
@Component
public class SpringContextUtils implements ApplicationContextAware {
    /**
     * 上下文对象实例
     */
    private static ApplicationContext applicationContext;

    @Override
    @Autowired
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }

    /**
     * 获取applicationContext
     * @return
     */
    public static ApplicationContext getApplicationContext() {
        return applicationContext;
    }

    /**
     * 通过name获取 Bean.
     * @param name
     * @return
     */
    public static Object getBean(String name){
        return getApplicationContext().getBean(name);
    }

    /**
     * 通过class获取Bean.
     * @param clazz
     * @param <T>
     * @return
     */
    public static <T> T getBean(Class<T> clazz){
        return getApplicationContext().getBean(clazz);
    }

    /**
     * 通过name,以及Clazz返回指定的Bean
     * @param name
     * @param clazz
     * @param <T>
     * @return
     */
    public static <T> T getBean(String name,Class<T> clazz){
        return getApplicationContext().getBean(name, clazz);
    }
}
```

此时即可将拦截器的注入方式改为：

```java
private ILogService logService= (ILogService) SpringContextUtils.getBean("logServiceImpl");
private IElementService elementService= (IElementService) SpringContextUtils.getBean("elementServiceImpl");
```

此时TrainWebConfig也不再需要注入拦截器了！