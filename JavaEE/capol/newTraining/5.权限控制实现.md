## 数据表的建立

首先有如下数据表

t_employee：用户表

t_group：角色表

t_group_employee：用户角色对应表

t_emnu：页面菜单表，具体如下

![](D:\Work\TyporaNotes\note\JavaEE\capol\newTraining\pict\5-1.jpg)

![](D:\Work\TyporaNotes\note\JavaEE\capol\newTraining\pict\5-2.jpg)

t_element：操作元素表，具体如下

![](D:\Work\TyporaNotes\note\JavaEE\capol\newTraining\pict\5-3.jpg)

![](D:\Work\TyporaNotes\note\JavaEE\capol\newTraining\pict\5-4.jpg)

t_group_authority：角色及操作权限表，具体如下

![](D:\Work\TyporaNotes\note\JavaEE\capol\newTraining\pict\5-5.jpg)

![](D:\Work\TyporaNotes\note\JavaEE\capol\newTraining\pict\5-6.jpg)

## 纯前端的实现

注意：这里的纯前端实现不是只用前端来敲代码实现，这里的意思是前端做页面的渲染，比如某个用户没有某个模块的权限，即此模块不显示；

但是，此时用此用户的token来访问后台的该模块内的接口，如果后台不加以控制，也是并未能够拦截的。

首先Controller提供接口，用于获取用户的权限列表等信息

```java
/**
     * 获取用户的权限菜单列表
     * @return
     */
@GetMapping("/auth")
public ObjectResponse selectUserMenu(){
    Long userId=Long.valueOf(TrainingUserUtils.getUserId());
    List<ElementVO> elementsList = elementService.getElementsList(userId);
    List<MenuVO> menuList = menuService.getMenuList(userId);
    EmployeeVO employeeVO=employeeService.getEmployeeById(userId);
    Map<String,Object> res=new HashMap<>(3);
    res.put("element",elementsList);
    res.put("menu",menuList);
    res.put("userInfo",employeeVO);
    return new ObjectResponse<Map<String,Object>>().data(res);
}
```

### menu后端实现

menu为前端显示的树形菜单列表

#### service

在sevice中获取当前用户的所有拥有权限的menus，并将其转为树形的格式

即menuVo中拥有List< MenuVo >属性：

```java
/**
 * @author fuzihao
 * @date 2019/8/19 9:40
 */
@Slf4j
@Service
public class MenuServiceImpl extends BaseService<MenuMapper, MenuDTO> implements IMenuService {
    @Override
    public List<MenuVO> getMenuList(Long userId) {
        List<MenuDTO> menuDtos = mapper.getAllMenus(userId);
        List<MenuVO>  menuVos;
        try {
            menuVos=TrainingBeanUtils.dtoListToVoList(menuDtos,MenuVO.class);
        } catch (Exception e) {
            log.error("MenuDTO转换MenuVO失败");
            throw new ObjectConvertException("MenuDTO转换MenuVO失败");
        }
        return getMenuTree(menuVos);

    }

    /**
     * 将 菜单 转为 树形格式
     * @param menuVos menuVos
     * @return List
     */
    private List<MenuVO> getMenuTree(List<MenuVO> menuVos) {
        List<MenuVO> trees=new ArrayList<>();
        if(CollectionUtil.isNotEmpty(menuVos)){
            for(MenuVO node:menuVos){
                if(node.getParentId()==null){
                    trees.add(node);
                }
                //取出孩子节点 并添加至children属性中
                List<MenuVO> children=menuVos
                        .stream()
                        .filter(p->p.getParentId()!=null
                        && p.getParentId().longValue()==node.getId().longValue())
                        .collect(Collectors.toList());
                if(children.size()>0){
                    node.setChildren(children);
                }
            }
        }
        return trees;
    }

}
```

#### Mapper

```xml
<select id="getAllMenus" parameterType="Long" resultType="com.capol.training.newemployee.common.entity.dto.MenuDTO">
    select * from t_menu where id in
    (
    select authority_id from t_group_authority g LEFT JOIN
    t_menu m on g.authority_id=m.id
    WHERE authority_type='menu' and  group_id=
    (select DISTINCT group_id from t_group_employee where `status`=1 and employee_id=#{id})
    )
    order by parent_id asc, order_num asc
</select>
```

### menu前端渲染

前端在判断身份成功，即成功登陆后，调用权限接口

```js
if(data['menu'].length>0){
    if(typeof(data["menu"]) != "undefined" && data["menu"].length > 0){
        //导航菜单
        localStorage.setItem("menu_list", JSON.stringify(data["menu"]));
        _that.$message({
            type: 'success',
            message: '欢迎来到新人入职平台'
        });
    }
}
```

首先将menu存储至localStorage中，然后跳转至首页

在Sidebar.vue页面中渲染树形菜单

```vue
<template>
    <div class="sidebar">
        <!--background-color="#324157" text-color="#bfcbd9" active-text-color="#20a0ff"-->
        <el-menu v-loading="listLoading" class="sidebar-el-menu" :default-active="onRoutes" :collapse="collapse" unique-opened router>
            <template v-for="item in items">
                <template v-if="item.children">
                    <el-submenu :index="item.code" :key="item.code">
                        <template slot="title">
                            <i :class="['iconfont',item.icon]"></i>
                            <span slot="title">{{ item.title }}</span>
                        </template>
                        <template v-for="subItem in item.children">
                            <el-menu-item  :index="subItem.code" :key="subItem.code">
                                <i :class="['iconfont',subItem.icon]"></i>
                                {{ subItem.title }}
                            </el-menu-item>
                        </template>
                    </el-submenu>
                </template>
                <template v-else>
                    <el-menu-item :index="item.code" :key="item.code">
                        <i :class="['iconfont',item.icon]"></i>
                        <span slot="title">{{ item.title }}</span>
                    </el-menu-item>
                </template>
            </template>
        </el-menu>
    </div>
</template>

<script>
    import bus from '../../bus/bus';
    export default {
        name:'sidebar',
        data() {
            return {
                listLoading:true,
                collapse: false,
                items: [],
                serverName: ''
            }
        },
        computed:{
            onRoutes(){
                const _that = this
                return _that.$route.path.replace('/','')
            }
        },
        created(){
            /*通过 Event Bus 进行组件间通信，来折叠侧边栏*/
            bus.$on('collapse', msg => {
                this.collapse = msg
            })
        },
        mounted(){
            const _that = this
            _that.init()
        },
        methods:{
            init(){
                const _that = this;
                let menu_list = JSON.parse(localStorage.getItem("menu_list"));
                if (localStorage.getItem("menu_list") != null && menu_list.length > 0) {
                    const menuList = eval('(' + localStorage.getItem("menu_list") + ')');
                    _that.items = menuList;
                } else {
                    _that.$notify({
                        title: '提示',
                        message: '菜单异常',
                        type: 'warning',
                        duration: 3500,
                        position: 'top-right'
                    })
                }
                setTimeout(function(){
                    _that.listLoading = false;
                },500)
            }
        }
    }
</script>

<style lang="scss" rel="stylesheet/scss" scoped>
    @import "../../sass/base/sidebar";
</style>

```

其中前端页面的 Sidebar、Head等渲染过程如下

```vue
<template>
    <div class="wrapper">
        <v-head></v-head>
        <v-sidebar></v-sidebar>
        <div :class="['content-box',{'content-collapse':collapse}]">
            <v-tags></v-tags>
            <!--非IE使用动画-->
            <div v-if="!isIe" class="content hx-scroll">
                <transition name="move" mode="out-in">
                    <keep-alive>
                        <router-view v-if="$route.meta.keepAlive"></router-view>
                    </keep-alive>
                </transition>
                <transition name="move" mode="out-in">
                    <router-view v-if="!$route.meta.keepAlive"></router-view>
                </transition>
            </div>
            <!--IE不使用动画-->
            <div v-else class="content hx-scroll">
                <keep-alive>
                    <router-view v-if="$route.meta.keepAlive"></router-view>
                </keep-alive>
                <router-view v-if="!$route.meta.keepAlive"></router-view>
            </div>
        </div>
    </div>
</template>

<script>
    import vHead from './Header.vue';
    import vSidebar from './Sidebar.vue';
    import vTags from './Tags.vue';
    import bus from '../../bus/bus';
    export default {
        name:'home',
        data(){
            return {
                tagsList: [],
                excludeList:['familyProcess','seeZuType'],
                collapse: false,
                isIe:false,
            }
        },
        components:{
            vHead, vSidebar, vTags
        },
        created(){
            this.isIe = this.$utils.isIE();

            bus.$on('collapse', msg => {
                this.collapse = msg;
            })

            // 只有在标签页列表里的页面才使用keep-alive，即关闭标签之后就不保存到内存中了。
            bus.$on('tags', msg => {
                let arr = [];
                for(let i = 0, len = msg.length; i < len; i ++){
                    /*if(msg[i].name !== 'familyProcess'){*/
                        msg[i].name && arr.push(msg[i].name);
                   /* }*/
                }
                this.tagsList = arr;
            })
        }
    }
</script>

```

在index.js中，将home作为母版页

```js
import Vue from 'vue'
import Router from 'vue-router'
import home from '../components/common/Home' //母版页

import login from '../view/login/login' //登录
import register from '../view/register/register' //注册
import error404 from '../view/exception/error404' //404
import error403 from '../view/exception/error403' //403
import noPermission from '../view/exception/noPermission' //无权限
import gateLog from '../view/basicsConfig/gateLog' //操作日志

import noticeManage from '../view/noticeManage/noticeManage' //公告管理
import documentation from '../view/documentation/documentation' //文档资料
import entryNotice from '../view/entryNotice/entryNotice' //入职公告

Vue.use(Router);

export default new Router({
    routes: [
        {
            path: '/',
            redirect: '/entryNotice'
        },
        {
            path: '/',
            component: home,
            meta: {title: '自述文件'},
            children: [
                {
                    path: '/entryNotice',
                    name: 'entryNotice',
                    component: entryNotice,
                    meta: {title: '入职公告', keepAlive: false}
                },{
                    path: '/documentation',
                    name: 'documentation',
                    component: documentation,
                    meta: {title: '文档资料', keepAlive: false}
                },
                {
                    path: '/noticeManage',
                    name: 'noticeManage',
                    component: noticeManage,
                    meta: {title: '公告管理', keepAlive: false}
                },
                {
                    path: '/gateLog',
                    name: 'gateLog',
                    component: gateLog,
                    meta: {title: '日志管理', keepAlive: false}
                }
            ]
        }
    ]
})
```

### element后端实现

#### service

首先在service中获取用户的所有 操作元素

```java
/**
     * 获取某用户的 所有菜单
     * @param userId
     * @return
     */
@Override
public List<ElementVO> getElementsList(Long userId) {
    List<ElementDTO> elementDtos = mapper.selectElements(userId);
    List<ElementVO> elementVos;
    try {
        elementVos=TrainingBeanUtils.dtoListToVoList(elementDtos,ElementVO.class);
    } catch (Exception e) {
        log.error("ElementDTO转换ElementVO失败");
        throw new ObjectConvertException("ElementDTO转换ElementVO失败");
    }
    return elementVos;
}
```

#### Mapper

```xml
<select id="selectElements" parameterType="Long" resultType="com.capol.training.newemployee.common.entity.dto.ElementDTO">
    select * from t_element
    where id in
    (
    select authority_id
    from t_group_authority
    where
    group_id =
    (
    select group_id
    from t_group_employee
    where status=1 and employee_id=#{id}
    )
    and authority_type='element'
    )
</select>
```

### element前端实现

封装一个element对象，将elements每个code取出来，另其值为true，将存储至Cookie中

```vue
//菜单-按钮权限
const elements={}
for(let i=0;i<data.element.length;i++){
	elements[data.element[i].code]=true;
}
_that.$Global.setQxCookie(JSON.stringify(elements))
```

在main.js中，引入了`./utils/global`，并定义全局变量，将其定义为$Global

```js
import Vue from 'vue'
import App from './App'
import router from './router'
import axios from 'axios'
import Cookie from 'js-cookie'
import qs from 'qs'
import ElementUI from 'element-ui'
import NProgress from 'nprogress' // Progress 进度条
import 'nprogress/nprogress.css' // Progress 进度条 样式
import * as filters from './filters/index' //全局filters
import global_ from './utils/global'
import '../theme/theme-capol/index.css'
import "babel-polyfill"
import Utils from './utils/utils'
import API from './api/index'
import { getToken,setToken,removeToken } from './utils/auth'

Vue.use(ElementUI, { size: 'small' })
Vue.prototype.$axios = axios
Vue.prototype.$utils = Utils
Vue.prototype.$qs = qs
Vue.prototype.$Cookie = Cookie
Vue.prototype.$API = API
Vue.prototype.$Global = global_
Vue.prototype.getToken = getToken
Vue.prototype.setToken = setToken
Vue.prototype.$nprogress = NProgress

/**
 * 下载文件
 * @param params
 * 文件ID
 * 文件存放路径
 */
Vue.prototype.downLoadFile = function (params) {
    let baseUrl = process.env.BASE_API_ROOT;
    window.location.href = baseUrl + '/fileApi/file/server/download/train?file=' + params + '&token=' + getToken();
}

/**
 * 清理用户登录信息
 */
Vue.prototype.$clearCookie = function () {
    removeToken();
    localStorage.removeItem("ms_username");
    localStorage.removeItem("menu_list");
    global_.removeQxCookie();
}
```

主要代码为：

`import global_ from './utils/global'`

`Vue.prototype.$Global = global_`

而在global.js中有get及set Cookie的方法

```js
import Cookies from 'js-cookie'
const qxManage = 'qx_cookie'

function setQxCookie(obj) {
    return Cookies.set(qxManage,obj);
}

function getQxCookie() {
    return Cookies.get(qxManage);
}

function removeQxCookie() {
    return Cookies.remove(qxManage);
}

export default {
    setQxCookie,
    getQxCookie,
    removeQxCookie
}
```

据此，完美发现其存储过程！

而在main.js中，我们也可以发现getQxBool方法，其中调用了getQxCookie，用以获取element信息

```js
/**
 * 获取权限
 * 判断权限是否存在，不存在跳转到登录页
 * @param val
 * @returns {*}
 */
Vue.prototype.getQxBool = function (val) {
    let obj = null;
    let userInfo = localStorage.getItem('ms_username');
    if (global_.getQxCookie() && global_.getQxCookie() == "") {
        Vue.prototype.$clearCookie();
        location.reload();
    } else {
        if(userInfo){
            userInfo = JSON.parse(userInfo);
            if(userInfo['groupCode'] && userInfo['groupCode'].split(',').length > 0){
                //是否为超级管理员
                if (userInfo['groupCode'].split(',').includes('superAdmin')) {
                    obj = true;
                } else {
                    obj = JSON.parse(global_.getQxCookie())[val];
                }
            }else{
                Vue.prototype.$clearCookie();
                location.reload();
            }
        }else{
            Vue.prototype.$clearCookie();
            location.reload();
        }
    }
    return obj;
}
```

最后，我们就可以在自己想要做权限控制的地方添加设置啦。

比如，我们在缓存清除功能上，此按钮只有“超级管理员”才可以进行操作，我们可以在前端以此设置

```vue
<template>
	<el-button icon="el-icon-refresh" v-if="notice_updateEntryNow" type="primary" size="small" style="float: right;" @click="clearEntry">公告刷新</el-button>
</template>
<script>
export default {
    name:'gateLog',
    data(){
        return{
            notice_updateEntryNow:false,
        }
    }
}
mounted() {
    let content = '';  // 请求后台返回的内容字符串
    this.notice_updateEntryNow=this.getQxBool('notice:updateEntryNow')
    this.init();
},
</script>
```

此时如果用户非“超级管理员”，notice_updateEntryNow则为false，按钮即不显示。

### userInfo后端实现

后端实现较为简单，直接查表，这里不做赘述

### userInfo前端实现

前端存储至localStorage中

```vue
localStorage.setItem("ms_username",JSON.stringify(data.userInfo));
```

在需要用到用户信息的地方，比如header中需要显示用户的name，即可通过localStorage获取到用户name

```vue
created(){
    let userInfo = localStorage.getItem('ms_username');
    // this.baseUrl = process.env.BASE_API_ROOT;
    userInfo = JSON.parse(userInfo);
    this.name=userInfo.name?userInfo.name:'-'
},
```

### 接口调用完整过程

```js
getElements(){
    const _that=this;
    if(_that.getToken()){
        _that.$API.login.getMenuUserList().then(function(res){
            if(res.status===200){
                let data=res.data;
                if(data['menu'].length>0){
                    localStorage.setItem("ms_username",JSON.stringify(data.userInfo));
                    if(typeof(data["menu"]) != "undefined" && data["menu"].length > 0){
                        //导航菜单
                        localStorage.setItem("menu_list", JSON.stringify(data["menu"]));
                        _that.$message({
                            type: 'success',
                            message: '欢迎来到新人入职平台'
                        });

                        //菜单-按钮权限
                        const elements={}
                        for(let i=0;i<data.element.length;i++){
                            elements[data.element[i].code]=true;
                        }
                        _that.$Global.setQxCookie(JSON.stringify(elements))
                        _that.$nprogress.done()
                        _that.$router.push('/');
                    }else{
                        _that.$nprogress.done()
                        _that.subLoading = false
                        _that.loadingText = "登录"
                        _that.$notify({
                            title: '提示',
                            message: '请联系管理员，你没有权限',
                            type: 'warning',
                            duration: 3500,
                            position: 'top-right'
                        })
                        _that.$router.push('/noPermission');
                    }
                }else{
                    _that.$nprogress.done();
                    _that.subLoading = false;
                    _that.loadingText = "登录";
                    _that.$notify({
                        title: '提示',
                        message: '请联系管理员，你没有权限',
                        type: 'warning',
                        duration: 3500,
                        position: 'top-right'
                    })
                    _that.$router.push('/noPermission');
                }
            }else{
                _that.$nprogress.done();
                _that.subLoading = false;
                _that.loadingText = "登录";
                _that.$notify({
                    title: '提示',
                    message: '请联系管理员，你没有权限',
                    type: 'warning',
                    duration: 3500,
                    position: 'top-right'
                })
                _that.$router.push('/noPermission');
            }
        }).catch(function (error) {
            _that.$nprogress.done()
            _that.subLoading = false
            _that.loadingText = "登录"
            _that.$notify({
                title: '提示',
                message: '获取权限信息失败！',
                type: 'error',
                duration: 2500,
                position: 'top-right'
            })
            console.log(error)
        })
    }else{
        _that.$notify({
            title: '提示',
            message: 'Token获取失败',
            type: 'warning',
            duration: 3500,
            position: 'top-right'
        })
        _that.$nprogress.done()
    }
}
```



## 后端配合权限控制

以上我们只是在前端显示上实现了“假权限控制”，我们还需要后端配合，实现真正的权限控制。

首先最直接的是，我们可以在每个controller判断用户的身份，但这样不仅代码冗杂，也增加了我们的维护成本。

此时可以通过“注解+AOP”的方式来实现权限的控制。

具体如下。

#### Enum

首先是一个 用户角色的枚举类

```java
package com.capol.training.newemployee.server.helpers.authority;

/**
 * @author fuzihao
 * @date 2019/8/20 9:07
 */
public enum AuthorityEnum {
    /**
     * 超级管理员
     */
    SUPER_ADMIN("superAdmin"),
    /**
     * 系统管理员
     */
    SYS_ADMIN("sysAdmin"),
    /**
     * 项目管理者
     */
    PRO_LEADER("proLeader"),
    /**
     * 新入职员工
     */
    ENTRYE_EMPLOYEE("entryEmployee");

    String code;
    AuthorityEnum(String code){
        this.code=code;
    }
}
```

#### Anno

注解类，修饰于方法上

```java
package com.capol.training.newemployee.server.helpers.authority;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * @author fuzihao
 * @date 2019/8/20 9:06
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
public @interface AuthorityAnno {
    AuthorityEnum value();
}
```



* 扩展：@Retention中Source、class、runtime区别及应用场景

  ```tex
  1、RetentionPolicy.SOURCE：注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；
  2、RetentionPolicy.CLASS：注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期；
  3、RetentionPolicy.RUNTIME：注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在；
  
  这3个生命周期分别对应于：Java源文件(.java文件) ---> .class文件 ---> 内存中的字节码。
  
  那怎么来选择合适的注解生命周期呢？
  
  首先要明确生命周期长度 SOURCE < CLASS < RUNTIME ，所以前者能作用的地方后者一定也能作用。一般如果需要在运行时去动态获取注解信息，那只能用 RUNTIME 注解；如果要在编译时进行一些预处理操作，比如生成一些辅助代码（如 ButterKnife），就用 CLASS注解；如果只是做一些检查性的操作，比如 @Override 和 @SuppressWarnings，则可选用 SOURCE 注解。
  ```

#### Aspect

接下来是重点，切面的定义

```java
package com.capol.training.newemployee.server.helpers.authority;

import cn.hutool.json.JSONUtil;
import com.capol.base.response.BaseResponse;
import com.capol.training.newemployee.common.helpers.utils.TrainingUserUtils;
import com.capol.training.newemployee.server.entity.vo.EmployeeVO;
import com.capol.training.newemployee.server.service.IEmployeeService;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestAttributes;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

/**
 * @author fuzihao
 * @date 2019/8/20 9:19
 */
@Slf4j
@Aspect
@Component
public class AuthorityAspect {
    @Autowired
    private IEmployeeService employeeService;

    @Around("@annotation(authorityAnno)")
    public Object aroundOperDeal(ProceedingJoinPoint point, AuthorityAnno authorityAnno) throws Throwable {
        Long userId= Long.valueOf(TrainingUserUtils.getUserId());
        EmployeeVO employee = employeeService.getEmployeeById(userId);
        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();
        ServletRequestAttributes sra= (ServletRequestAttributes) requestAttributes;
        if(sra==null){
            log.error("权限AOP sra 空指针异常");
            throw new RuntimeException();
        }
        HttpServletResponse response = sra.getResponse();
        BaseResponse baseResponse=new BaseResponse(40301,"");
        String s = JSONUtil.toJsonStr(baseResponse);
        if(employee==null){
            return s;
        }
        if(response==null){
            return s;
        }
        String groupCode = employee.getGroupCode();
        System.out.println("权限："+groupCode);
        //超级管理员的权限
        if (authorityAnno.value() == AuthorityEnum.SUPER_ADMIN) {
            if(!groupCode.equals(AuthorityEnum.SUPER_ADMIN.code)){
                writerNoAuth(response,s);
                return null;
            }
        }

        //系统管理员的权限
        if (authorityAnno.value() == AuthorityEnum.SYS_ADMIN) {
            if(!(groupCode.equals(AuthorityEnum.SYS_ADMIN.code)
                    ||groupCode.equals(AuthorityEnum.SUPER_ADMIN.code))){
                writerNoAuth(response,s);
                return null;
            }
        }

        //项目管理者的权限
        if (authorityAnno.value() == AuthorityEnum.PRO_LEADER) {
            if(!(groupCode.equals(AuthorityEnum.PRO_LEADER.code)
                    ||groupCode.equals(AuthorityEnum.SYS_ADMIN.code)
                    ||groupCode.equals(AuthorityEnum.SUPER_ADMIN.code))){
                writerNoAuth(response,s);
                return null;
            }
        }
        return point.proceed();
    }


    private void writerNoAuth(HttpServletResponse response,String msg) throws IOException {
        PrintWriter writer = response.getWriter();
        writer.write(msg);
        writer.flush();
    }
}
```

针对不同注解，得到的权限要求，并拦截获得当前用户id（其中用户id是在gateway拦截判断身份设置于ThreadLocal中的，再到此处从ThreadLocal中获取）用于获取用户的身份，如果用户的身份满足于调用方法的权限要求，即放行，否则response输出错误信息。

#### 使用

此时我们就可以在需要的地方使用此注解了

```java
@AuthorityAnno(AuthorityEnum.SUPER_ADMIN)
@PutMapping("/updateEntryNow")
public BaseResponse updateEntryNow(){
    log.info("刷新缓存");
    redisService.delete(TrainingConstant.REDIS_HKEY_TRAIN_ENTRYNOTICE);
    redisService.delete(TrainingConstant.REDIS_HKEY_TRAIN_ENTRYNOTICE_TOTAL);
    return new BaseResponse(ResponseCode.RESPONSE_CODE_200, MessageConstant.EDIT_SUCCESS);
}
```

比如，刚才的刷新缓存操作，我们只允许 “超级管理员”使用，我们就可以这样设置。

