给出以下全局异常处理方案：

#### 基本实现

首先定义如下异常类

```java
package com.capol.training.newemployee.common.helpers.exception.entity;

import com.capol.base.exception.BaseException;
import com.capol.training.newemployee.common.helpers.code.TrainingResponseCode;

/**
 * 对象拷贝异常
 * @author fuzihao
 * @date 2019/8/19 14:29
 */
public class ObjectConvertException extends BaseException {
    public ObjectConvertException(String message) {
        super(message, TrainingResponseCode.RESPONSE_CODE_CONVERT_FAILD);
    }
}
```

其中BaseException如下

```java
public class BaseException extends RuntimeException {
    private int status = 200;

    public int getStatus() {
        return this.status;
    }

    public void setStatus(int status) {
        this.status = status;
    }

    public BaseException() {
    }

    public BaseException(String message, int status) {
        super(message);
        this.status = status;
    }

    public BaseException(String message) {
        super(message);
    }

    public BaseException(String message, Throwable cause) {
        super(message, cause);
    }

    public BaseException(Throwable cause) {
        super(cause);
    }

    public BaseException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
```

可以看到BaseException继承了RuntimeException，且其构造函数中都直接super(message)抛出异常；

实现项目的ExceptionHandler，继承至GlobalExceptionHandler

```java
/**
 * @author fuzihao
 * @date 2019/8/19 14:40
 */
@Slf4j
@ResponseBody
public class TrainingGlobalExceptionHandler extends GlobalExceptionHandler {
    @ExceptionHandler(ObjectConvertException.class)
    public BaseResponse objectConvertException(Exception ex) {
        log.error(ex.getMessage(),ex);
        return new BaseResponse(TrainingResponseCode.RESPONSE_CODE_CONVERT_FAILD, ex.getMessage());
    }
}
```

其中GlobalExceptionHandler来自于基础服务，通过@ControllerAdvice注解实现对包下文件的全局异常操控

```java
//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//

package com.capol.base.exception.handle;

import com.capol.base.exception.BaseException;
import com.capol.base.exception.NormalException;
import com.capol.base.exception.auth.ClientTokenException;
import com.capol.base.exception.auth.UserInvalidException;
import com.capol.base.exception.auth.UserTokenException;
import com.capol.base.exception.validate.ParameterValidateException;
import com.capol.base.response.BaseResponse;
import javax.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

@ControllerAdvice({"com.capol"})
@ResponseBody
public class GlobalExceptionHandler {
    private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    public GlobalExceptionHandler() {
    }

    @ExceptionHandler({ClientTokenException.class})
    public BaseResponse clientTokenExceptionHandler(HttpServletResponse response, ClientTokenException ex) {
        response.setStatus(403);
        log.error(ex.getMessage(), ex);
        return new BaseResponse(ex.getStatus(), ex.getMessage());
    }

    @ExceptionHandler({UserTokenException.class})
    public BaseResponse userTokenExceptionHandler(HttpServletResponse response, UserTokenException ex) {
        response.setStatus(200);
        log.error(ex.getMessage(), ex);
        return new BaseResponse(ex.getStatus(), ex.getMessage());
    }

    @ExceptionHandler({UserInvalidException.class})
    public BaseResponse userInvalidExceptionHandler(HttpServletResponse response, UserInvalidException ex) {
        response.setStatus(200);
        log.error(ex.getMessage(), ex);
        return new BaseResponse(ex.getStatus(), ex.getMessage());
    }

    @ExceptionHandler({ParameterValidateException.class})
    public BaseResponse parameterValidateExceptionHandler(HttpServletResponse response, ParameterValidateException ex) {
        log.error(ex.getMessage(), ex);
        response.setStatus(200);
        return new BaseResponse(ex.getStatus(), ex.getMessage());
    }

    @ExceptionHandler({BaseException.class})
    public BaseResponse baseExceptionHandler(HttpServletResponse response, BaseException ex) {
        log.error(ex.getMessage(), ex);
        response.setStatus(500);
        return new BaseResponse(ex.getStatus(), ex.getMessage());
    }

    @ExceptionHandler({NormalException.class})
    public BaseResponse normalExceptionHandler(HttpServletResponse response, NormalException ex) {
        log.error(ex.getMessage(), ex);
        response.setStatus(HttpStatus.NOT_ACCEPTABLE.value());
        return ex.getResponse();
    }

    @ExceptionHandler({Exception.class})
    public BaseResponse otherExceptionHandler(HttpServletResponse response, Exception ex) {
        response.setStatus(500);
        log.error(ex.getMessage(), ex);
        return new BaseResponse(500, ex.getMessage());
    }
}

```

在全局配置下，通过bean注入exceptionHandler

```java
/**
 * @author fuzihao
 * @date 2019/8/14 16:13
 * 全局配置，用于日志操作及异常处理
 */
@Configuration
public class TrainWebConfig implements WebMvcConfigurer {
    @Bean
    GlobalExceptionHandler globalExceptionHandler(){
        return new TrainingGlobalExceptionHandler();
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new OperationLogInterceptor())
                .addPathPatterns("/**")
                .excludePathPatterns("/api/**");
    }
}
```

#### 简洁实现

当然，我们也可以不手动在Config在手动注入bean，直接在TrainingGlobalExceptionHandler中通过@ControllerAdvice实现统一的异常处理，如下

```java
/**
 * @author fuzihao
 * @date 2019/8/19 14:32
 */
@ControllerAdvice("com.capol.training")
@ResponseBody
@Slf4j
public class TrainingGlobalExceptionHandler extends GlobalExceptionHandler {
    @ExceptionHandler(ObjectConvertException.class)
    public BaseResponse objectConvertException(HttpServletResponse response, Exception ex) {
        //response.setStatus(TrainingResponseCode.RESPONSE_CODE_CONVERT_FAILD);
        log.error(ex.getMessage(),ex);
        return new BaseResponse(TrainingResponseCode.RESPONSE_CODE_CONVERT_FAILD, ex.getMessage());
    }
}

```

#### tips

vue在axios请求后，通过 拦截 response的状态码 ，进入进一步的操作

```js
axios.interceptors.response.use(function (response) {
    const res = response.data
    if (response.status === 401 || res.status === 40101) {
        MessageBox.confirm('你已被登出，可以取消继续留在该页面，或者重新登录', '确定登出', {
            confirmButtonText: '重新登录',
            cancelButtonText: '取消',
            type: 'warning'
        }).then(() => {
            router.replace({
                path: 'login',
                query: {redirect: router.currentRoute.fullPath}
            })
            //location.reload(); // 为了重新实例化vue-router对象 避免bug
        }).catch(()=>{
            Notification({
                title: '提示',
                message:"取消登出",
                type: 'warning',
                duration: 2500
            })
        })
        return Promise.reject('error');
    }
    if (res.status === 40301) {
        if(process.env.BASE_AUTO_LOGIN) {
            router.push({
                path: "/automaticLogin"
            });
        } else {
            Notification({
                title: '提示',
                message:"token过期，请重新登录！",
                type: 'warning',
                duration: 3500
            })
            router.push({
                path: "/login"
            });
        }
        return Promise.reject('error');
    }
    if (res.status === 40001) {
        Notification({
            title:'提示',
            message: '账户或密码错误！',
            type: 'warning',
            duration: 2500
        });
        return Promise.reject('error');
    }
    if (response.status !== 200 && res.status !== 200) {
        Message({
            message: res.message,
            type: 'error',
            duration: 5 * 1000
        });
    } else {
        return response;
    }
    if(res.status === 50001){
        Notification({
            title:'提示',
            message: res.message,
            type: 'warning',
            duration: 2500
        });
    } else {
        return response;
    }

}, function (error) {
    //  1.判断请求超时
    if (error.code === 'ECONNABORTED' && error.message.indexOf('timeout') !== -1) {
        Notification({
            title:'提示',
            message: '请求超时5000！',
            type: 'warning',
            duration: 2500
        });
        //console.log('请求超时5000')
        // return service.request(originalRequest);//例如再重复请求一次
    }

    // Do something with response error
    if (error && error.response) {
        if (error.response.status === 401) {
            router.push({
                path: "/login"
            });
        }
        if (error.response.status === 403) {
            router.push({
                path: "/error/403"
            });
        }
        if (error.response.status === 404) {
            router.push({
                path: "/error/404"
            });
        }
    } else {
        router.replace({
            path: 'login',
            query: {redirect: router.currentRoute.fullPath}
        })
    }
    return Promise.reject(error);
});
```

