## 账密加密方式

```js
let lastUserName = _that.ruleForm.username.substring(_that.ruleForm.username.length - 3);
let timestamp = new Date().getTime();
let keyCode = timestamp + lastUserName;
let encryptOne = _that.encryptPadding(_that.ruleForm.password, keyCode);
let encryptVal = _that.encryptPadding(encryptOne,keyCode);
let params = {
    'username':_that.ruleForm.username,
    'password':encryptVal,
    'timestamp':timestamp
}
_that.$API.login.loginEncryption(params).then(function (res) {
    if(res.status==200){
        _that.setToken(res.data.token)
        /**
                                 * 获取菜单
                                 * 获取权限列表
                                 */
        _that.getElements()
    }else{
        _that.subLoading = false;
        _that.loadingText = "登录";
        _that.$nprogress.done();
        _that.$notify({
            title: '提示',
            message:res.message,
            type: 'warning',
            duration: 2500
        })
        console.log(res)
    }
}).catch(function (error) {
    _that.subLoading = false;
    _that.loadingText = "登录";
    _that.$nprogress.done();
    _that.$notify({
        title: '提示',
        message: error.response.data.message,
        type: 'warning',
        duration: 3500,
        position: 'top-right'
    })
    console.log(error);
})
```

#### 以上加密过程，解密方式

```java
/**
     * 规则: 使用AES  KEY:时间戳 + username后三位  decrypt两次
     * @param capolAuthPwdDTO
     * @return
*/
public String decryptPwd(final String username,final String password,final String timeStamp) throws Exception {
    String pwd = null;
    StringBuilder key = new StringBuilder();
    key.append(timeStamp).append(username.substring(username.length()-3,username.length()));
    pwd = AesUtil.decrypt(password,key.toString());
    pwd = AesUtil.decrypt(pwd,key.toString());
    return pwd;
}
```

先引入http的utils包，对 请求时，加上token；及 响应时，判断401状态

同时对put、post等aoix请求进行了封装

```js
/**
 * Created by tongkaiqiang on 2019/2/21.
 */
import axios from 'axios'
import {Message, MessageBox,Notification} from 'element-ui';
import router from '../router'
import { getToken } from './auth'

axios.defaults.withCredentials = true
// axios.defaults.timeout = 5000

axios.interceptors.request.use(
    config => {
        if (getToken()) {
            //application/x-www-form-urlencoded
            //application/json;charset=UTF-8
            //config.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            //config.headers['Access-Control-Allow-Headers'] = 'Authorization'
            config.headers.Authorization = getToken()
        }
        return config
    },
    error => {
        return Promise.reject(error)
    }
)
axios.interceptors.response.use(function (response) {
    const res = response.data
    if (response.status === 401 || res.status === 40101) {
        MessageBox.confirm('你已被登出，可以取消继续留在该页面，或者重新登录', '确定登出', {
            confirmButtonText: '重新登录',
            cancelButtonText: '取消',
            type: 'warning'
        }).then(() => {
            router.replace({
                path: 'login',
                query: {redirect: router.currentRoute.fullPath}
            })
            //location.reload(); // 为了重新实例化vue-router对象 避免bug
        }).catch(()=>{
            Notification({
                title: '提示',
                message:"取消登出",
                type: 'warning',
                duration: 2500
            })
        })
        return Promise.reject('error');
    }
    if (res.status === 40301) {
        if(process.env.BASE_AUTO_LOGIN) {
            router.push({
                path: "/automaticLogin"
            });
        } else {
            Notification({
                title: '提示',
                message:"token过期，请重新登录！",
                type: 'warning',
                duration: 3500
            })
            router.push({
                path: "/login"
            });
        }
        return Promise.reject('error');
    }
    if (res.status === 40001) {
        Notification({
            title:'提示',
            message: '账户或密码错误！',
            type: 'warning',
            duration: 2500
        });
        return Promise.reject('error');
    }
    if (response.status !== 200 && res.status !== 200) {
        Message({
            message: res.message,
            type: 'error',
            duration: 5 * 1000
        });
    } else {
        return response;
    }
    if(res.status === 50001){
        Notification({
            title:'提示',
            message: res.message,
            type: 'warning',
            duration: 2500
        });
    } else {
        return response;
    }

}, function (error) {
    //  1.判断请求超时
    if (error.code === 'ECONNABORTED' && error.message.indexOf('timeout') !== -1) {
        Notification({
            title:'提示',
            message: '请求超时5000！',
            type: 'warning',
            duration: 2500
        });
        //console.log('请求超时5000')
        // return service.request(originalRequest);//例如再重复请求一次
    }

    // Do something with response error
    if (error && error.response) {
        if (error.response.status === 401) {
            router.push({
                path: "/login"
            });
        }
        if (error.response.status === 403) {
            router.push({
                path: "/error/403"
            });
        }
        if (error.response.status === 404) {
            router.push({
                path: "/error/404"
            });
        }
    } else {
        router.replace({
            path: 'login',
            query: {redirect: router.currentRoute.fullPath}
        })
    }
    return Promise.reject(error);
});

export const POST = (url, params) => {
    return axios.post(process.env.BASE_API_ROOT+`${url}`, params).then(res => res.data)
}

export const GET = (url, params) => {
    return axios.get(process.env.BASE_API_ROOT+`${url}`+'?time='+new Date().getTime(), {
        params: params
    }).then(res => res.data)
}

export const PUT = (url, params) => {
    return axios.put(process.env.BASE_API_ROOT+`${url}`, params).then(res => res.data)
}

export const DELETE = (url, params) => {
    return axios.delete(process.env.BASE_API_ROOT+`${url}`, {
        params: params
    }).then(res => res.data)
}

export const PATCH = (url, params) => {
    return axios.patch(process.env.BASE_API_ROOT+`${url}`, params).then(res => res.data)
}

```

以后使用方式如下：

```js
/**
 * Created by tongkaiqiang on 2019/2/21.
 */
import * as HTTP from '@/utils/http'

export default {
    /**
     * 登录
     * @param params
     * @returns {*}
     */
    login: params => {
        "use strict";
         return HTTP.POST('/api/auth/jwt/token', params)
    },
    getMenuUserList:params=>{
        "use strict";
        return HTTP.GET('/famApi/family/menu/auth', params)
    },
}

```

比如获取个人信息

```js
/**
                     * 获取用户个人信息
                     * 获取菜单列表
                     * 获取权限列表
                     */
_that.$API.login.getMenuUserList({'token': _that.getToken()}).then(function (res) {
    if(res.status == 200){
```

每次路由前判断token

```js
router.beforeEach((to, from, next) => {
    NProgress.start();//开启NProgress
    const token = getToken();
    document.title = to.meta.title;
    if(!token && to.path !== '/login'){
        if (whiteList.indexOf(to.path) != -1) {
            next();
        } else {
            if(process.env.BASE_AUTO_LOGIN){
                next('/automaticLogin');
            }else{
                next('/login');
            }
            NProgress.done();
        }
    }else{
        // 简单的判断IE10及以下不进入富文本编辑器，该组件不兼容
        if(navigator.userAgent.indexOf('MSIE') > -1 && to.path === '/editor'){
            Vue.prototype.$alert('vue-quill-editor组件不兼容IE10及以下浏览器，请使用更高版本的浏览器查看', '浏览器不兼容通知', {
                confirmButtonText: '确定'
            });
        }else{
            next();
        }
    }
})

export function getToken() {
    return Cookies.get(TokenKey)
}
```

## 雪花算法设置id

```java
package com.capol.notify.server.helpers.util;

import com.capol.notify.server.helpers.snowflake.SnowflakeIdWorker;
import lombok.extern.slf4j.Slf4j;


@Slf4j
public class IdUtil {

    private static volatile SnowflakeIdWorker instance;

    private IdUtil(){}

    public static SnowflakeIdWorker getInstance() {
        if (instance == null) {
            synchronized (SnowflakeIdWorker.class) {
                if (instance == null) {
                    log.info("when instance, workId = {}, datacenterId = {}", 1, 1);
                    instance = new SnowflakeIdWorker(1, 1);
                }
            }
        }
        return instance;
    }

    public static Long generateId(){
        SnowflakeIdWorker idWorker = IdUtil.getInstance();
        return idWorker.nextId();
    }


```

使用

```java
 msgDTO.setId(IdUtil.generateId());
```

## 复制属性的方法

```java
BeanUtils.copyProperties(employeeDTO, info);
```

```java
/**
	 * Cglib的对象属性拷贝方法，可以拷贝不同Class类之间的同名实例属性（使用动态代理，效率很优,推荐使用）
	 * 注：如果属性类型不同，即使属性名相同将也不会拷贝
	 * @param orig 源对象
	 * @param dest 目标对象
	 */
public static void copyPropertiesByCglib(Object orig, Object dest) throws Exception {
    BeanCopier beanCopier = BeanCopier.create(orig.getClass(), dest.getClass(), false);
    beanCopier.copy(orig, dest, null);
}

/**
	 * Cglib的对象属性拷贝方法,可以拷贝不同Class类之间的同名实例属性,并且可以通过实现Convert接口定制转换指定的类型
	 * @param orig 源对象
	 * @param dest 目标对象
	 * @param converter 转换定义实现,为null时，默认按不转换规则拷贝属性
	 */
public static void copyPropertiesByCglib(Object orig, Object dest, Converter converter) throws Exception {
    // 判断是否使用类型转换接口
    boolean isUseConverter = converter == null ? false : true;
    BeanCopier beanCopier = BeanCopier.create(orig.getClass(), dest.getClass(), isUseConverter);
    beanCopier.copy(orig, dest, converter);
}
```

## 若登录成功，缓存token到redis

```java
/**
     * 缓存token信息到redis
     * @param info
     * @return
     * @throws Exception
     */
private String cacheToken(UserInfo info) throws Exception {
    String token = 
        jwtTokenUtil.generateToken(new JwtInfoDTO(info.getUsername(), info.getId() + "", info.getName()));
    boolean isHasTokenKey=redisService.exists("Token:" + token.substring(0,32));
    if(!isHasTokenKey){
        redisService.set("Token:" + token.substring(0,32), JSONObject.toJSONString(new JwtInfoDTO(info.getUsername(), info.getId() + "", info.getName())));
        redisService.expire("Token:" + token.substring(0,32),expire, TimeUnit.SECONDS);
    }
    return token;
}
```

## 通过ThreadLocal存储用户状态

首先有一个自定义的封装java类，用来存储 用户的userId，通过static令threadLocal保持状态，以Map来保存各信息，比如键"userId"，值userId，键userName，值userName等，以此来保存用户的各信息。

```java
package com.capol.base.helpers.context;
import com.capol.base.helpers.constant.SystemConstant;
import com.capol.base.utils.StringUtil;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.HashMap;
import java.util.Map;
import static org.junit.Assert.assertEquals;

/**
 * Created by huangpingqiang
 * Date: 18/12/27
 * Time: 15:13
 * Version 1.0.0
 */
public class BaseContextHandler {
    public static ThreadLocal<Map<String, Object>> threadLocal = new ThreadLocal<Map<String, Object>>();

    public static void set(String key, Object value) {
        Map<String, Object> map = threadLocal.get();
        if (map == null) {
            map = new HashMap<String, Object>();
            threadLocal.set(map);
        }
        map.put(key, value);
    }

    public static Object get(String key){
        Map<String, Object> map = threadLocal.get();
        if (map == null) {
            map = new HashMap<String, Object>();
            threadLocal.set(map);
        }
        return map.get(key);
    }

    public static String getUserID(){
        Object value = get(SystemConstant.CONTEXT_KEY_USER_ID);
        return returnObjectValue(value);
    }

    public static String getUsername(){
        Object value = get(SystemConstant.CONTEXT_KEY_USERNAME);
        return returnObjectValue(value);
    }


    public static String getName(){
        Object value = get(SystemConstant.CONTEXT_KEY_USER_NAME);
        return StringUtil.getObjectValue(value);
    }

    public static String getToken(){
        Object value = get(SystemConstant.CONTEXT_KEY_USER_TOKEN);
        return StringUtil.getObjectValue(value);
    }
    public static void setToken(String token){set(SystemConstant.CONTEXT_KEY_USER_TOKEN,token);}

    public static void setName(String name){set(SystemConstant.CONTEXT_KEY_USER_NAME,name);}

    public static void setUserID(String userID){
        set(SystemConstant.CONTEXT_KEY_USER_ID,userID);
    }

    public static void setUsername(String username){
        set(SystemConstant.CONTEXT_KEY_USERNAME,username);
    }

    private static String returnObjectValue(Object value) {
        return value==null?null:value.toString();
    }

    public static void remove(){
        threadLocal.remove();
    }
}
```

添加一个全局拦截器，每次请求前确保token：

```java
package com.capol.auth.client.helpers.interceptor;
import com.alibaba.fastjson.JSONObject;
import com.capol.auth.client.helpers.annotation.IgnoreUserToken;
import com.capol.auth.client.helpers.config.UserAuthConfig;
import com.capol.auth.client.utils.UserAuthUtil;
import com.capol.auth.common.entity.IJwtInfo;
import com.capol.base.helpers.context.BaseContextHandler;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;
import org.springframework.web.servlet.resource.ResourceHttpRequestHandler;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.List;

/**
 * Created by huangpingqiang
 * Date: 19/01/03
 * Time: 15:13
 * Version 1.0.0
 */
@Slf4j
public class UserAuthRestInterceptor extends HandlerInterceptorAdapter {

    @Autowired
    private UserAuthUtil userAuthUtil;

    @Autowired
    private UserAuthConfig userAuthConfig;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        if(handler instanceof ResourceHttpRequestHandler){
            return super.preHandle(request, response, handler);
        }
        HandlerMethod handlerMethod = (HandlerMethod) handler;
        // 配置该注解，说明不进行用户拦截
        IgnoreUserToken annotation = handlerMethod.getBeanType().getAnnotation(IgnoreUserToken.class);
        if (annotation == null) {
            annotation = handlerMethod.getMethodAnnotation(IgnoreUserToken.class);
        }
        if (annotation != null) {
            return super.preHandle(request, response, handler);
        }
        String token = request.getHeader(userAuthConfig.getTokenHeader());
        if (StringUtils.isEmpty(token)) {
            if (request.getCookies() != null) {
                for (Cookie cookie : request.getCookies()) {
                    if (cookie.getName().equals(userAuthConfig.getTokenHeader())) {
                        token = cookie.getValue();
                    }
                }
            }
            if (StringUtils.isEmpty(token)) {
                token = request.getParameter("token");
            }
        }
        IJwtInfo infoFromToken = userAuthUtil.getInfoFromToken(token);
        log.info("Auth Client => UserAuthRestInterceptor: "+ JSONObject.toJSONString(infoFromToken));
        BaseContextHandler.setUsername(infoFromToken.getUniqueName());
        BaseContextHandler.setName(infoFromToken.getName());
        BaseContextHandler.setUserID(infoFromToken.getId());
        BaseContextHandler.setToken(token);
        return super.preHandle(request, response, handler);
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        BaseContextHandler.remove();
        super.afterCompletion(request, response, handler, ex);
    }
}
```

```java
package com.capol.auth.server.helpers.config;
import com.capol.auth.server.helpers.interceptor.ServiceAuthRestInterceptor;
import com.capol.auth.server.helpers.interceptor.UserAuthRestInterceptor;
import com.capol.base.exception.handle.GlobalExceptionHandler;
import com.capol.base.exception.handle.GlobalExceptionHandler;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * Created by huangpingqiang
 * Date: 19/01/03
 * Time: 15:13
 * Version 1.0.0
 */
@Configuration("admimWebConfig")
@Primary
public class WebConfig implements WebMvcConfigurer {
    @Bean
    GlobalExceptionHandler getGlobalExceptionHandler() {
        return new GlobalExceptionHandler();
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(getServiceAuthRestInterceptor()).addPathPatterns("/service/**");
        registry.addInterceptor(getUserAuthRestInterceptor()).addPathPatterns("/service/**");
    }

    @Bean
    ServiceAuthRestInterceptor getServiceAuthRestInterceptor() {
        return new ServiceAuthRestInterceptor();
    }

    @Bean
    UserAuthRestInterceptor getUserAuthRestInterceptor() {
        return new UserAuthRestInterceptor();
    }

}

```

## 将页面父子元素  由list转换为  对象+children格式

```java
/**
     * 封装方法，将list格式改为含children的对象
     * @param voList
     * @return
     */
private List<MenuVO> getMenuTree(List<MenuVO> voList) {
    List<MenuVO> trees = new ArrayList<>();
    if (CollectionUtils.isNotEmpty(voList)) {
        for(MenuVO node : voList){
            if ( node.getParentId() == null) {
                trees.add(node);
            }
            List<MenuVO> children = voList
                .stream()
                .filter(p -> p.getParentId() != null
                        && node.getId() != null
                        && p.getParentId().longValue() == node.getId().longValue())
                .collect(Collectors.toList());
            if(children != null && children.size() > 0){
                node.setChildren(children);
            }
        }
    }
    return trees;
}
```

注意：此方法的问题在于  时间复杂度 是O2，可以想办法简化。

## axios 跨域 两次请求问题

##### 问题：

vue axios跨域请求，在`Request Headers`加`Authorization`传递`Token`时，发现统一请求触发了两次，第一次是`Request Method: OPTIONS`请求。

##### 原因：

跨域请求时，浏览器会首先使用`OPTIONS`方法发起一个**预请求**，判断接口是否能够正常通讯。如果通讯异常，则不会发送真正的请求，如果测试通讯正常，则开始真正的请求。

##### 解决方法：

后台：判断请求方式是`OPTIONS`，则不处理；

```java
if (request.getMethod() == HttpMethod.OPTIONS) {
    response.setStatusCode(HttpStatus.OK);
    return Mono.empty();
}
```

## 查询实体类封装

首先为了分页，有一个分页的Vo（其实应该是Dto）

```java
package com.capol.family.manage.common.entity.vo;

import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

import java.io.Serializable;

@Data
public class PageHelperVO implements Serializable {

    private static final long serialVersionUID = 1L;

    @ApiModelProperty("当前分页数")
    private Integer page;

    @ApiModelProperty("当前页显示数量")
    private Integer limit;

    @ApiModelProperty("排序字段")
    private String column;

    @ApiModelProperty("排序规则（desc、asc）")
    private String orderBy;

}
```

然后各个查询，有相应的查询类及字段，继承了以上的分页Vo

```java
package com.capol.family.manage.server.entity.vo.familyProcess;

import com.capol.family.manage.common.entity.vo.PageHelperVO;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import lombok.Data;

import java.io.Serializable;

@ApiModel("族列表查询条件实体类")
@Data
public class FamilySearchVO extends PageHelperVO implements Serializable {

    private static final long serialVersionUID = 1L;

    @ApiModelProperty("专业编号")
    private String specialityNo;

    @ApiModelProperty("分类层级编号")
    private String categoryHierarchyNo;

    @ApiModelProperty("族名称")
    private String familyName;

    @ApiModelProperty("状态：1：待制作，2：待互检，3：待审核，4：互检驳回，5：审核驳回，6：已完成，7：已取消")
    private Integer status;

    @ApiModelProperty("是否我参与的，1：是，0：否")
    private Integer myJoined;

    @ApiModelProperty("用户id")
    private Long userId;
}
```

## Java8函数式编程

大佬的源码

```java
Map<Long, List<CategoryVO>> map = list.stream().collect(Collectors.groupingBy(CategoryVO::getSpecialityId));
```

解释：

```java
List<Fruit> fruitList = Lists.newArrayList(new Fruit("apple", 6),
        new Fruit("apple", 6),
        new Fruit("banana", 7), new Fruit("banana", 7),
        new Fruit("banana", 7), new Fruit("grape",8));

Map<String, Long> map = fruitList.stream().
   collect(Collectors.groupingBy(Fruit::getName,Collectors.counting()));
```

输出结果是：{banana=3, apple=2, grape=1}
 换一种啰嗦、复杂的写法，但能加深理解。

```java
Map<String, Long> map = fruitList.stream().map(Fruit::getName).
  collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
```

自我的代码

```java
package hpsyche.stream;

import org.junit.Test;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * @author fuzihao
 * @date 2019/7/22 11:45
 */
public class StreamTest1 {
    class Fruit{
        private String name;
        private Integer price;

        public Fruit(String name, Integer price) {
            this.name = name;
            this.price = price;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public Integer getPrice() {
            return price;
        }

        public void setPrice(Integer price) {
            this.price = price;
        }
    }
    @Test
    public void test1(){
        List<Fruit> list=new ArrayList();
        list.add(new Fruit("苹果",1));
        list.add(new Fruit("香蕉",2));
        list.add(new Fruit("葡萄",3));
        Map<String, List<Fruit>> collect = list.stream().collect(Collectors.groupingBy(Fruit::getName));

    }
}
```

可以发现collect是一个以fruit的name为键，fruit为值得键值对。

![](D:\tools\notes\SpringCloud\pict\stream.jpg))

## Java 8 Optional 类

Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。

Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。

Optional 类的引入很好的解决空指针异常。

```java
Optional<FamilyInfoDTO> familyInfoMakingOption = null;
  if (familyId != null){
                familyInfoMakingOption = familyInfoList.stream().filter(a -> FamilyStatusEnum.MAKING.getValue().equals(a.getStatus())
                        && !familyId.equals(a.getId())).findAny();
            }else{
                familyInfoMakingOption = familyInfoList.stream().filter(a -> FamilyStatusEnum.MAKING.getValue().equals(a.getStatus())).findAny();
            }
            if (familyInfoMakingOption.isPresent()){
                ...
            }else{
                ...
            }
```

## Feign的使用

基本和5.Hystrix中Feign使用一致，同时加了熔断器。

## Git

放弃自己修改过的代码，抓取远程代码：

git fetch --all
git reset --hard origin/**master (想恢复的分支)**
git fetch 只是下载远程的库的内容，不做任何的合并git reset 把HEAD指向刚刚下载的最新的版本  

## 封装实体验证类

```java
public static <T> ValidationResult validateEntity(T obj) {
    ValidationResult result = new ValidationResult();
    Set<ConstraintViolation<T>> set = validator.validate(obj, Default.class);
    // if( CollectionUtils.isNotEmpty(set) ){
    if (set != null && set.size() != 0) {
        result.setHasErrors(true);
        Map<String, String> errorMsg = new HashMap<String, String>();
        for (ConstraintViolation<T> cv : set) {
            errorMsg.put(cv.getPropertyPath().toString(), cv.getMessage());
        }
        result.setErrorMsg(errorMsg);
    }
    return result;
}
```

判断是否有异常数据

```java
 ValidationResult result = ValidateUtil.validateEntity(familyInfoDTO);
if (result.isHasErrors()) {
    return new ObjectResponse().data(result.getErrorMsg()).rel(false);
}
```

注意：实体中是有假如validate的注解的，比如@NotBlank

## Feign用法

其实family-manage-client是用来暴露server中的接口的，然后给其他服务使用；

比如在family-manage-client中有如下接口：

```java
package com.capol.family.client.api;

import com.capol.family.client.api.hystrix.ManageAnalysisServiceFallback;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PostMapping;

@FeignClient(value = "family-manage-server",fallback = ManageAnalysisServiceFallback.class)
public interface IManageAnalysisApi {
    @PostMapping("/api/manageAnalysis/updateCache")
    void updateCache();
}

```

它用来暴露server下的/api/manageAnalysis/updateCache方法；

sever下有如下rest接口

```java
package com.capol.family.manage.server.web.rpc;

import com.capol.auth.client.helpers.annotation.IgnoreUserToken;
import com.capol.family.manage.server.service.analysis.IManageAnalysisService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("api")
public class ManageAnalysisRest {

    @Autowired
    private IManageAnalysisService manageAnalysisService;

    @IgnoreUserToken
    @PostMapping("/manageAnalysis/updateCache")
    public void updateCache(){
        manageAnalysisService.updateAllFamilyManageAnalysisCache();
    }

}
```

当另一个服务，比如定时任务要更新缓存时，即pom.xml引入family-manage-client，调用其接口；

```java
package com.capol.job.server.helpers.job.family;

import com.capol.elasticjob.annotation.ElasticJobConf;
import com.capol.family.client.api.IManageAnalysisApi;
import com.dangdang.ddframe.job.api.ShardingContext;
import com.dangdang.ddframe.job.api.simple.SimpleJob;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;

@Slf4j
@ElasticJobConf(name="UpdateManageAnalysisCacheJob",cron = "0 0 1 * * ?",eventTraceRdbDataSource = "dataSource", description = "更新族管理分析数据缓存")
public class UpdateManageAnalysisCacheJob implements SimpleJob {

    @Autowired
    private IManageAnalysisApi manageAnalysisApi;

    @Override
    public void execute(ShardingContext shardingContext) {
        manageAnalysisApi.updateCache();
    }
}
```

其中的IManageAnalysisApi即为引入的client包

## 排序

order by count(maker_name) desc,convert(maker_name using gbk) asc

按数量降序排序，如果数量相同，则按名字gbk升序排序

## 好评差评排名

```sql
SELECT  command, sum(if(appraise=1, 1, 0)) praiseCount,sum(if(appraise=2, 1, 0)) negativeCount
            FROM t_family_command_appraise
            where 1=1
                and command like '%c%'
                and date_format(create_time,'%Y') =2019
            group by command
                 order by praiseCount desc,command asc
                limit 0,10
```

## 枚举一般使用

```java
package com.capol.family.manage.server.enums;

public enum FamilyCommandAppraiseEnum {

    PRAISE("好评",1),
    NEGATIVE("差评",2);

    private String name;
    private Integer value;

    FamilyCommandAppraiseEnum(String name, Integer value){
        this.name = name;
        this.value = value;
    }

    public Integer getValue() {
        return value;
    }
    public String getName(){
        return name;
    }
}
```

## 统一异常处理

首先定义异常基类

```java
public class BaseException extends RuntimeException {
    private int status = 200;

    public int getStatus() {
        return status;
    }

    public void setStatus(int status) {
        this.status = status;
    }

    public BaseException() {
    }

    public BaseException(String message,int status) {
        super(message);
        this.status = status;
    }

    public BaseException(String message) {
        super(message);
    }

    public BaseException(String message, Throwable cause) {
        super(message, cause);
    }

    public BaseException(Throwable cause) {
        super(cause);
    }

    public BaseException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
```

接着定义了各大异常类，如 无效参数 异常，注意：需要继承至 异常基类

```java
ublic class InvalidParamException extends BaseException {

    public InvalidParamException(String message) {
        super(message, FamilyResponseCode.RESPONSE_CODE_INVALID_PARAM);
    }
}
```

然后在各service或者controller中如果遇到参数无效的情况，则抛出异常；

最后，定义一个统一异常处理器

```java
@ControllerAdvice("com........")
@ResponseBody
@Slf4j
public class FamilyGlobalExceptionHandler extends GlobalExceptionHandler {

    @ExceptionHandler(InvalidParamException.class)
    public BaseResponse invalidParamException(HttpServletResponse response, Exception ex) {
        response.setStatus(FamilyResponseCode.RESPONSE_CODE_INVALID_PARAM);
        log.error(ex.getMessage(),ex);
        return new BaseResponse(FamilyResponseCode.RESPONSE_CODE_INVALID_PARAM, ex.getMessage());
    }
}
```

## Gateway使用方式

见部分源代码如下：

```yml
spring:
    cloud:
     gateway:
       discovery:
         locator:
           lowerCaseServiceId: true
           enabled: true
       routes:
        # =====================================
        - id: capol-auth
          uri: lb://capol-auth
          order: 8000
          predicates:
          - Path=/api/auth/**
          filters:
          - StripPrefix=2
        - id: capol-admin-server
          uri: lb://capol-admin-server
          order: 8001
          predicates:
          - Path=/api/admin/**
          filters:
          - StripPrefix=2
```

举例解释

```yml
gateway:
      discovery:
        locator:
          enabled: true
          lower-case-service-id: true
      routes:
      - id: service_consumer
        uri: lb://service-consumer
        predicates:
        - Path= /consumer/**
        filters:
        - StripPrefix=1
```

在上面的配置中：

* 配置了一个Path的predicat,将以/consumer/...开头的请求都会转发到uri为lb://service-consumer的地址上，**lb://service-consumer（注册中心中服务的名称）即service-consumer服务的负载均衡地址**
* StripPrefix=1的filter 即为在转发之前将第一个前缀即：/consumer去掉。
* spring.cloud.gateway.discovery.locator.enabled为true，表明Gateway开启服务注册和发现的功能，并且Spring Cloud Gateway自动根据服务发现为每一个服务创建了一个router，这个router将以服务名开头的请求路径转发到对应的服务。
* spring.cloud.gateway.discovery.locator.lowerCaseServiceId是将请求路径上的服务名配置为小写（因为服务注册的时候，向注册中心注册时将服务名转成大写的了）。

