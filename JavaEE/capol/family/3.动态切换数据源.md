## Spring动态切换多数据源

Spring动态配置多数据源，即在大型应用中对数据进行切分，并且采用多个数据库实例进行管理，这样可以有效提高系统的水平伸缩性。而这样的方案就会不同于常见的单一数据实例的方案，这就要程序在运行时根据当时的请求及系统状态来动态的决定将数据存储在哪个数据库实例中，以及从哪个数据库提取数据。

Spring配置多数据源的方式和具体使用过程。 
Spring对于多数据源，以数据库表为参照，大体上可以分成两大类情况： 
一是，表级上的跨数据库。即，对于不同的数据库却有相同的表（表名和表结构完全相同）。 
二是，非表级上的跨数据库。即，多个数据源不存在相同的表。

1、根据用户的选择，使用不同的数据源。

2、解决思路锁定：将sessionFactory的属性dataSource设置成不同的数据源，以达到切换数据源的目的。

3、问题产生：**<font color=red>因为整个项目用的几乎都是单例模式，当多个用户并发访问数据库的时候，会产生资源争夺的问题。即项目启动时候，所有的bean都被装载到内存，并且每个bean都只有一个对象。正因为只有一个对象，所有的对象属性就如同静态变量（静态变量跟单例很相似，常用静态来实现单例）。整个项目系统的dataSource只有一个，如果很多用户不断的去改变dataSource的值，那必然会出现资源的掠夺问题，造成系统隐患。</font>**

4、多资源共享解决思路：同一资源被抢夺的时候，通常有两种做法，a、以时间换空间 b、以空间换时间。 

5、线程同步机制就是典型的“以时间换空间”，采用排队稍等的方法，一个个等待，直到前面一个用完，后面的才跟上，多人共用一个变量，用**synchronized锁定排队。**    

6、“ThreadLocal”就是典型的“以空间换时间”，为每一个人提供一份变量，因此可以同时访问并互不干扰。

## 具体方法

创建SpringBoot项目，pom.xml如下

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.1.6.RELEASE</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.capol</groupId>
	<artifactId>multidatasource</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>multidatasource</name>
	<description>Demo project for Spring Boot</description>

	<properties>
		<java.version>1.8</java.version>
	</properties>

	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter</artifactId>
		</dependency>
		<dependency>
			<groupId>com.microsoft.sqlserver</groupId>
			<artifactId>sqljdbc4</artifactId>
			<version>4.0</version>
		</dependency>
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>5.1.46</version>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>com.alibaba</groupId>
			<artifactId>druid-spring-boot-starter</artifactId>
			<version>1.1.16</version>
		</dependency>
		<dependency>
			<groupId>org.mybatis.spring.boot</groupId>
			<artifactId>mybatis-spring-boot-starter</artifactId>
			<version>1.3.2</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-aop</artifactId>
		</dependency>

		<dependency>
			<groupId>org.mybatis</groupId>
			<artifactId>mybatis</artifactId>
			<version>3.4.1</version>
		</dependency>
		<dependency>
			<groupId>com.alibaba</groupId>
			<artifactId>druid</artifactId>
			<version>1.1.9</version>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

</project>

```

在application.yml中进行如下配置

```yml
spring:
  datasource:
    sqlserver:
      driver-class-name: com.microsoft.sqlserver.jdbc.SQLServerDriver
      jdbc-url: 
      username: 
      password: 
    mysql:
      driver-class-name: com.mysql.jdbc.Driver
      jdbc-url: 
      username: 
      password: 

    druid:
      db-type: com.alibaba.druid.pool.DruidDataSource
```

首先定义一个数据库的枚举类

```java
package com.capol.multidatasource.config;

/**
 * @author fuzihao
 * @date 2019/7/26 16:08
 */
public enum DataSourceEnum {
    MYSQL_DATASOURCE,
    SQLSERVER_DATASOURCE
}
```

其次，有如下的类，持有数据库连接对象与线程中，需要使用ThreadLocal

```java
package com.capol.multidatasource.config;

/**
 * @author fuzihao
 * @date 2019/7/26 15:38
 */
public class DataSourceContextHolder {

    /**
     * 通过Thread保证线程安全
     */
    private static final ThreadLocal<DataSourceEnum> contextHolder = new ThreadLocal<>();

    /**
     * 设置数据源变量
     * @param dataSourceEnum 数据源变量
     */
    public static void setDataBaseType(DataSourceEnum dataSourceEnum) {
        System.err.println("修改数据源为：" + dataSourceEnum);
        contextHolder.set(dataSourceEnum);
    }

    /**
     * 获取数据源变量
     * @return 数据源变量
     */
    public static DataSourceEnum getDataBaseType() {
        DataSourceEnum dataSourceEnum = contextHolder.get() == null ? DataSourceEnum.MYSQL_DATASOURCE : contextHolder.get();
        System.err.println("当前数据源的类型为：" + dataSourceEnum);
        return dataSourceEnum;
    }

    /**
     * 清空数据类型
     */
    public static void clearDataBaseType() {
        contextHolder.remove();
    }

}
```

同时sqlSessionFactory需要一个DynamicDataSource，其继承至AbstractRoutingDatasource，如下

```java
package com.capol.multidatasource.config;

import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;

/**
 * @author fuzihao
 * @date 2019/7/26 14:58
 */
public class DynamicDataSource extends AbstractRoutingDataSource {
    @Override
    protected Object determineCurrentLookupKey() {
        return DataSourceContextHolder.getDataBaseType();
    }

}
```

此时就可以注入各Bean了

```java
package com.capol.multidatasource.config;

import org.apache.ibatis.session.SqlSessionFactory;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

/**
 * @author fuzihao
 * @date 2019/7/26 14:43
 */
@Configuration
public class DataSourceConfig {
    @Bean(name = "sqlserverDataSource")
    @ConfigurationProperties(prefix = "spring.datasource.sqlserver")
    public DataSource getDateSource1() {
        return DataSourceBuilder.create().build();
    }

    @Bean(name = "mysqlDataSource")
    @ConfigurationProperties(prefix = "spring.datasource.mysql")
    public DataSource getDateSource2() {
        return DataSourceBuilder.create().build();
    }

    @Bean(name = "dynamicDataSource")
    public DynamicDataSource DataSource(@Qualifier("sqlserverDataSource") DataSource sqlserverDataSource,
                                        @Qualifier("mysqlDataSource") DataSource mysqlDataSource) {
        //配置多数据源
        Map<Object, Object> targetDataSource = new HashMap<>();
        targetDataSource.put(DataSourceEnum.SQLSERVER_DATASOURCE, sqlserverDataSource);
        targetDataSource.put(DataSourceEnum.MYSQL_DATASOURCE, mysqlDataSource);
        DynamicDataSource dataSource = new DynamicDataSource();
        //多数据源
        dataSource.setTargetDataSources(targetDataSource);
        //默认数据源
        dataSource.setDefaultTargetDataSource(mysqlDataSource);
        return dataSource;
    }
    @Bean(name = "SqlSessionFactory")
    public SqlSessionFactory test1SqlSessionFactory(@Qualifier("dynamicDataSource") DataSource dynamicDataSource)
            throws Exception {
        SqlSessionFactoryBean bean = new SqlSessionFactoryBean();
        bean.setDataSource(dynamicDataSource);
        return bean.getObject();
    }
}
```

由于mysql数据库中有一个t_blog表，故简单写下mapper和entity：

```java
package com.capol.multidatasource.mapper;

import com.capol.multidatasource.entity.Blog;
import org.apache.ibatis.annotations.Select;

/**
 * @author fuzihao
 * @date 2019/7/26 15:47
 */
public interface UserMapper {
    @Select("select pk_t_blog as id,f_author as author from t_blog where pk_t_blog=#{id}")
    Blog selectBlog(Integer id);
}
```

```java
package com.capol.multidatasource.entity;

/**
 * @author fuzihao
 * @date 2019/7/26 15:46
 */
public class Blog {
    private Integer id;
    private String author;

	//getter and setter
}

```

此时就也可以在测试类中进行测试了：

```java
package com.capol.multidatasource;

import com.capol.multidatasource.config.DataSourceContextHolder;
import com.capol.multidatasource.config.DataSourceEnum;
import com.capol.multidatasource.entity.Blog;
import com.capol.multidatasource.mapper.UserMapper;
import org.apache.ibatis.session.SqlSessionFactory;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;


@RunWith(SpringRunner.class)
@SpringBootTest
@MapperScan(basePackages = "com.capol.multidatasource.mapper")
public class MultidatasourceApplicationTests {

	@Autowired
	@Qualifier("SqlSessionFactory")
	private SqlSessionFactory sqlSessionFactory;
	@Autowired
	private UserMapper userMapper;
	@Test
	public void contextLoads() {
		Blog blog = userMapper.selectBlog(1);
		System.out.println(blog);
	}
}
```

此时输出实体类对象，若在config中设置默认为sqlServer数据库，或者在测试中插入

```java
DataSourceContextHolder.setDataBaseType(DataSourceEnum.SQLSERVER_DATASOURCE);
```

发现会报错找不到  t_blog 表，配置成功！

## 知识扩展

为了方便我们在Mapper中切换各数据库，可以通过注解和AOP的方式来实现数据源的切换

首先定义一个注解类：

```java
package com.capol.multidatasource.config;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 自定义数据源注解，默认为mysql数据源
 * @author fuzihao
 * @date 2019/7/26 16:26
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
public @interface DataSourceAnno {
    DataSourceEnum value() default DataSourceEnum.MYSQL_DATASOURCE;
}
```

其次，给注解切面

```java
package com.capol.multidatasource.config;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

/**
 * @author fuzihao
 * @date 2019/7/26 16:27
 */
@Aspect
@Component
public class DynamicDataSourceAspect {
    @Around("@annotation(dataSourceAnno)")
    public Object aroudOperDeal(ProceedingJoinPoint point,DataSourceAnno dataSourceAnno) throws Throwable {
        DataSourceContextHolder.setDataBaseType(dataSourceAnno.value());
        // 让目标方法继续进行
        Object retVal=point.proceed();
        DataSourceContextHolder.clearDataBaseType();
        return retVal;
    }
}
```

此时，我们就可以在mapper中，在相应数据库的curd操作上加上此注解，修改对应数据源啦！