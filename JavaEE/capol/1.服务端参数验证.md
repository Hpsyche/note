## 为什么要进行服务端参数验证

数据的校验是交互式网站一个不可或缺的功能，前端的js校验可以涵盖大部分的校验职责，如用户名唯一性，生日格式，邮箱格式校验等等常用的校验。但是为了避免用户绕过浏览器，使用http工具直接向后端请求一些违法数据，服务端的数据校验也是必要的，可以防止脏数据落到数据库中。在一般的应用，可以使用本文将要介绍的validation来对数据进行校验。

## 方法

服务端参数验证主要有JSR303/JSR-349，hibernate validation，spring validation三种方法。

* JSR303是一项标准,JSR-349是其的升级版本，添加了一些新特性，他们规定一些校验规范即校验注解，如@Null，@NotNull，@Pattern，他们位于javax.validation.constraints包下，只提供规范不提供实现。

* 而hibernate validation是对这个规范的实践（不要将hibernate和数据库orm框架联系在一起），他提供了相应的实现，并增加了一些其他校验注解，如@Email，@Length，@Range等等，他们位于org.hibernate.validator.constraints包下。

* 万能的spring为了给开发者提供便捷，对hibernate validation进行了二次封装，显示校验validated bean时，你可以使用spring validation或者hibernate validation，而spring validation另一个特性，便是其在springmvc模块中添加了自动校验，并将校验信息封装进了特定的类中。这无疑便捷了我们的web开发。

  本文主要介绍在springmvc中自动校验的机制。

## 过程

新建springboot工程，导入validator必要的依赖

```xml
<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-validator</artifactId>
</dependency>
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
</dependency>
```

准备一个pojo Foo

```java
package com.capol.validation_test.pojo;

import javax.validation.constraints.Min;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Pattern;

/**
 * @author fuzihao
 * @date 2019/7/11 10:21
 */
public class Foo {
    @NotBlank
    private String name;
    @Min(18)
    private Integer age;
    @Pattern(regexp = "^1(3|4|5|7|8)\\d{9}$",message = "手机号格式错误")
    @NotBlank(message = "手机号不能为空")
    private String phone;
    @NotBlank(message = "邮箱不能为空")
    private String email;
    //getter setter
}
```

使用一些比较常用的校验注解，还是比较浅显易懂的，字段上的注解名称即可推断出校验内容，每一个注解都包含了message字段，用于校验失败时作为提示信息，特殊的校验注解，如Pattern（正则校验），还可以自己添加正则表达式。

FooController

```java
package com.capol.validation_test.controller;

import com.capol.validation_test.pojo.Foo;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.validation.ValidationUtils;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.validation.ConstraintViolation;
import javax.validation.Validation;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;
import java.util.Set;

/**
 * @author fuzihao
 * @date 2019/7/11 10:23
 */
@RestController
public class FooController {
    @GetMapping("/foo")
    public String foo(@Validated Foo foo, BindingResult bindingResult){
        if(bindingResult.hasErrors()){
            for(FieldError fieldError:bindingResult.getFieldErrors()){
                System.out.println(fieldError.getField());
            }
            return "false";
        }
        return "success";
    }
}
```

访问 http://localhost:8080/foo?name=xujingfeng&email=000&age=19 可以得到如下的debug信息

![](D:\Work\TyporaNotes\note\JavaEE\capol\pict\1-1.png)

实验告诉我们，校验结果起了作用。并且，可以发现当发生多个错误，spring validation不会在第一个错误发生后立即停止，而是继续试错，告诉我们所有的错误。debug可以查看到更多丰富的错误信息，这些都是spring validation为我们提供的便捷特性，基本适用于大多数场景。

## AOP

很多时候，我们在多个controller中遇到了该 实体类，不想要每次都这样验证，此时可以通过AOP实现 实体的判断：

首先在pom.xml中引入aop依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

写一个参数验证的aop组件 

```java
package com.capol.validation_test.filter;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;
import org.springframework.validation.BindingResult;


/**
 * @author fuzihao
 * @date 2019/7/11 10:32
 */
@Component
@Aspect
public class RequestParamValidAspect {
    @Pointcut("execution(* com.capol.validation_test.controller.*.*(..))")
    public void controllerBefore(){

    }

    /**
    * 切面，参数验证失败直接返回“error”
    */
    @Around(value = "controllerBefore()")
    public Object before(ProceedingJoinPoint joinPoint) throws Throwable {
        Object[] args=joinPoint.getArgs();
        BindingResult bindingResult= (BindingResult) args[1];
        if(bindingResult.hasErrors()){
            return "error";
        }
        return joinPoint.proceed();
    }
}

```



## 附录

其他注解说明

```tex
JSR提供的校验注解：         
@Null   被注释的元素必须为 null    
@NotNull    被注释的元素必须不为 null    
@AssertTrue     被注释的元素必须为 true    
@AssertFalse    被注释的元素必须为 false    
@Min(value)     被注释的元素必须是一个数字，其值必须大于等于指定的最小值    
@Max(value)     被注释的元素必须是一个数字，其值必须小于等于指定的最大值    
@DecimalMin(value)  被注释的元素必须是一个数字，其值必须大于等于指定的最小值    
@DecimalMax(value)  被注释的元素必须是一个数字，其值必须小于等于指定的最大值    
@Size(max=, min=)   被注释的元素的大小必须在指定的范围内    
@Digits (integer, fraction)     被注释的元素必须是一个数字，其值必须在可接受的范围内    
@Past   被注释的元素必须是一个过去的日期    
@Future     被注释的元素必须是一个将来的日期    
@Pattern(regex=,flag=)  被注释的元素必须符合指定的正则表达式    


Hibernate Validator提供的校验注解：  
@NotBlank(message =)   验证字符串非null，且长度必须大于0    
@Email  被注释的元素必须是电子邮箱地址    
@Length(min=,max=)  被注释的字符串的大小必须在指定的范围内    
@NotEmpty   被注释的字符串的必须非空    
@Range(min=,max=,message=)  被注释的元素必须在合适的范围内
```



