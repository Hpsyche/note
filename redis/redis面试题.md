[TOC]

# Redis概述

## redis在JavaWeb主要应用场景

* 缓存常用的场景
* 需要高速读、写的场合，比如一些需要进行商品抢购和抢红包的场景。

### 缓存

当发送sql去数据库进行读取时，数据库就会去磁盘把对应的数据索引回来，而索引磁盘是一个相对缓慢的过程，如果把数据直接放在运行在内存的redis服务器上，就可以直接去redis中取数据了，大大减轻了数据库的压力。

一般而言，我们存储一些常用的数据，如用户登录的信息；一些主要的业务数据。

### 高速读写场合

当一个请求到达服务器，只是把业务数据放在Redis读写，而没有进行任何对数据库的操作。所以在一个请求操作完redis的读写后，就会去判断高速读写业务是否结果，若结束，再一次性批量地将redis中数据导入数据库中。

## NoSQL和传统数据库的异同

NoSQL的数据主要存储在内存中（部分可以持久化到磁盘），而数据库主要是磁盘。NoSQL的数据结构比较简单，但是其功能毕竟是有限的，不如数据库的SQL语句强大，支持更为复杂的计算。再次，NoSQL并不完全安全稳定，由于它基于内存，一旦停电或者机器故障数据就很容易丢失数据，其持久化能力也是有限的，而基于磁盘的数据库则不会出现这样的问题。最后，其数据完整性、事务能力、安全性、可靠性及可扩展性远不及数据库。

# Redis数据结构常用命令

## 链表

操作链表的命令可能是进程不安全的，因为当我们操作的时候，其他进程也可能在操作同一个链表，就会出现数据库安全一致性的问题，因此，redis提供了链表的**阻塞命令**，它们在运行的时候，会对链表加锁，以保证操作链表的命令安全性。

* blpop key timeout

  移出并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止

  (相比lpop，其是想线程安全的)

* brpop key timeout

  同上

* rpoplpush key src dest

  按从左到右的顺序，将一个链表的最后一个元素移除，并插入到目标链表的最左边

* brpoplpush key src dest timeout

  按从左到右的顺序，将一个链表的最后一个元素移除，并插入到目标链表的最左边，并可以设置超时时间

当使用这些命令时，redis就会对对应的链表加锁，加锁的结果就是其他的进程不能再读取或者写入该链表，只能等待命令结束。加锁的好处可以保证在多线程并发环境中数据的一致性。

# Redis数据结构的应用场景

## String

**应用场景：**String是最常用的一种数据类型，普通的key/ value 存储都可以归为此类.即可以完全实现目前 Memcached 的功能，并且效率更高。还可以享受Redis的定时持久化，操作日志及 Replication等功能。除了提供与 Memcached 一样的get、set、incr、decr 等操作外，Redis还提供了下面一些操作：

- 获取字符串长度
- 往字符串append内容
- 设置和获取字符串的某一段内容
- 设置及获取字符串的某一位（bit）
- 批量设置一系列字符串的内容

## Hash

**常用命令：**hget,hset,hgetall 等。

**应用场景：**在Memcached中，我们经常将一些结构化的信息打包成HashMap，在客户端序列化后存储为一个字符串的值，比如用户的昵称、年龄、性别、积分等，这时候在需要修改其中某一项时，通常需要将所有值取出反序列化后，修改某一项的值，再序列化存储回去。**这样不仅增大了开销，也不适用于一些可能并发操作的场合**（比如两个并发的操作都需要修改积分）。而Redis的Hash结构可以使你像在数据库中Update一个属性一样只修改某一项属性值。

我们简单举个实例来描述下Hash的应用场景，比如我们要存储一个用户信息对象数据，包含以下信息：

用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储，主要有以下2种存储方式：

![](D:\Work\TyporaNotes\note\redis\pict\redis之hash应用1.jpg)

第一种方式将用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，这种方式的缺点是，增加了序列化/反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。

![](D:\Work\TyporaNotes\note\redis\pict\redis之hash应用2.jpg)

第二种方法是这个用户信息对象有多少成员就存成多少个key-value对儿，用用户ID+对应属性的名称作为唯一标识来取得对应属性的值，虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。

那么Redis提供的Hash很好的解决了这个问题，Redis的Hash实际是内部存储的Value为一个HashMap，并提供了直接存取这个Map成员的接口，如下图：

![](D:\Work\TyporaNotes\note\redis\pict\redis之hash应用3.jpg)

**实现方式：**

Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap,当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。

## List

**常用命令：**lpush,rpush,lpop,rpop,lrange等。

**应用场景：**

Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现。

Lists 就是链表，相信略有数据结构知识的人都应该能理解其结构。使用Lists结构，我们可以轻松地实现最新消息排行等功能。Lists的另一个应用就是消息队列，
可以利用Lists的PUSH操作，将任务存在Lists中，然后工作线程再用POP操作将任务取出进行执行。Redis还提供了操作Lists中某一段的api，你可以直接查询，删除Lists中某一段的元素。

**实现方式：**

Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。

## Set

**常用命令：**

sadd,spop,smembers,sunion 等。

**应用场景：**

Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。

Sets 集合的概念就是一堆不重复值的组合。利用Redis提供的Sets数据结构，可以存储一些集合性的数据，比如在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。

**实现方式：**

set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。

## SortSet

**常用命令：**

zadd,zrange,zrem,zcard等

**使用场景：**

Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构，比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。

另外还可以用Sorted Sets来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。

**实现方式：**

Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。

# Redis为什么那么快

1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；

2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；

3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；

4、使用多路I/O复用模型，非阻塞IO；

5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

以上几点都比较好理解，下边我们针对多路 I/O 复用模型进行简单的探讨：

（1）多路 I/O 复用模型

多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。

**这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。**采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。

# Redis的一些常用技术

## 事务

在一个redis连接中，请注意要求是一个连接，所以更多的时候在使用spirng中会使用SessionCallback接口进行处理，在redis中使用事务会经过3个过程：

* 开启事务
* 命令进入队列
* 执行事务

| 命令                    | 说明                                                         | 备注                                    |
| ----------------------- | ------------------------------------------------------------ | --------------------------------------- |
| multi                   | 开启事务命令，之后的命令会进入队列，不会马上被执行           | 在事务生存期间，所有的redis命令都会入列 |
| watch key1 [key2 ...]   | 监听某些键，当被监听的键在事务执行前被修改，则事务会被回滚   | 使用乐观锁                              |
| unwatch key1 [key2 ...] | 取消监听某些键                                               |                                         |
| exec                    | 执行事务，如果被监听的键没有被修改，则采用执行命令，否则执行回滚命令 |                                         |
| discard                 | 回滚事务                                                     |                                         |

如果我们希望得到redis执行事务各个命令的结果，可以用这行代码：

```java
List list=ope.exec(); //执行事务
```

这段代码将返回之前在事务队列中所有命令的执行结果，并保存在一个List中，我们只要在SessionCallback接口的execute方法中将list返回，就可以在程序获得各个命令执行行的结果了。

## 探索Redis事务回滚

* 当redis事务遇到命令格式正确而数据类型不符合的情况，当exec命令执行后，出现问题的出现会显示错误，但是其之前和之后的命令都会被正确执行。
* 当redis事务遇到命令格式错误的，在命令入列的时候，redis就会检测到错误，其之前和之后的命令都会被事务回滚，即什么都不会发生。

## 使用watch命令监控事务

* 在multi命令前watch监听某些键值对
* multi开启事务，执行各命令，命令入队列
* 当exec时比较watch的键值对有没有发生变化
  * 若未发生变化，提交事务
  * 若发生了变化，回滚事务

以上，可以发现redis事务的exec是类似于多线程中的CAS的（可见“面试题.16.CAS"）；
注意：是类似，因为不完全是，原因是CAS原理会产生ABA问题，ABA问题如下：

| 时间顺序 | 线程1                       | 线程2        | 说明                              |
| -------- | --------------------------- | ------------ | --------------------------------- |
| T1       | X=A                         | --           | 线程1加入监控X                    |
| T2       | 复杂运算开始                | 修改X=B      | 线程2修改X，此刻变回B             |
| T3       |                             | 处理简单业务 | --                                |
| T4       |                             | 修改X=A      | 线程2修改X，此刻又变回A           |
| T5       |                             | 结束线程2    | 线程2结束                         |
| T6       | 检测X=A，验证通过，提交事务 | --           | CAS原理检测过，因为和旧值保持一致 |

* 现有一个用单向链表实现的堆栈，栈顶为A，这时线程T1已经知道A.next为B，然后希望用CAS将栈顶替换为B：head.compareAndSet(A,B);
* 在T1执行上面这条指令之前，线程T2介入，将A、B出栈，再pushD、C、A，对象B此时处于游离状态；
* 此时轮到线程T1执行CAS操作，检测发现栈顶仍为A，所以CAS成功，但此时的栈已然不是原来的栈了，故会出现不一致的问题。

各需要如下：各种乐观锁的实现中通常都会用版本戳version来对记录或对象标记，避免并发操作带来的问题，在Java中，AtomicStampedReference也实现了这个作用。

<font color=red>redis在执行事务过程中，不会产生ABA问题</font>。因为事务只要检查在T2时候被监控的key1被修改过，即会回滚！

## 流水线

使用流水线操作Redis命令

```java
Jedis jedis=pool.getResource();
long start=System.currentTimeMills();
//开启流水线
Pipeline pipeline=jedis.pipelined();
//测试数据
for(int i=0;i<100000;i++){
    int j=i+1;
    pipeline.set("key"+j,"value"+j);
    pipeline.get("key"+j)
}
//这里只执行同步，但不返回结果
List result=pipeline.syncAndReturnAll();
```

以上代码耗时550-700毫秒之间，也就是不到1秒时间完成了10万次读、写，性能远超数据库。

## 发布订阅

发布订阅模式首先需要消息源，也就是要有消息发布出来，比如例子中的银行通知，首先是银行的记账系统，收到了交易的命令，成功记账后，它就会把消息发送出来，这个时候，订阅者就可以收到这个消息进行处理了，类似于观察者模式。

## 超时命令

一般而言，和Java虚拟机一样，当内存不足时Redis会触发自动垃圾回收的机制，而程序员可以通过System.gc()去建议JVM回收内存垃圾，它将"可能"（Sytem.gc()并不一定会触发JVM去执行回收，它仅仅是建议JVM做回收）触发一次JVM的回收机制，但是这样可能导致JVM在回收大量的内存空间的同时，引发性能低下的情况。

### Redis的超时命令

| 命令                   | 说明                    | 备注 |
| ---------------------- | ----------------------- | ---- |
| persist key            | 持久化key，取消超时时间 |      |
| tll key                | 查看key的超时时间       |      |
| expire key seconds     | 设置超时时间戳          |      |
| expireat key timestamp | 设置超时时间戳          |      |
| ...                    | ...                     |      |

* *如果key超时了，Redis会回收key的存储空间吗*

  不会。redis的key超时不会被自动回收，它只会标识哪些键值对超时了，这样做的一个好处就是，如果一个很大的键值对超时，比如一个列表或者哈希结构，存在数以百万个元素，要对其回收需要很长时间，如果采用超时回收，则可能会产生停顿。

  Redis提供两种方式回收这些超时键值对，它们是定时回收和惰性回收。

  * 定时回收：在确定的某个时间触发一段代码，回收超时的键值对；
  * 惰性回收：当一个超时的键，被再次用get命令访问时，将触发Redis将其从内存中清空

## Redis为什么要单线程

因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。


# Redis配置

## Redis备份（持久化）

在Redis中存在两种备份方式：

* 快照，备份当前瞬间redis在内存中的数据记录；
* 只追加文件(AOF)，当redis执行写命令后，在一定的条件下将执行过的命令依次保存在redis文件中。

## Redis内存回收策略

* volatile-lru;

  最近最少的淘汰策略，会说那么超时的键值对，也就是它只淘汰超时的键值对

* allkeys-lru;

  最近最少的淘汰策略，不仅仅是超时的键值对

* volatile-random；

  随机淘汰，仅仅是超时的

* allkeys-random;

  随机淘汰，不仅仅是超时的

* volatile-ttl；

  删除存活时间最短的键值对策略

* noeviction（默认）

  根本就不淘汰任何键值对，当内存已满时，如果做读操作，例如get命令，它将正常操作，如果是写操作，它将返回错误。

## 复制

很多时候一台redis服务器是不够的，需要作灾备等。更多的时候我们更希望可以读写分离，<font color=red>读写分离的前提是读操作比写操作频繁得多</font>，我们可以从多态服务器中读取数据，从而消除了单态服务器的压力。

### 主从同步基础概念

* 在多台数据服务器，只有一个主服务器，而主服务器负责写入数据，不负责从外部程序读取数据。
* 存在多台从服务器，从服务器不写数据，只负责同步主服务器的数据，并让外部程序读取数据。
* 主服务器在写入数据后，即刻将写入数据的命令发送给服务器，从而使得主从数据同步。
* 应用程序可以读取选择一台从服务器的数据，分摊了读数据的压力。
* 当从服务器不能工作时，整个系统不受影响；当主服务器不能工作时，从从服务器选择一台来作为主服务器。

## 哨兵模式

主从切换技术的方法是：当主服务器宕机后，需要把一台从服务器切换为主服务器，使用哨兵模式。

原理：哨兵通过发送命令，等待redis服务器响应，从而监控运行的多个redis实例。哨兵以独立的进程监控3台服务器redis是否正常执行。

哨兵作用：

* 通过发送命令，让redis服务器返回检测其运行状态，包括主服务器和从服务器。
* 当哨兵检测到master宕机，会自动将slave切换master，然后通过发布订阅模式通知到其他的从服务器，修改配置文件，让它们切换主机。

故障切换的过程：

假设主服务器宕机，哨兵1先检测到这个结果，仅仅是哨兵1主观地认为主机已经不可用，这个现象被称为主观下线。当后面的哨兵监测也监测到了主服务器不可用，并且有了一定数量的哨兵认为主服务器不可用，那么哨兵之间就会形成一次投票，投票的结果由一个哨兵发起，进行failover操作，在failover操作的过程中<font color=red>切换成功后，就会通过发布订阅方式，让各个哨兵把自己监控的服务器实现切换主机，这个过程也被称为客观下线。</font>这样对于客户端而言，一切都是透明的。

