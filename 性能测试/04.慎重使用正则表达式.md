## 正则表达式引擎

正则表达式是一个用正则符号写出的公式，程序对这个公式进行语法分析，建立一个语法分析树，再根据这个分析树结合正则表达式的引擎生成执行程序（这个执行程序我们把它称作状态机，也叫状态自动机），用于字符匹配。

目前实现正则表达式引擎的方式有两种：DFA自动机（Deterministic Final Automata 确定有限状态自动机）和NFA自动机（Non deterministic Finite Automaton 非确定有限状态自动机）。

对比来看，**构造DFA自动机的代价远大于NFA自动机，但DFA自动机的执行效率高于NFA自动机**。

假设一个字符串的长度是n，如果**用DFA自动机作为正则表达式引擎，则匹配的时间复杂度为O(n)**；如果用NFA自动机作为正则表达式引擎，由于NFA自动机在匹配过程中存在大量的分支和回溯，假设**NFA的状态数为s，则该匹配算法的时间复杂度为O（ns）。**

### NFA自动机的回溯

DFA的匹配较为简单，直接每个字符进行匹配。

用NFA自动机实现的比较复杂的正则表达式，在匹配过程中经常会引起回溯问题。大量的回溯会长时间地占用CPU，从而带来系统性能开销。我来举例说明。

```tex
text=“abbc”
regex=“ab{1,3}c”
```

首先，读取正则表达式第一个匹配符a和字符串第一个字符a进行比较，a对a，匹配。

![](D:\Work\TyporaNotes\note\性能测试\pict\4-1.jpg)

然后，读取正则表达式第二个匹配符b{1,3} 和字符串的第二个字符b进行比较，匹配。**但因为 b{1,3} 表示1-3个b字符串，NFA自动机又具有贪婪特性，所以此时不会继续读取正则表达式的下一个匹配符，而是依旧使用 b{1,3} 和字符串的第三个字符b进行比较，结果还是匹配。**

![](D:\Work\TyporaNotes\note\性能测试\pict\4-2.jpg)

接着继续使用b{1,3} 和字符串的第四个字符c进行比较，**发现不匹配了，此时就会发生回溯，已经读取的字符串第四个字符c将被吐出去，指针回到第三个字符b的位置。**

![](D:\Work\TyporaNotes\note\性能测试\pict\4-3.jpg)

那么发生回溯以后，匹配过程怎么继续呢？程序会读取正则表达式的下一个匹配符c，和字符串中的第四个
字符c进行比较，结果匹配，结束。

![](D:\Work\TyporaNotes\note\性能测试\pict\4-4.jpg)

## 如何避免回溯问题？

首先了解下正则表达式的匹配模式。

### 贪婪模式

顾名思义，就是在数量匹配中，如果单独使用+、 ? 、* 或{min,max} 等量词，正则表达式会匹配尽可能多的内容。例如上面的例子

### 懒惰模式

在该模式下，正则表达式会尽可能少地重复匹配字符。如果匹配成功，它会继续匹配剩余的字符串。

例如，**<font color=red>在上面例子的字符后面加一个“？”，就可以开启懒惰模式。</font>**

text=“abc”
regex=“ab{1,3}?c”

匹配结果是“abc”，**该模式下NFA自动机首先选择最小的匹配范围**，即匹配1个b字符，因此就避免了回溯问题。

### 独占模式

同贪婪模式一样，独占模式一样会最大限度地匹配更多内容；不同的是，在独占模式下，匹配失败就会结束匹配，不会发生回溯问题。

还是上边的例子，**<font color=red>在字符后面加一个“+”，就可以开启独占模式。</font>**

text=“abbc”
regex=“ab{1,3}+c”

结果是不匹配，结束匹配，不会发生回溯问题。讲到这里，你应该非常清楚了，**避免回溯的方法就是：使用懒惰模式和独占模式。**

## 正则表达式的优化

### 少用贪婪模式，多用独占模式

贪婪模式会引起回溯问题，我们可以使用独占模式来避免回溯。

### 减少分支选择

分支选择类型“(X|Y|Z)”的正则表达式会降低性能，我们在开发的时候要尽量减少使用。如果一定要用，我们可以通过以下几种方式来优化：

* 首先，我们需要考虑选择的顺序，**将比较常用的选择项放在前面**，使它们可以较快地被匹配；
* 其次，我们可以尝试提取共用模式，例如，**将“(abcd|abef)”替换为“ab(cd|ef)”**，后者匹配速度较快，因为NFA自动机会尝试匹配ab，如果没有找到，就不会再尝试任何选项；
* 最后，**如果是简单的分支选择类型，我们可以用三次index代替“(X|Y|Z)”**，如果测试的话，你就会发现三次index的效率要比“(X|Y|Z)”高出一些。

### 减少捕获嵌套

捕获组是指把正则表达式中，子表达式匹配的内容保存到以数字编号或显式命名的数组中，方便后面引用。一般一个()就是一个捕获组，捕获组可以进行嵌套。

**非捕获组则是指参与匹配却不进行分组编号的捕获组，其表达式一般由（?:exp）组成。**

在正则表达式中，每个捕获组都有一个编号，编号0代表整个匹配到的内容。我们可以看下面的例子：

```java
public static void main( String[] args )
    {
        String text = "<input high=\"20\" weight=\"70\">test</input>";
        String reg="(<input.*?>)(.*?)(</input>)";
        Pattern p = Pattern.compile(reg);
        Matcher m = p.matcher(text);
        while(m.find()) {
            System.out.println(m.group(0));//整个匹配到的内容
            System.out.println(m.group(1));//(<input.*?>)
            System.out.println(m.group(2));//(.*?)
            System.out.println(m.group(3));//(</input>)
    }
}
```

运行结果：

```java
<input high=\"20\" weight=\"70\">test</input>
<input high=\"20\" weight=\"70\">
test
</input>
```

**如果你并不需要获取某一个分组内的文本，那么就使用非捕获分组。例如，使用“(?:X)”代替“(X)”，**我们再看下面的例子：

```java
public static void main( String[] args )
    {
        String text = "<input high=\"20\" weight=\"70\">test</input>";
        String reg="(?:<input.*?>)(.*?)(?:</input>)";
        Pattern p = Pattern.compile(reg);
        Matcher m = p.matcher(text);
        while(m.find()) {
            System.out.println(m.group(0));//整个匹配到的内容
            System.out.println(m.group(1));//(.*?)
    }
}
```

运行结果：

```java
<input high=\"20\" weight=\"70\">test</input>
test
```

综上可知：减少不需要获取的分组，可以提高正则表达式的性能。

