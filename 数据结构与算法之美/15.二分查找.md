## O(logn)惊人的查找速度

因为logn是一个非常“恐怖”的数量级，即便n非常非常大，对应的logn也很小。比如n等于2的32次方，这个数很大了吧？大约是42亿。也就是说，如果我们在42亿个数据中用二分查找一个数据，最多需要比较32次。

我们前面讲过，用大O标记法表示时间复杂度的时候，会省略掉常数、系数和低阶。对于常量级时间复杂度的算法来说，O(1)有可能表示的是一个非常大的常量值，比如O(1000)、O(10000)。所以，常量级时间复杂度的算法有时候可能还没有O(logn)的算法执行效率高。

## 二分查找的递归与非递归实现

最简单的二分查找算法。

```java
public int bsearch(int[] a, int n, int value) {
     int low = 0;
     int high = n - 1;
     while (low <= high) {
 		int mid = (low + high) / 2;
		if (a[mid] == value) {
 			return mid;
 		} else if (a[mid] < value) {
 			low = mid + 1;
 		} else {
 			high = mid - 1;
 		}
 	}
 	return -1;
}
```

强调一下容易出错的3个地方。

* 循环退出条件	

  注意是low<=high，而不是low

* mid的取值

  实际上，mid=(low+high)/2这种写法是有问题的。因为如果low和high比较大的话，两者之和就有可能会溢出。**改进的方法是将mid的计算方式写成low+(highlow)/2。**更进一步，如果要将性能优化到极致的话，我们可以将这里的除以2操作转化成位运算**low+((high-low)>>1)**。因为相比除法运算来说，计算机处理位运算要快得多。

* low和high的更新

  low=mid+1，high=mid-1。注意这里的+1和-1，如果直接写成low=mid或者high=mid，就可能会发生死循环。比如，当high=3，low=3时，如果a[3]不等于value，就会导致一直循环不退出。

## 二分查找应用场景的局限性

* 首先，二分查找依赖的是顺序表结构，简单点说就是数组。
* 其次，二分查找针对的是有序数据。
* 再次，数据量太小不适合二分查找。

## 解答

* 如何在1000万个整数中快速查找某个整数？

  我们的内存限制是100MB，每个数据大小是8字节，最简单的办法就是将数据存储在数组中，内存占用差不多是80MB，符合内存的限制。借助今天讲的内容，我们可以**先对这1000万数据从小到大排序，然后再利用二分查找算法，就可以快速地查找想要的数据了。**

  你可能会觉得，用散列表和二叉树这些支持快速查找的动态数据结构也可以解决这个问题。实际上是不行的。虽然大部分情况下，用二分查找可以解决的问题，用散列表、二叉树都可以解决。但是，我们后面会讲，**不管是散列表还是二叉树，都会需要比较多的额外的内存空间。如果用散列表或者二叉树来存储这1000万的数据，用100MB的内存肯定是存不下的。而二分查找底层依赖的是数组，除了数据本身之外，不需要额外存储其他信息，是最省内存空间的存储方式，所以刚好能在限定的内存大小下解决这个问题。**

## 二分查找的变体

### 变体一：查找第一个值等于给定值的元素

比如下面这样一个有序数组，其中，a[5]，a[6]，a[7]的值都等于8，是重复的数据。我们希望查找第一个等于8的数据，也就是下标是5的。

![](D:\Work\TyporaNotes\note\数据结构与算法之美\pict\15-1.PNG)

如果我们用上一节课讲的二分查找的代码实现，首先拿8与区间的中间值a[4]比较，8比6大，于是在下标5到9之间继续查找。下标5和9的中间位置是下标7，a[7]正好等于8，所以代码就返回了。

尽管a[7]也等于8，但它并不是我们想要找的第一个等于8的元素，因为第一个值等于8的元素是数组下标为5的元素。我们上一节讲的二分查找代码就无法处理这种情况了。所以，针对这个变形问题，我们可以稍微改造一下上一节的代码。

```java
public int bsearch(int[] a, int n, int value) {
 	int low = 0;
 	int high = n - 1;
 	while (low <= high) {
 		int mid = low + ((high - low) >> 1);
 		if (a[mid] > value) {
 			high = mid - 1;
 		} else if (a[mid] < value) {
 			low = mid + 1;
 		} else {
 			if ((mid == 0) || (a[mid - 1] != value)) return mid;
 				else high = mid - 1;
 			}
 		}
 	return -1;
}
```

a[mid]跟要查找的value的大小关系有三种情况：大于、小于、等于。对于a[mid]>value的情况，我们需要更新high= mid-1；对于a[mid]<value的情况，我们需要更新low=mid+1。这两点都很好理解。那当a[mid]=value的时候应该如何处理呢？

如果我们查找的是任意一个值等于给定值的元素，当a[mid]等于要查找的值时，a[mid]就是我们要找的元素。但是，如果我们求解的是第一个值等于给定值的元素，当a[mid]等于要查找的值时，我们就需要确认一下这个a[mid]是不是第一个值等于给定值的元素。

我们重点看第11行代码。如果mid等于0，那这个元素已经是数组的第一个元素，那它肯定是我们要找的；如果mid不等于0，但a[mid]的前一个元素a[mid-1]不等于value，那也说明a[mid]就是我们要找的第一个值等于给定值的元素。

**如果经过检查之后发现a[mid]前面的一个元素a[mid-1]也等于value，那说明此时的a[mid]肯定不是我们要查找的第一个值等于给定值的元素。那我们就更新high=mid-1，因为要找的元素肯定出现在[low, mid-1]之间。**

### 变体二：查找最后一个值等于给定值的元素

```java
public int bsearch(int[] a, int n, int value) {
 	int low = 0;
 	int high = n - 1;
 	while (low <= high) {
 		int mid = low + ((high - low) >> 1);
 		if (a[mid] > value) {
 			high = mid - 1;
 		} else if (a[mid] < value) {
 			low = mid + 1;
 		} else {
 			if ((mid == n - 1) || (a[mid + 1] != value)) return mid;
 		else low = mid + 1;
 		}
 	}
 	return -1;
}
```

我们还是重点看第11行代码。如果a[mid]这个元素已经是数组中的最后一个元素了，那它肯定是我们要找的；如果a[mid]的后一个元素a[mid+1]不等于value，那也说明a[mid]就是我们要找的最后一个值等于给定值的元素。

如果我们经过检查之后，发现a[mid]后面的一个元素a[mid+1]也等于value，那说明当前的这个a[mid]并不是最后一个值等于给定值的元素。我们就更新low=mid+1，因为要找的元素肯定出现在[mid+1, high]之间。

### 变体三：查找第一个大于等于给定值的元素

```java
public int bsearch(int[] a, int n, int value) {
 	int low = 0;
 	int high = n - 1;
 	while (low <= high) {
 		int mid = low + ((high - low) >> 1);
 	if (a[mid] >= value) {
 		if ((mid == 0) || (a[mid - 1] < value)) return mid;
 		else high = mid - 1;
 	} else {
 		low = mid + 1;
 		}
 	}
 	return -1;
}
```

注意其中的：mid==0

如果a[mid]小于要查找的值value，那要查找的值肯定在[mid+1, high]之间，所以，我们更新low=mid+1。

对于a[mid]大于等于给定值value的情况，我们要先看下这个a[mid]是不是我们要找的第一个值大于等于给定值的元素。**如果a[mid]前面已经没有元素，或者前面一个元素小于要查找的值value，那a[mid]就是我们要找的元素。**这段逻辑对应的代码是第7行。

如果a[mid-1]也大于等于要查找的值value，那说明要查找的元素在[low, mid-1]之间，所以，我们将high更新为mid-1。

### 变体四：查找最后一个小于等于给定值的元素

```java
public int bsearch7(int[] a, int n, int value) {
 	int low = 0;
 	int high = n - 1;
 	while (low <= high) {
 		int mid = low + ((high - low) >> 1);
 		if (a[mid] > value) {
 			high = mid - 1;
 		} else {
 			if ((mid == n - 1) || (a[mid + 1] > value)) return mid;
 			else low = mid + 1;
 		}
 	}
 	return -1;
}
```

注意其中的(mid == n - 1)

## 解答

* 如何快速定位出一个IP地址的归属地？

* 当我们想要查询202.102.133.13这个IP地址的归属地时，我们就在地址库中搜索，发现这个IP地址落在[202.102.133.0, 202.102.133.255]这个地址范围内，那我们就可以将这个IP地址范围对应的归属地“山东东营市”显示给用户了。
  [202.102.133.0, 202.102.133.255] 山东东营市
  [202.102.135.0, 202.102.136.255] 山东烟台
  [202.102.156.34, 202.102.157.255] 山东青岛
  [202.102.48.0, 202.102.48.255] 江苏宿迁
  [202.102.49.15, 202.102.51.251] 江苏泰州
  [202.102.56.0, 202.102.56.255] 江苏连云港
  现在我的问题是，在庞大的地址库中逐一比对IP地址所在的区间，是非常耗时的。假设我们有12万条这样的IP区间与归属地的对应关系，如何快速定位出一个IP地址的归属地呢？

  

  如果IP区间与归属地的对应关系不经常更新，我们可以先预处理这12万条数据，让其按照起始IP从小到大排序。如何来排序呢？我们知道，IP地址可以转化为32位的整型数。所以，我们可以将起始地址，按照对应的整型值的大小关系，从小到大进行排序。

  这个问题就可以转化为我刚讲的第四种变形问题“在有序数组中，查找最后一个小于等于某个给定值的元素”了。

  **当我们要查询某个IP归属地时，我们可以先通过二分查找，找到最后一个起始IP小于等于这个IP的IP区间，然后，检查这个IP是否在这个IP区间内，如果在，我们就取出对应的归属地显示；如果不在，就返回未查找到。**



* 循环有序数组查找

  - 题目：循环有序数组就是类似于56781234这样的数组。用logn复杂度查找一个元素，并返回其下标；如果不存在则返回-1.
  - 思路：有序数组容易想到二分查找。但是需要加一些细节判断。

  1. 第一种情况：mid值落在前半部分有序数组中，那么继续判断要查找的n是否落在start和mid中间有序数组部分：是，那么end=mid-1;否则start=mid+1,向后半部分区域查找
  2. 第二种情况：mid值落在后半部分有序数组，通过a[mid]>a[start]可以判断，继续判断n是否落在mid和end之间：是，那么start=mid+1,否则end=mid-1,向前寻找。

  - 要注意的是除了要判断a[mid]是否等于n之外，还要判断a[start]和a[end]。

    ```java
    public static int binarySearch(int a[],int n) {
        if(a==null||a.length==0)
            return -1;
        int start=0,end=a.length-1;
        int mid=(start+end)/2;
        while(start<=end) {
            if(a[start]==n)
                return start;
            if(a[end]==n)
                return end;
            if(a[mid]==n)
                return mid;
            mid=(start+end)/2;
            if(a[start]<a[mid]) {
                if(a[start]<n&&a[mid]>n)
                    end=mid-1;
                else
                    start=mid+1;
            }else {
                if(a[mid]<n&&n<a[end])
                    start=mid+1;
                else
                    end=mid-1;
            }
    
        }
        return -1;
    }
    ```

    

