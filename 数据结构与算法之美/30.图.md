## 邻接矩阵存储方法

图最直观的一种存储方法就是，邻接矩阵（Adjacency Matrix）。

![](D:\Work\TyporaNotes\note\数据结构与算法之美\pict\30-1.png)

用邻接矩阵来表示一个图，**虽然简单、直观，但是比较浪费存储空间。为什么这么说呢？**

**对于无向图来说**，如果A[i][j]等于1，那A[j][i]也肯定等于1。实际上，我们只需要存储一个就可以了。也就是说，无向图的二维数组中，如果我们将其用对角线划分为上下两部分，那我们只需要利用上面或者下面这样一半的空间就足够了，另外**一半白白浪费掉了。**

还有，如果我们存储的是稀疏图（Sparse Matrix），也就是说，顶点很多，但每个顶点的边并不多，那邻接矩阵的存储方法就更加浪费空间了。**比如微信有好几亿的用户，对应到图上就是好几亿的顶点。但是每个用户的好友并不会很多，一般也就三五百个而已。如果我们用邻接矩阵来存储，那绝大部分的存储空间都被浪费了。**

但这也并不是说，邻接矩阵的存储方法就完全没有优点。

* 首先，邻接矩阵的存储方式简单、直接，因为基于数组，所以在获取两个顶点的关系时，就非常高效。
* 其次，用邻接矩阵存储图的另外一个好处是方便计算。这是因为，用邻接矩阵的方式存储图，可以将很多图的运算转换成矩阵之间的运算。比如求解最短路径问题时会提到一个Floyd-Warshall算法，就是利用矩阵循环相乘若干次得到结果。

## 邻接表存储方法

另外一种图的存储方法，邻接表（Adjacency List）。

![](D:\Work\TyporaNotes\note\数据结构与算法之美\pict\30-2.png)

就像图中的例子，如果我们要确定，是否存在一条从顶点2到顶点4的边，那我们就要遍历顶点2对应的那条链表，看链表中是否存在顶点4。而且，我们前面也讲过，链表的存储方式对缓存不友好。所以，比起邻接矩阵的存储方式，在邻接表中查询两个顶点之间的关系就没那么高效了。

在散列表那几节里，我讲到，在基于链表法解决冲突的散列表中，**如果链过长，为了提高查找效率，我们可以将链表换成其他更加高效的数据结构，比如平衡二叉查找树等。**我们刚刚也讲到，邻接表长得很像散列。所以，我们也可以将邻接表同散列表一样进行“改进升级”。

我们可以将邻接表中的链表改成平衡二叉查找树。实际开发中，我们可以选择用红黑树。这样，我们就可以更加快速地查找两个顶点之间是否存在边了。当然，**这里的二叉查找树可以换成其他动态数据结构，比如跳表、散列表等。除此之外，我们还可以将链表改成有序动态数组，可以通过二分查找的方法来快速定位两
个顶点之间否是存在边。**

## 问答

* 如何存储微博、微信等社交网络中的好友关系？

  数据结构是为算法服务的，所以具体选择哪种存储方法，与期望支持的操作有关系。针对微博用户关系，假设我们需要支持下面这样几个操作：

  * 判断用户A是否关注了用户B；
  * 判断用户A是否是用户B的粉丝；
  * 用户A关注用户B；
  * 用户A取消关注用户B；
  * 根据用户名称的首字母排序，分页获取用户的粉丝列表；
  * 根据用户名称的首字母排序，分页获取用户的关注列表。

  关于如何存储一个图，前面我们讲到两种主要的存储方法，邻接矩阵和邻接表。因为社交网络是一张稀疏图，使用邻接矩阵存储比较浪费存储空间。所以，这里我们采用邻接表来存储。

  不过，用一个邻接表来存储这种有向图是不够的。我们去查找某个用户关注了哪些用户非常容易，但是如果要想知道某个用户都被哪些用户关注了，也就是用户的粉丝列表，是非常困难的。

  基于此，我们需要一个逆邻接表。邻接表中存储了用户的关注关系，**逆邻接表中存储的是用户的被关注关系。对应到图上，邻接表中，每个顶点的链表中，存储的就是这个顶点指向的顶点，逆邻接表中，每个顶点的链表中，存储的是指向这个顶点的顶点。**如果要查找某个用户关注了哪些用户，我们可以在邻接表中查找；如果要查找某个用户被哪些用户关注了，我们从逆邻接表中查找。

  ![](D:\Work\TyporaNotes\note\数据结构与算法之美\pict\30-3.png)

  基础的邻接表不适合快速判断两个用户之间是否是关注与被关注的关系，所以我们选择改进版本，将邻接表中的链表改为支持快速查找的动态数据结构。选择哪种动态数据结构呢？红黑树、跳表、有序动态数组还是散列表呢？

  因为**我们需要按照用户名称的首字母排序，分页来获取用户的粉丝列表或者关注列表，用跳表这种结构再合适不过了。这是因为，跳表插入、删除、查找都非常高效，时间复杂度是O(logn)，空间复杂度上稍高，是O(n)。最重要的一点，跳表中存储的数据本来就是有序的了，分页获取粉丝列表或关注列表，就非常高效。**

  如果对于小规模的数据，比如社交网络中只有几万、几十万个用户，我们可以将整个社交关系存储在内存中，上面的解决思路是没有问题的。但是如果像微博那样有上亿的用户，数据规模太大，我们就无法全部存储在内存中了。这个时候该怎么办呢？

  我们可以通过哈希算法等数据分片方式，将邻接表存储在不同的机器上。你可以看下面这幅图，我们在机器1上存储顶点1，2，3的邻接表，在机器2上，存储顶点4，5的邻接表。逆邻接表的处理方式也一样。当要查询顶点与顶点关系的时候，我们就利用同样的哈希算法，先定位顶点所在的机器，然后再在相应的机器上查找。

  ![](D:\Work\TyporaNotes\note\数据结构与算法之美\pict\30-4.png)

  除此之外，我们还有另外一种解决思路，就是利用外部存储（比如硬盘），因为外部存储的存储空间要比内存会宽裕很多。数据库是我们经常用来持久化存储关系数据的，所以我这里介绍一种数据库的存储方式。

  我用下面这张表来存储这样一个图。为了高效地支持前面定义的操作，我们可以在表上建立多个索引，比如第一列、第二列，给这两列都建立索引。

  ![](D:\Work\TyporaNotes\note\数据结构与算法之美\pict\30-5.png)

## 深度和广度优先搜索

首先定义图

```java
public class Graph { // 无向图
     private int v; // 顶点的个数
     private LinkedList<Integer> adj[]; // 邻接表
     public Graph(int v) {
         this.v = v;
         adj = new LinkedList[v];
         for (int i=0; i<v; ++i) {
         	adj[i] = new LinkedList<>();
         }
     }
     public void addEdge(int s, int t) { // 无向图一条边存两次
         adj[s].add(t);
         adj[t].add(s);
     }
}
```

### 广度优先搜索

![](D:\Work\TyporaNotes\note\数据结构与算法之美\pict\30-6.png)

这里面，bfs()函数就是基于之前定义的，图的广度优先搜索的代码实现。其中s表示起始顶点，t表示终止顶点。我们搜索一条从s到t的路径。实际上，这样求得的路径就是从s到t的最短路径。

```java
public void bfs(int s, int t) {
     if (s == t) return;
     boolean[] visited = new boolean[v];
     visited[s]=true;
     Queue<Integer> queue = new LinkedList<>();
     queue.add(s);
     int[] prev = new int[v];
     for (int i = 0; i < v; ++i) {
     	prev[i] = -1;
     }
     while (queue.size() != 0) {
         int w = queue.poll();
         for (int i = 0; i < adj[w].size(); ++i) {
             int q = adj[w].get(i);
             if (!visited[q]) {
                 prev[q] = w;
                 if (q == t) {
                     print(prev, s, t);
                     return;
             	}
                 visited[q] = true;
                 queue.add(q);
             }
         }
     }
}
private void print(int[] prev, int s, int t) { // 递归打印s->t的路径
     if (prev[t] != -1 && t != s) {
     	print(prev, s, prev[t]);
     }
     System.out.print(t + " ");
}
```

理解这三个变量：

* **visited是用来记录已经被访问的顶点，用来避免顶点被重复访问。**如果顶点q被访问，那相应的visited[q]会被设置为true。
* **queue是一个队列，用来存储已经被访问、但相连的顶点还没有被访问的顶点。**因为广度优先搜索是逐层访问的，也就是说，我们只有把第k层的顶点都访问完成之后，才能访问第k+1层的顶点。当我们访问到第k层的顶点的时候，我们需要把第k层的顶点记录下来，稍后才能通过第k层的顶点来找第k+1层的顶点。所以，我们用这个队列来实现记录的功能。
* **prev用来记录搜索路径**。当我们从顶点s开始，广度优先搜索到顶点t后，prev数组中存储的就是搜索的路径。不过，这个路径是反向存储的。prev[w]存储的是，顶点w是从哪个前驱顶点遍历过来的。**比如，我们通过顶点2的邻接表访问到顶点3，那prev[3]就等于2。**为了正向打印出路径，我们需要递归地来打印，你可以看下print()函数的实现方式。

#### 广度优先搜索的分解图

![](D:\Work\TyporaNotes\note\数据结构与算法之美\pict\30-7.png)

![](D:\Work\TyporaNotes\note\数据结构与算法之美\pict\30-8.png)

![](D:\Work\TyporaNotes\note\数据结构与算法之美\pict\30-9.png)

最坏情况下，终止顶点t离起始顶点s很远，需要遍历完整个图才能找到。这个时候，每个顶点都要进出一遍队列，每个边也都会被访问一次，所以，**广度优先搜索\的时间复杂度是O(V+E)，其中，V表示顶点的个数，E表示边的个数。**当然，对于一个连通图来说，也就是说一个图中的所有顶点都是连通的，E肯定要大于等于V-1，所以，广度优先搜索的时间复杂度也可以简写为O(E)。

广度优先搜索的空间消耗主要在几个辅助变量visited数组、queue队列、prev数组上。这三个存储空间的大小都不会超过顶点的个数，所以**空间复杂度是O(V)。**

## 深度优先搜索

我用深度递归算法，把整个搜索的路径标记出来了。这里面实线箭头表示遍历，虚线箭头表示回退。从图中我们可以看出，深度优先搜索找出来的路径，并不是顶点s到顶点t的最短路径。

![](D:\Work\TyporaNotes\note\数据结构与算法之美\pict\30-10.png)

深度优先搜索代码实现里，有个比较特殊的变量found，它的作用是，当我们已经找到终止顶点t之后，我们就不再递归地继续查找了。

```java
boolean found = false; // 全局变量或者类成员变量
public void dfs(int s, int t) {
     found = false;
     boolean[] visited = new boolean[v];
     int[] prev = new int[v];
     for (int i = 0; i < v; ++i) {
     	prev[i] = -1;
     }
     recurDfs(s, t, visited, prev);
     print(prev, s, t);
}
private void recurDfs(int w, int t, boolean[] visited, int[] prev) {
     if (found == true) return;
     visited[w] = true;
     if (w == t) {
         found = true;
         return;
     }
     for (int i = 0; i < adj[w].size(); ++i) {
         int q = adj[w].get(i);
         if (!visited[q]) {
             prev[q] = w;
             recurDfs(q, t, visited, prev);
         }
     }
 }
```

从我前面画的图可以看出，每条边最多会被访问两次，一次是遍历，一次是回退。所以，**图上的深度优先搜索算法的时间复杂度是O(E)，E表示边的个数。**

深度优先搜索算法的消耗内存主要是visited、prev数组和递归调用栈。visited、prev数组的大小跟顶点的个数V成正比，递归调用栈的最大深度不会超过顶点的个数，所以**总的空间复杂度就是O(V)。**

