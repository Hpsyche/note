我们知道事务有 4 个隔离级别，以及可能存在的三种异常问题，如下图所示：

![](D:\Work\TyporaNotes\note\Sql\Mysql\SQL必知必会\pict\31-1.jpg)

**在 MySQL 中，默认的隔离级别是可重复读**，可以解决脏读和不可重复读的问题，但不能解决幻读问题。**如果我们想要解决幻读问题，就需要采用串行化的方式，也就是将隔离级别提升到最高，但这样一来就会大幅降低数据库的事务并发能力。**

在 MySQL 中，默认的隔离级别是可重复读，可以解决脏读和不可重复读的问题，但不能解决幻读问题。如果我们想要解决幻读问题，就需要采用串行化的方式，也就是将隔离级别提升到最高，但这样一来就会大幅降低数据库的事务并发能力。

![](D:\Work\TyporaNotes\note\Sql\Mysql\SQL必知必会\pict\31-2.jpg)

## MVCC 是什么，解决了什么问题

**MVCC 的英文全称是 Multiversion Concurrency Control，中文翻译过来就是多版本并发控制技术。**从名字中也能看出来，MVCC 是通过数据行的多个版本管理来实现数据库的并发控制，简单来说它的思想就是保存数据的历史版本。这样我们就可以**通过比较版本号决定数据是否显示出来（具体的规则后面会介绍到），读取数据的时候不需要加锁也可以保证事务的隔离效果。**

通过 MVCC 我们可以解决以下几个问题：

* 读写之间阻塞的问题，通过 MVCC 可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。
* 降低了死锁的概率。这是因为 MVCC 采用了乐观锁的方式，**读取数据时并不需要加锁，对于写操作，也只锁定必要的行。**
* 解决一致性读的问题。一致性读也被称为快照读，当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。

## 什么是快照读，什么是当前读

**快照读读取的是快照数据。**

**当前读就是读取最新数据，而不是历史版本的数据。**

上面讲 MVCC 的作用，你可能觉得有些抽象。我们用具体的例子体会一下。

比如我们有个账户金额表 user_balance，包括三个字段，分别是 username 用户名、balance 余额和 bankcard 卡号。

为了方便，我们假设 user_balance 表中只有用户 A 和 B 有余额，其他人的账户余额均为 0。下面我们考虑一个使用场景。

某时刻用户 A 和用户 B 之间进行转账，同时数据库管理员想要查询 user_balance 表中的总金额：

```sql
SELECT SUM(balance) FROM user_balance
```

你可以思考下，如果数据库不支持 MVCC 机制，而是采用自身的锁机制来实现的话，可能会出现怎样的情况呢？

情况 1：因为需要采用加行锁的方式，用户 A 给 B 转账时间等待很久，如下图所示。

![](D:\Work\TyporaNotes\note\Sql\Mysql\SQL必知必会\pict\31-3.jpg)

情况 2：当我们读取的时候用了加行锁，可能会出现死锁的情况，如下图所示。比如当我们读到 A 有 1000 元的时候，此时 B 开始执行给 A 转账：

```sql
UPDATE user_balance SET balance=balance-100 WHERE username ='B'
```

执行完之后马上执行下一步：

```sql
UPDATE user_balance SET balance=balance+100 WHERE username ='A'
```

我们会发现此时 A 被锁住了，而管理员事务还需要对 B 进行访问，但 B 被用户事务锁住了，此时就发生了死锁。

![](D:\Work\TyporaNotes\note\Sql\Mysql\SQL必知必会\pict\31-4.jpg)

MVCC 可以解决读写互相阻塞的问题，这样提升了效率，同时因为采用了乐观锁的思想，降低了死锁的概率。

## InnoDB 中的 MVCC 是如何实现的？

在了解 InnoDB 中 MVCC 的实现方式之前，我们需要了解 InnoDB 是如何存储记录的多个版本的。这里的多版本对应的就是 MVCC 前两个字母的释义：**Multi Version**，我们需要了解和它相关的数据都有哪些，存储在哪里。这些**数据包括事务版本号、行记录中的隐藏列和 Undo Log。**

### 事务版本号

每开启一个事务，我们都会从数据库中获得一个事务 ID（也就是事务版本号），这个事务 ID 是自增长的，通过 ID 大小，我们就可以判断事务的时间顺序。

### 行记录的隐藏列

InnoDB 的叶子段存储了数据页，**数据页中保存了行记录，而在行记录中有一些重要的隐藏字段**，如下图所示：

* **db_row_id：隐藏的行 ID，用来生成默认聚集索引。如果我们创建数据表的时候没有指定聚集索引，这时 InnoDB 就会用这个隐藏 ID 来创建聚集索引。采用聚集索引的方式可以提升数据的查找效率。**
* **db_trx_id：操作这个数据的事务 ID，也就是最后一个对该数据进行插入或更新的事务 ID。**
* **db_roll_ptr：回滚指针，也就是指向这个记录的 Undo Log 信息。**

### Undo Log

InnoDB 将行记录快照保存在了 Undo Log 里，我们可以在回滚段中找到它们，如下图所示：

![](D:\Work\TyporaNotes\note\Sql\Mysql\SQL必知必会\pict\31-5.jpg)

从图中你能看到**回滚指针将数据行的所有快照记录都通过链表的结构串联了起来，每个快照的记录都保存了当时的 db_trx_id，也是那个时间点操作这个数据的事务 ID。这样如果我们想要找历史快照，就可以通过遍历回滚指针的方式进行查找。**

## Read View 是如何工作的

在 MVCC 机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些历史快照保存在 Undo Log 里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢？这时就需要用到 Read View 了，它帮我们解决了行的可见性问题。**Read View 保存了当前事务开启时所有活跃（还没有提交）的事务列表，换个角度你可以理解为 Read View 保存了不应该让这个事务看到的其他的事务 ID 列表。**

在 Read VIew 中有几个重要的属性：

* trx_ids，系统当前正在活跃的事务 ID 集合。
* low_limit_id，活跃的事务中最大的事务 ID。
* up_limit_id，活跃的事务中最小的事务 ID。
* creator_trx_id，创建这个 Read View 的事务 ID。

假设当前有事务 creator_trx_id 想要读取某个行记录，这个行记录的事务 ID 为 trx_id，那么会出现以下几种情况。

* 如果 trx_id < 活跃的最小事务 ID（up_limit_id），也就是说这个行记录在这些活跃的事务创建之前就已经提交了，那么这个行记录对该事务是可见的。
* 如果 trx_id > 活跃的最大事务 ID（low_limit_id），这说明该行记录在这些活跃的事务创建之后才创建，那么这个行记录对当前事务不可见。
* 如果 up_limit_id < trx_id < low_limit_id，说明该行记录所在的事务 trx_id 在目前 creator_trx_id 这个事务创建的时候，可能还处于活跃的状态，因此我们需要在 trx_ids 集合中进行遍历，如果 trx_id 存在于 trx_ids 集合中，证明这个事务 trx_id 还处于活跃状态，不可见。否则，如果 trx_id 不存在于 trx_ids 集合中，证明事务 trx_id 已经提交了，该行记录可见。

了解了这些概念之后，我们来看下当查询一条记录的时候，系统如何通过多版本并发控制技术找到它：.

* 首先获取事务自己的版本号，也就是事务 ID；
* 获取 Read View；
* 查询得到的数据，然后与 Read View 中的事务版本号进行比较；
* 如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；
* 最后返回符合规则的数据。

你能看到 InnoDB 中，**MVCC 是通过 Undo Log + Read View 进行数据读取，Undo Log 保存了历史快照，而 Read View 规则帮我们判断当前版本的数据是否可见。**

需要说明的是，**在隔离级别为读已提交（Read Commit）时，一个事务中的每一次 SELECT 查询都会获取一次 Read View。**如表所示：

![](D:\Work\TyporaNotes\note\Sql\Mysql\SQL必知必会\pict\31-6.jpg)

你能看到，在读已提交的隔离级别下，同样的查询语句都会重新获取一次 Read View，这时如果 Read View 不同，就可能产生不可重复读或者幻读的情况。

**当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次 SELECT 的时候会获取一次 Read View，而后面所有的 SELECT 都会复用这个 Read View**，如下表所示：

![](D:\Work\TyporaNotes\note\Sql\Mysql\SQL必知必会\pict\31-7.jpg)

## InnoDB 是如何解决幻读的

从以上看起来，MVCC也解决了幻读问题，那既然这样串行化读貌似就没啥意义了，带着疑问继续测试。

测试前数据：

![](D:\Work\TyporaNotes\note\Sql\Mysql\SQL必知必会\pict\31-9.jpg)

| 事物 1                        | 事物 2                                  |
| :---------------------------- | :-------------------------------------- |
| begin                         | begin                                   |
| select * from dept            |                                         |
| -                             | insert into dept(name) values("研发部") |
| -                             | commit                                  |
| update dept set name="财务部" |                                         |
| commit                        |                                         |

根据上面的结果我们期望的结果是这样的：

id  name
1   财务部
2   研发部

但是实际上我们的经过是：

![](D:\Work\TyporaNotes\note\Sql\Mysql\SQL必知必会\pict\31-10.jpg)

本来我们希望得到的结果只是第一条数据的部门改为财务，但是结果确实两条数据都被修改了。这种结果告诉我们其实在MySQL可重复读的隔离级别中并不是完全解决了幻读的问题，而是解决了读数据情况下的幻读问题。而对于修改的操作依旧存在幻读问题，就是说MVCC对于幻读的解决时不彻底的。

### Next-key+MVCC解决幻读

**在可重复读的情况下，InnoDB 可以通过 Next-Key 锁 +MVCC 来解决幻读问题。**

**在读已提交的情况下（每次查询获取一个Read View），即使采用了 MVCC 方式也会出现幻读。**如果我们同时开启事务 A 和事务 B，先在事务 A 中进行某个条件范围的查询，**读取的时候采用排它锁**，在事务 B 中增加一条符合该条件范围的数据，并进行提交，然后我们在事务 A 中再次查询该条件范围的数据，就会发现结果集中多出一个符合条件的数据，这样就出现了幻读。

![](D:\Work\TyporaNotes\note\Sql\Mysql\SQL必知必会\pict\31-8.jpg)

**出现幻读的原因是在读已提交的情况下，InnoDB 只采用记录锁（Record Locking）**。这里要介绍下 InnoDB 三种行锁的方式：

* 记录锁：针对单个行记录添加锁。
* 间隙锁（Gap Locking）：可以帮我们锁住一个范围（索引之间的空隙），但不包括记录本身。采用间隙锁的方式可以防止幻读情况的产生。
* **Next-Key 锁：帮我们锁住一个范围，同时锁定记录本身，相当于间隙锁 + 记录锁，可以解决幻读的问题。**

在隔离级别为可重复读时，InnoDB 会采用 Next-Key 锁的机制，帮我们解决幻读问题。

还是这个例子，我们能看到当我们想要插入球员艾利克斯·伦（身高 2.16 米）的时候，事务 B 会超时，无法插入该数据。这是因为采用了 Next-Key 锁，会将 height>2.08 的范围都进行锁定，就无法插入符合这个范围的数据了。然后事务 A 重新进行条件范围的查询，就不会出现幻读的情况。

![](D:\Work\TyporaNotes\note\Sql\Mysql\SQL必知必会\pict\31-11.jpg)

## 总结

MVCC 的核心就是 Undo Log+ Read View，“MV”就是通过 Undo Log 来保存数据的历史版本，实现多版本的管理，“CC”是通过 Read View 来实现管理，通过 Read View 原则来决定数据是否显示。同时针对不同的隔离级别，Read View 的生成策略不同，也就实现了不同的隔离级别。

**MVCC 是一种机制，MySQL、Oracle、SQL Server 和 PostgreSQL 的实现方式均有不同，我们在学习的时候，更主要的是要理解 MVCC 的设计思想。**

## 思考

* 为什么隔离级别为读未提交时，不适用于 MVCC 机制呢？

  因为隔离级别是读未提交，所以根本就不需要版本控制，直接读取最新的数据就好了。

* 读已提交和可重复读这两个隔离级别的 Read View 策略有何不同？

  读已提交每一次Select都会重新查询Read View，保证可以读到其它事务的提交。
  可重复读会复用第一次查询到的Read View,不会读到其它事务的提交，加上Next-Key锁的配合，从而避免幻读。

* 幻读的解决方案：

  很明显可重复读的隔离级别没有办法彻底的解决幻读的问题，如果我们的项目中需要解决幻读的话也有两个办法：

  - 使用串行化读的隔离级别
  - MVCC+next-key locks：next-key locks由record locks(索引加锁) 和 gap locks(间隙锁，每次锁住的不光是需要使用的数据，还会锁住这些数据附近的数据)

  实际上很多的项目中是不会使用到上面的两种方法的，串行化读的性能太差，而且其实幻读很多时候是我们完全可以接受的。