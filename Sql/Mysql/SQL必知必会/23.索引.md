## 索引是万能的吗？

首先我们需要了解什么是索引（Index）。数据库中的索引，就好比一本书的目录，它可以帮我们快速进行特定值的定位与查找，从而加快数据查询的效率。

索引就是帮助数据库管理系统高效获取数据的数据结构。

如果我们不使用索引，就必须从第 1 条记录开始扫描，直到把所有的数据表都扫描完，才能找到想要的数据。既然如此，如果我们想要快速查找数据，就只需要创建更多的索引就好了呢？

其实索引不是万能的，在有些情况下使用索引反而会让效率变低。

### 实验 1：数据行数少的情况下，索引效率如何

你能看到运行结果相同，但是创建了 name 字段索引的效率比没有创建索引时效率更低。在数据量不大的情况下，索引就发挥不出作用了。

### 实验 2：性别（男或女）字段真的不应该创建索引吗？

如果一个字段的取值少，比如性别这个字段，通常是不需要创建索引的。那么有没有特殊的情况呢？

下面我们来看一个例子，假设有一个**女儿国，人口总数为 100 万人，男性只有 10 个人，也就是占总人口的 10 万分之 1。**

女儿国的人口数据表 user_gender 。其中数据表中的 user_gender 字段取值为 0 或 1，0 代表女性，1 代表男性。

如果我们要筛选出这个国家中的男性，可以使用：

```sql
SELECT * FROM user_gender WHERE user_gender = 1
```

运行结果（10 条数据，运行时间 0.696s）。

你能看到在未创建索引的情况下，运行的效率并不高。如果我们针对 user_gender 字段创建索引呢？

```sql
SELECT * FROM user_gender WHERE user_gender = 1
```

同样是 10 条数据，运行结果相同，时间却缩短到了 0.052s，大幅提升了查询的效率。

其实通过这两个实验你也能看出来，索引的价值是帮你快速定位。如果想要定位的数据有很多，那么索引就失去了它的使用价值，比如通常情况下的性别字段。不过有时候，我们还要考虑这个字段中的数值分布的情况，在实验 2 中，性别字段的数值分布非常特殊，男性的比例非常少。

**我们不仅要看字段中的数值个数，还要根据数值的分布情况来考虑是否需要创建索引。**

## 索引的种类有哪些？

### 功能逻辑

从功能逻辑上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引和全文索引。

普通索引是基础的索引，没有任何约束，主要用于提高查询效率。唯一索引就是在普通索引的基础上增加了数据唯一性的约束，在一张数据表里可以有多个唯一索引。主键索引在唯一索引的基础上增加了不为空的约束，也就是 NOT NULL+UNIQUE，一张表里最多只有一个主键索引。全文索引用的不多，MySQL 自带的全文索引只支持英文。我们通常可以采用专门的全文搜索引擎，比如 ES(ElasticSearch) 和 Solr。

### 物理实现

按照物理实现方式，索引可以分为 2 种：聚集索引和非聚集索引。我们也把非聚集索引称为二级索引或者辅助索引。

#### 聚集索引

**聚集索引可以按照主键来排序存储数据，**这样在查找行的时候非常有效。举个例子，如果是一本汉语字典，我们想要查找“数”这个字，直接在书中找汉语拼音的位置即可，也就是拼音“shu”。这样**找到了索引的位置，在它后面就是我们想要找的数据行。**

#### 非聚集索引

**在数据库系统会有单独的存储空间存放非聚集索引，这些索引项是按照顺序存储的，但索引项指向的内容是随机存储的。也就是说系统会进行两次查找，第一次先找到索引，第二次找到索引对应的位置取出数据行。**非聚集索引不会把索引指向的内容像聚集索引一样直接放到索引的后面，而是维护单独的索引表（只维护索引，不维护索引指向的数据），为数据检索提供方便。我们还以汉语字典为例，如果想要查找“数”字，那么按照部首查找的方式，先找到“数”字的偏旁部首，然后这个目录会告诉我们“数”字存放到第多少页，我们再去指定的页码找这个字。

聚集索引指表中数据行按索引的排序方式进行存储，对查找行很有效。只有当表包含聚集索引时，表内的数据行才会按找索引列的值在磁盘上进行物理排序和存储。**每一个表只能有一个聚集索引，因为数据行本身只能按一个顺序存储。**

聚集索引与非聚集索引的原理不同，在使用上也有一些区别：

* 聚集索引的叶子节点存储的就是我们的数据记录，非聚集索引的叶子节点存储的是数据位置。非聚集索引不会影响数据表的物理存储顺序。
* **<font color=red>一个表只能有一个聚集索引，因为只能有一种排序存储的方式</font>，但可以有多个非聚集索引，也就是多个索引目录提供数据检索。**
* 使用聚集索引的时候，数据的查询效率高，但如果对数据进行插入，删除，更新等操作，效率会比非聚集索引低。

### 实验 3：使用聚集索引和非聚集索引的查询效率

有以下结论：

* 对 WHERE 子句的字段建立索引，可以大幅提升查询效率。
* 采用聚集索引进行数据查询，比使用非聚集索引的查询效率略高。如果查询次数比较多，还是尽量使用主键索引进行数据查询。

### 字段个数

除了业务逻辑和物理实现方式，索引还可以按照字段个数进行划分，分成单一索引和联合索引。

索引列为一列时为单一索引；多个列组合在一起创建的索引叫做联合索引。

创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (x, y, z) 和 (z, y, x) 在使用的时候效率可能会存在差别。

这里需要说明的是联合索引存在**最左匹配原则**，也就是按照最左优先的方式进行索引的匹配。比如刚才举例的 (x, y, z)，如果查询条件是 WHERE x=1 AND y=2 AND z=3，就可以匹配上联合索引；如果查询条件是 WHERE y=2，就无法匹配上联合索引。

### 实验 4：联合索引的最左原则

当我们使用了联合索引 (user_id, user_name) 的时候，在 WHERE 子句中对联合索引中的字段 user_id 和 user_name 进行条件查询，或者只对 user_id 进行查询，效率基本上是一样的。当我们对 user_name 进行条件查询时，效率就会降低很多，这是因为根据联合索引的最左原则，user_id 在 user_name 的左侧，如果没有使用 user_id，而是直接使用 user_name 进行条件查询，联合索引就会失效。

## 索引是否生效案例

### 案例1

在d001_index表中下创建索引（a，b，c，d），查看索引使用情况

* 查询条件为a :用到了索引a (长度为5)

```sql
explain  SELECT * from d001_index WHERE a = 1 ;
```

* 查询条件为b：未用到索引

```sql
explain  SELECT * from d001_index WHERE b = 1 ;
```

* 查询条件为 b 、 c ：未用到索引

```sql
explain  SELECT * from d001_index WHERE b = 1 and c = 2 ;
```

* 查询条件为 a 、 b：用到了联合索引 a 、b (长度为10)

```sql
explain  SELECT * from d001_index WHERE a = 1 and b = 2 ;
```

* 查询条件为 a、c ：用到了联合索引a (长度为5)

```sql
explain  SELECT * from d001_index WHERE a = 1 and c = 3 ;
```

* 查询条件为 a 、b、c、c：用到了联合索引a b c d (长度为20)

```sql
explain  SELECT * from d001_index WHERE a = 1 and b = 2 and c = 3  and d = 4 ;
```

* 查询条件为 a or b ：未用到索引

```sql
explain  SELECT * from d001_index WHERE a = 1 or b = 2;
```

​	（只有给a和b同时加上索引时，才会使用索引，type为index_merge,其实是将查询出的结果取并集。）

### 总结

1、 顾名思义是最左优先，以最左边的为起点任何连续的索引都能匹配上

2、多个单列索引在多条件查询时只会生效第一个索引！所以多条件联合查询时最好建联合索引。

**当创建(a,b,c)联合索引时，相当于创建了(a)单列索引，(a,b)联合索引以及(a,b,c)联合索引**

想要索引生效的话,只能使用 a和a,b和a,b,c三种组合；当然，我们上面测试过，**a,c组合也可以，但实际上只用到了a的索引，c并没有用到！**

3、具体 使用 a b c 的顺序无关，mysql会自动优化，但是我们建议按照索引的顺序进行查询，而且尽量将筛选力度大的放到前面，其实这种也不要一定是准确的，其实真正有影响的是是否用到了索引

### 案例2

* a > 3 使用了索引 a （长度为 5 ）

```sql
explain  SELECT * from d001_index WHERE a > 3  ;
```

* a = 1 and b > 1 ：使用了联合索引 a、b（长度为10）

```sql
explain SELECT * from d001_index WHERE a = 1 and  b > 1 ;
```

* a = 5 AND b > 6 AND c = 7 ：使用了联合索引 a、b（长度为10）

```sql
explain SELECT * from d001_index WHERE a = 5 AND b > 6 AND c = 7
```

#### 可以用到索引的情况

A>5
A=5 AND B>6
A=5 AND B=6 AND C=7

#### 不能用上索引

B>5 ——查询条件不包含组合索引首列字段
B=6 AND C=7 ——查询条件不包含组合索引首列字段

#### 用上部分组合索引

A>5 AND B=2 ——当范围查询使用第一列，查询条件仅仅能使用第一列 A
A=5 AND B>6 AND C=2 ——范围查询使用第二列，查询条件仅仅能使用前二列    A B

### 总结

即< 、>后面的字段 都不能用上索引，同时也要满足最左匹配原则

### 案例3

* order by b 未使用索引

```sql
explain  SELECT * from d001_index  order by b  limit  1;
```

#### 可以用到索引的情况

ORDER BY A ——首列排序

A=5 ORDER BY B——第一列过滤后第二列排序

ORDER BY A DESC, B DESC——注意，此时**两列以相同顺序排序**

A>5 ORDER BY A——数据检索和排序都在第一列

#### 不能用上索引

ORDER BY B ——排序在索引的第二列

A>5 ORDER BY B ——范围查询在第一列，排序在第二列

A IN(1,2) ORDER BY B ——理由同上

ORDER BY A ASC, B DESC ——注意，此时**两列以不同顺序排序**

