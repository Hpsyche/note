## 主键算法

### 自增主键

##### 优点:

1、数据存储空间小

2、查询效率高

##### 缺点:

1、如果数据量过大,会超出自增长的值范围

2、分布式存储的表操作,尤其是在合并的时候操作复杂

3、安全性低,因为是有规律的,如果恶意扒取用户信息会很容易,如果是单据编号使用,竞争对手会容易查询出货量。

### UUID主键

##### 优点:

1、出现重复的机会少

2、适合大量数据的插入和更新操作,尤其是在高并发和分布式环境下

3、安全性较高

##### 缺点:

1、存储空间大（16 byte）,因此它将会占用更多的磁盘空间, MySQL官方有明确的建议主键要尽量越短越好，36个字符长度的UUID不符合要求

2、**性能降低,对MySQL索引不利: 如果作为数据库主键，在InnoDB引擎下，UUID的无序性可能会引起数据位置频繁变动，严重影响性能。**

### 雪花算法Snowflake

基于数据库自增序列的实现。这种方式优缺点都非常明显，好处是简单易用，但是在扩展性和可靠性等方面存在局限性。

基于Twitter早期开源的Snowfake的实现，以及相关改动方案。这是目前应用相对比较广泛的一种方式，其结构定义你可以参考下面的示意图。

![](D:\Work\TyporaNotes\note\微服务\分布式\pict\1-1.jpg)

整体长度通常是64 （1 + 41 + 10+ 12 = 64）位，适合使用Java语言中的long类型来存储。

* 头部是1位的正负标识位。
* 紧跟着的高位部分包含41位时间戳，通常使用System.currentTimeMillis()。
* 后面是10位的WorkerID，**标准定义是5位数据中心 + 5位机器ID，组成了机器编号，以区分不同的集群节点。**
* **最后的12位就是单位毫秒内可生成的序列号数目的理论极限。**

Snowfake方案的好处是算法简单，依赖也非常少，生成的序列可预测，性能也非常好，比如Twitter的峰值超过10万/s。

但是，它也存在一定的不足，例如：

* **时钟偏斜问题（Clock Skew）**。我们知道普通的计算机系统时钟并不能保证长久的一致性，**可能发生时钟回拨等问题，这就会导致时间戳不准确，进而产生重复ID。**

  解决方案：**缓存历史时间戳，然后在序列生成之前进行检验，如果出现当前时间落后于历史时间的不合理情况，可以采取相应的动作**，要么重试、等待时钟重新一致，或者就直接提示服务不可用。

* 另外，**序列号的可预测性**是把双刃剑，虽然简化了一些工程问题，但很多业务场景并不适合可预测的ID。如果你用它作为安全令牌之类，则是非常危险的，很容易被黑客猜测并利用。

* 从理论上来说，类似Snowfake的方案**由于时间数据位数的限制，存在与2038年问题相似的理论极限**。

  * 2038年问题？

    在大部分的32位操作系统上，此“time_t”数据模式使用一个有符号32位整数(signed int32)存储计算的秒数。当距离格林尼治时间的毫秒数达到一个4字节，也就是32位，即达到最大值2147483647，此时是2038年1月19日，之后的时间都会变成负数，所有用到这种“标准时间库”的C语言程序都会碰到时间计算上的麻烦。

    **解决方案：**给那些程序换一个新版本的“标准时间库”。比如说，改用8字节64位的形式来存储时间。

除了唯一和有序，考虑到分布式系统的功能需要，通常还会额外希望分布式ID保证：

* **有意义，或者说包含更多信息，例如时间、业务等信息。**这一点和有序性要求存在一定关联，如果ID中包含时间，本身就能保证一定程度的有序，虽然并不能绝对保证。ID中包含额外信息，在分布式数据存储等场合中，有助于进一步优化数据访问的效率。
* **高可用性，这是分布式系统的必然要求。**前面谈到的方案中，有的是真正意义上的分布式，有得还是传统主从的思路，这一点没有绝对的对错，取决于我们业务对扩展性、性能等方面的要求。
* **紧凑性**，ID的大小可能受到实际应用的制约，例如数据库存储往往对长ID不友好，太长的ID会降低MySQL等数据库索引的性能；编程语言在处理时也可能受数据类型长度限制。