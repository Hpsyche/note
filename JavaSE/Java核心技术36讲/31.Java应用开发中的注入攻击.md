* SQL注入

* 操作系统命令注入

* XML攻击注入

  Java核心类库提供了全面的XML处理、转换等各种API，而XML自身是可以包含动态内容的，例如XPATH，如果使用不当，可能导致访问恶意内容。

  还有类似LDAP等允许动态内容的协议，都是可能利用特定命令，构造注入式攻击的，包括XSS（Cross-site Scripting）攻击，虽然并不和Java直接相关，但也可能在JSP等动态页面中发生。

## 知识拓展

哪些Java API和工具构成了Java安全基础？主要可以分为以下三个方面：

1. 运行时安全机制。可以简单认为，就是限制Java运行时的行为，不要做越权或者不靠谱的事情，具体来看：

   * **在类加载过程中，进行字节码验证，**以防止不合规的代码影响JVM运行或者载入其他恶意代码。

   * **类加载器本身也可以对代码之间进行隔离**，例如，应用无法获取启动类加载器（Bootstrap Class-Loader）对象实例，不同的类加载器也可以起到容器的作用，隔离模块之间不必要的可见性等。目前，Java Applet、RMI等特性已经或逐渐退出历史舞台，类加载等机制总体上反倒在不断简化。

   * **利用SecurityManager机制和相关的组件，限制代码的运行时行为能力，**其中，你可以定制policy文件和各种粒度的权限定义，限制代码的作用域和权限，例如对文件系统的操作权限，或者监听某个网络端口的权限等。我画了一个简单的示意图，对运行时安全的不同层次进行了整理。

     ![](D:\Work\TyporaNotes\note\JavaSE\Java核心技术36讲\pict\31-1.PNG)

     可以看到，Java的安全模型是以代码为中心的，贯穿了从类加载，如URLClassLoader加载网络上的Java类等，到应用程序运行时权限检查等全过程。

     在应用实践中，如果对安全要求非常高，建议打开SecurityManager，

     > -Djava.security.manager

     请注意其开销，通常只要开启SecurityManager，就会导致10% ~ 15%的性能下降，在JDK 9以后，这个开销有所改善。

   * 另外，从原则上来说，**Java的GC等资源回收管理机制，都可以看作是运行时安全的一部分，**如果相应机制失效，就会导致JVM出现OOM等错误，可看作是另类的拒绝服务。

2. Java提供的安全框架API，这是构建安全通信等应用的基础。

   * 加密、解密API。
   * 授权、鉴权API。
   * 安全通信相关的类库，比如基本HTTPS通信协议相关标准实现，如TLS 1.3；或者附属的类似证书撤销状态判断（OSCP）等协议实现。

3. JDK集成的各种安全工具

   * keytool，这是个强大的工具，可以管理安全场景中不可或缺的秘钥、证书等，并且可以管理Java程序使用的keystore文件。
   * jarsigner，用于对jar文件进行签名或者验证。

## Java安全漏洞

任何可以用来绕过系统安全策略限制的程序瑕疵，都可以算作安全漏洞。具体原因可能非常多，设计或实现中的疏漏、配置错误等，任何不慎都有可能导致安全漏洞出现，例如恶意代码绕过了Java沙箱的限制，获取了特权等。

但是，要达到攻击的目的，未必都需要绕过权限限制。

<font color=red>**比如利用哈希碰撞发起拒绝服务攻击（DOS，Denial-Of-Service attack），常见的场景是，攻击者可以事先构造大量相同哈希值的数据，然后以JSON数据的形式发送给服务器端，服务器端在将其构建成为Java对象过程中，通常以Hastable或HashMap等形式存储，哈希碰撞将导致哈希表发生严重退化，算法复杂度可能上升一个数量级（HashMap后续进行了改进，我在专栏第9讲介绍了树化机制），进而耗费大量CPU资源。**</font>

拿到json格式的数据之后都需要做jsonDecode(),将json串转换为json对象，而对象默认会存储于Hash Table，而Hash Table很容易被碰撞攻击。我只要将攻击数据放在json中，服务端程序在做jsonDecode()时必定中招，中招后CPU会立刻飙升至100%。16核的CPU，16个请求就能达到DoS的目的。

如何防御

- 打补丁，修改hash算法。
- 限制POST的参数个数，限制POST的请求长度。
- 使用防火墙检测异常请求
- 增加权限验证，最大可能的在jsonDecode()之前把非法用户拒绝
- 重写jsonDecode()方法