Integer的值缓存，是Java5中的一个改进。

缓存值为-128——127

当然，这种缓存机制并不是Integer才有，其他一些包装类也有，比如：

* Boolean：缓存了true、false
* Short：缓存了-128——127之间的数值
* Byte：全部被缓存
* Character：缓存'\u0000'到'\u007F'

如果两个对象的int值相同且落在缓存值范围内，那么这个两个对象就是
同一个对象；当值较小且频繁使用时，推荐优先使用整型池方法（时间与空间性能俱佳）。

### 注意事项

[1] 基本类型均具有取值范围，在大数*大数的时候，有可能会出现越界的情况。
[2] 基本类型转换时，使用声明的方式。例：long result= 1234567890 * 24 * 365；结果值一定不会是你所期望的那个值，因为1234567890 * 24已经超过了int的范围，如果修改
为：long result= 1234567890L * 24 * 365；就正常了。
[3] 慎用基本类型处理货币存储。如采用double常会带来差距，常采用BigDecimal、整型（如果要精确表示分，可将值扩大100倍转化为整型）解决该问题。
[4] 优先使用基本类型。原则上，建议避免无意中的装箱、拆箱行为，尤其是在性能敏感的场合，
[5] 如果有线程安全的计算需要，建议考虑使用类型AtomicInteger、AtomicLong 这样的线程安全类。部分比较宽的基本数据类型，比如 foat、double，甚至不能保证更新操作的原子性，
可能出现程序读取到只更新了一半数据位的数值。

## 对象在内存中的布局

在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

* HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为"Mark Word"。

  对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身，这点将在2.3.3节讨论。

  另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。

* 接下来的实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。

* 第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。









* 学校概况

  * 海大简介
  * 历史沿革
  * 重点学科

* 校园资讯

  * 综合要闻
  * 科教动态
  * 校园快讯

* 海大社区

  * 吉他社
  * halo女子舞队
  * 日语社

* 海大风光

  * 学校大门
  * 钟海楼
  * 图书馆
  * 艺术楼

* 海大商城

  * 海红香米
  * 农学院鲜奶

* 服务中心

  