# 进程的引入

## 程序顺序执行的特征

* 顺序性
* 封闭性
* 可再现性

由于单道程序系统具有资源浪费、效率低下等明显缺点，现代操作系统不再使用，而广泛使用多道程序设计技术。

## 多道程序设计

具有提高系统资源利用率和增加系统吞吐量的优点，但程序的并发执行和系统资源的共享使得操作系统的工作变得很复杂，不像单道程序执行那样简单、直观。

特征：

* 间断性（执行--暂停--执行）
* 失去封闭性
* 失去可再现性

由于多道程序并发执行时共享系统资源，共同决定着这些资源的状态，因此系统中并发执行的程序之间存在着某种相互制约的关系，出现“走走停停”的现象，而程序这一静止的概念不能如实地放映该特征，故引入进程的概念。

## 进程的概念

进程是**可并发执行的程序在一个数据集合上的执行过程。**

### 进程和程序的关系

| 进程                                               | 程序                     |
| -------------------------------------------------- | ------------------------ |
| 动态性                                             | 静态性                   |
| 并发性                                             | 顺序性                   |
| 暂时性                                             | 永久性                   |
| 进程=程序+数据+进程控制块                          | -----                    |
| 一个进程可以涉及一个或多个程序的执行，通过多次执行 | 一个程序可以对应多个进程 |

**注意：进程和程序不是一一对应的关系**



# 进程的状态及组成

## 进程的基本状态

* 运行状态
* 就绪状态
* 阻塞状态**（当进程由于等待输入输出操作或某个同步事件而暂停运行时，就处于阻塞状态）**

## 3种基本状态的转换

![](/pict/进程状态转换图.png)

### 就绪状态-->运行状态

由进程调度程序负责；

对于单处理机的系统，处于运行状态的进程只有一个；

### 运行状态-->就绪状态

正在运行的进程，由于<font color=red>**规定的时间片用完**</font>而被暂停执行，该进程就会从运行状态转变成就绪状态；

（该进程根据自身的情况（如优先级）插入就绪队列的适当位置，系统收回处理机后转入进程调度程序重新进行调度。）

### 运行状态-->阻塞状态

进程请求I/O、等待某个事件或请求访问某个临界资源，因该临界资源正在被其他进程访问，则请求该资源的进程将由运行状态变成阻塞状态，此时系统会调用进程调度程序重新选择一个进程投入运行。

### 阻塞状态-->就绪状态

当阻塞的原因解除后，被阻塞的进程不能立即投入运行，而是从阻塞状态变成就绪状态等待处理机。



## 5种进程状态及转换

![](https://github.com/Hpsyche/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/pict/5%E7%A7%8D%E7%8A%B6%E6%80%81%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png)

### 创建状态

创建状态下的进程正在创建过程中，还不能运行；操作系统在创建进程时，要为进程分配PCB结构等

当就绪队列接纳新创建的进程时，操作系统就把处于创建状态的进程移入就绪队列，此时，进程从创建状态转化成就绪状态。

### 退出状态

当进程已经完成了预期的任务，或者发生某事件（如出现地址越界、非法指令等错误）而被异常终止时，进程将由运行状态转化为退出状态；

系统并不立即撤销一个正常或异常结束的进程，而是暂时留在系统中，以便让其他相关进程从该退出进程的PCB中收集相关信息。



## 进程的挂起状态

### 引入挂起状态的原因

* 内外存对换的需要

为了缓和内存紧张的情况，**将内存中处于阻塞状态的进程移至外存**，这样进程又处于一种有别于阻塞状态的新状态，在这种状态下，即使该进程等待的事件发生或者阻塞的原因解除，该挂起进程仍然不能进入就绪状态，因为它还存放在外存。

* 用户调试程序的需要（debug）
* 实时系统中调节负载的需要

### 进程状态的转换

单挂起状态的进程状态转换图

![](https://github.com/Hpsyche/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/pict/%E5%8D%95%E6%8C%82%E8%B5%B7%E7%8A%B6%E6%80%81%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png)

双挂起状态的进程状态转换图

![](https://github.com/Hpsyche/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/pict/%E5%8F%8C%E6%8C%82%E8%B5%B7%E7%8A%B6%E6%80%81%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png)

#### 阻塞-->阻塞挂起

当内存紧张时会引起这种状态的转换，将处于阻塞状态的进程挂起（从内存移到外存），是为了腾出更多内存空间给新创建的进程或就绪的进程

####  就绪-->就绪挂起

当挂起一些阻塞的进程仍然不能满足内存的需要，或者当有高优先级阻塞的进程和低优先级就绪的进程时，系统会选择首先挂起低优先级就绪的进程，因为系统认为应该让高优先级的进程尽快完成。

#### <font color=red>运行-->就绪挂起</font>

在抢占式分时系统中，当高优先级阻塞挂起的进程因事件出现而进入就绪挂起状态时，如果内存空间不够，系统可能将正在运行的进程状态转化为就绪挂起状态。

#### 就绪挂起-->就绪

#### 阻塞挂起-->阻塞

 

# 进程控制块

## 进程映像

进程控制块：一个用来描述进程本身的特性、进程的状态、进程的调度信息以及对资源的占有情况等的数据结构。

进程（映像）=程序+数据+栈+PCB

程序段描述了进程本身所要完成的功能；

数据段是程序操作的对象；（全程变量、局部变量、定义的变量。。。）

栈是一段系统存储单元，用于保存程序调用的参数、过程调用地址和系统调用地址。

**进程控制块是在进程创建时建立的，当进程存在于系统时，进程控制块就代表了这个进程；当进程撤销时，进程控制块也随之撤销。**

<font color=red>进程控制块是进程存在的唯一标识。</font>

## 进程控制块的作用

进程控制块是进程实体的一部分，它是操作系统中最重要的数据结构。

**其作用是使一个在多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位，是一个能与其他进程并发执行的进程。**

当系统创建了一个新进程时，就为它建立了一个进程控制块；当进程结束时，又收回其进程控制块。

（因为进程控制块经常被访问，尤其是被运行频率很高的进程调度程序访问，故进程控制块应常驻内存。

## 进程控制块中的内容

### 进程描述信息

* 进程名
* 进程标识符
* 用户名

### 处理机状态信息

* 通用寄存器
* 指令计数器
* 程序状态字寄存器
* 栈指针

### 进程调度信息

* 进程的状态
* 进程的优先级
* 运行统计信息
* 进程阻塞的原因

### 进程控制和资源占用信息

* 程序入口地址
* 程序的外存地址
* 进程同步及通信机制
* 资源占用信息
* 链接指针

为了统一管理、控制和调度进程，操作系统往往将进程控制块集中组织。

# 进程控制

**多道程序环境中（支持多线程环境）中，操作系统<font color=red>分配资源</font>是以<font color=red>进程</font>为基本。**

## 操作系统内核

为了保护操作系统及其数据结构，处理机的执行状态分为核心态和用户态。

### 核心态

核心态又称为系统态，具有较高的特权，能执行一切指令，能访问所有寄存器及内存的所有区域，操作系统内核通常运行在系统态。

### 用户态

用户态是具有较低特权的执行状态。在这种状态下，只能执行规定的指令，访问指定的寄存器和内存的指定区域。通常用户的程序在用户态下运行，因此用户程序不能访问操作系统的区域。

### 内核与原语

硬件的第一次延伸；

操作系统通常将一些与硬件紧密相关的模块放在**内核**上，并且**这部分程序常驻内存，以便提高运行效率。**

内核是由原语来实现的，原语是由原子操作（不可分割的一个操作）构成的。因此原语在被执行时是不可以被中断的。

原语是“原子操作”。即一个操作中的所有动作，要么全做，要么全不做。

内核一般包含以下一般功能：

* 时钟管理
* 中断处理
* 原语操作

## 进程的创建与撤销

### 进程的创建

引起创建进程的事件：

* 用户登录
* 新作业进入系统
* 提供服务
* 应用请求

创建原语要做的工作：

* 申请空白PCB
* 初始化进程描述信息
* 为进程分配资源、分配存储空间
* 将新进程插入就绪队列

### 进程的撤销

引起进程撤销的事件

* 进程正常结束，即进程执行完需要做的工作
* 进程异常结束
* 外界干预

撤销原语要做的工作

* 查找撤销进程的PCB
* 若进程处于运行状态，予以终止，并进行进程调度，以重新筛选其他进程运行
* 若进程有子孙，予以终止。
* 归还资源
* 从所在队列移除

### 进程的阻塞与唤醒

引起进程阻塞和唤醒的事件

* 请求系统服务
* 启动某种操作
* 新数据尚未到达
* 无新工作可做

阻塞原语需要做的工作
<font color=red>***（进程的阻塞是进程自身的一种主动行为，是进程通过调用阻塞原语把自己阻塞）***</font>

* 停止进程的执行
* 将进程插入阻塞队列
* 重新调度

唤醒原语需要做的工作

* 将进程从阻塞队列解下
* 把进程插入就绪队列
* 改变进程在PCB中的状态（插入阻塞就绪队列）

**阻塞原语和唤醒原语必须成对使用**，否则被阻塞的进程将会因不能被唤醒而一直处于阻塞状态，没有机会再运行。



# 线程

多线程程序具有以下优点

* 响应度高
* 资源共享
* 经济

## 线程的概念

### 线程的引入

引入进程的目的：使多个程序并发执行，改善资源的利用率，提高系统的吞吐量；（具有较大的时间、空间开销）

**传统的操作系统中：**

**进程是一个可以拥有资源的独立单位**

**进程是一个可以独立调度和分派的基本单位**

引入线程的目的：<font color=red>减少程序并发执行时所付出的时间和空间开销，使操作系统具有更好的并发性。</font>

**引入线程的操作系统中：**

**线程是进程的一个实体，是被独立调度和分派的基本单位，表示进程中的一个控制点，执行一系列指令。**

### 线程的组成

每个线程都有一个线程控制块TCB，其由以下几部分组成：

* 线程标识符
* 描述处理机状态信息的一组寄存器
* 栈指针
* 一个私有存储区

线程由线程控制块和属于该线程的用户栈和核心栈组成。

单进程，单线程：DOS

单进程，多线程：Java

多进程，每个进程一个线程：Unix

多进程，每个进程多个线程：Windows 2000、Linux

## 用户级线程与内核级线程

### 用户级线程

线程的创建、撤消和切换，都不利用系统调用来实现。**线程与内核无关，内核也不知道线程的存在。**

对于用户级线程，一个进程内部线程的行为不影响其他进程，内核只对进程进行适当的调度。

### 内核级线程

依赖于内核，线程的创建、撤消和切换都由内核实现。在内核中有线程控制块（TCB），内核根据TCB感知线程的存在，并对线程进行控制。

## 线程与进程的比较

### 线程与进程的关系

![](https://github.com/Hpsyche/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/pict/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB.png)

并发性：在引入线程的操作系统中，不仅进程之间可以并发执行，一个进程中的多个线程之间亦可并发执行。

### 线程与进程的比较

* 调度

传统的操作系统中拥有资源的基本单位、独立调度及分派的基本单位都是进程。而在引入线程的操作系统中，则把线程作为调度和分派的基本单位，把进程作为资源分配的基本单位。

在同一个进程中，线程的切换不会引起进程的切换，只有当从一个进程的线程切换到另一个进程中的线程时，才会引起进程的切换。

* 并发性

在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间也可以并发执行，因此操作系统具有更好的并发性，从而可以更有效地使用系统中的资源，提高系统的吞吐量。

* 拥有资源

<font color=blue>不论是传统的操作系统，还是具有线程的操作系统，进程都是拥有资源的独立单位。</font>一般地说，线程自己不拥有资源（只有少量的必不可少的资源），但它可以访问其隶属进程的资源。

* 系统开销

在创建或销毁进程时，操作系统所付出的时间和空间开销将显著大于重建或撤销线程的开销。

## 线程的实现

对于进程来讲，无论是系统进程还是用户进程，在进行切换时都要依赖于内核中的进程调度程序。**所以，内核是感知进程存在的，在内核支持下进行进程切换。**

而对于线程则不然，根据线程的切换是否依赖于内核可以把线程分为用户级线程和内核级线程。

### 用户级线程

如：数据库管理系统

用户级线程只存在于用户级，线程的创建、撤销及切换都不利用系统调用实现，因而这种线程与内核无关，内核也不知道这种线程的存在。

#### 用户级线程的优点

* 线程切换不需要系统状态的转换
* 每个进程可以使用专用的线程调度算法来调度线程
* 用户级线程可以在任何操作系统中运行，不需要对底层操作系统内核进行修改

#### 用户级线程的缺点

* 当一个用户级线程调用一个系统调用时，系统会认为是这个线程所在进程的行为，因此进程被阻塞，进程中的所有用户级线程此时都不能继续执行
* 在只使用用户级线程的系统中，一个多线程的应用程序不能利用多处理机技术。（解决方案是：把应用程序写成一个多进程的程序，但这也消除了用户级线程的优点）

### 内核级线程

如：OS/2、Windows 2000、Linux、Mach等

内核级线程的调度不需要考虑这个线程属于哪个进程。

在进行线程调度时，当两个线程的优先权相同，一个线程和正在运行的线程属于同一个进程，而同一个线程属于其进程，系统将优先考虑前者，因为后者要进行内存映射并清除高速缓存，系统开销较大。

#### 内核级线程的优点

* 在多处理机环境中，内核可以同时把同一个进程的多个线程分配到多个处理机上
* 如果进程中的一个线程被阻塞，内核可以调度一个进程的同一个线程执行
* 内核本身也可以设计成多线程

#### 内核级线程的缺点

* 在同一个进程中把控制权从一个线程切换给另一个线程需要内核的状态转换

### 用户级线程与内核级线程的主要区别：

#### 切换速度

用户级线程切换可用机器指令，速度快；

内核级线程切换需要内核模式的转换，速度慢。

#### 阻塞

当用户级线程因等待I/O阻塞时，会将它所在的整个进程阻塞，而内核级线程的阻塞不会涉及它所在的进程。

#### 系统调用

用户级线程在调用系统调用时，系统将看成是其所在进程的行为。而内核级线程的系统调用是以线程为单位。因此比较轻装。**用户级线程不如内核级线程。**

#### 线程执行时间

**用户级线程不如内核级线程合理。**



# 课堂练习

![](https://github.com/Hpsyche/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/pict/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%981.png)

![](https://github.com/Hpsyche/note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/pict/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%982.png)
