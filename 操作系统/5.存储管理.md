# 程序的装入与链接

## 重定位

地址重定位完成的是相对地址转换（逻辑地址）成内存的绝对地址（物理地址）的工作。

按照重定位的时机，可分为静态重定位和动态重定位。

### 静态重定位

静态重定位就是在程序执行之前进行重定位。它根据装入模块将要装入的内存起始地址修改装入模块中有关使用地址的代码。

优点：

* 无须硬件支持

缺点：

* 程序重定位之后不能再在内存中移动
* 要求程序的存储空间是连续的，不能把程序放在若干个不连续的存储区域内。

### 动态重定位

动态重定位是指程序在执行过程中进行地址重定位。更确切地说是在每次访问每个地址单元前再进行地址变换。动态重定位需要硬件----重定位寄存器的支持。

当该程序运行时，CPU每取一条访问内存的指令，地址变换硬件逻辑就自动将指令中的相对地址与重定位寄存器中的值相加，再将此值作为内存绝对地址去访问该单元中的数据。

优点：

* 目标模块装入内存时无须任何修改，因此装入后可以再搬迁
* 一个程序是由若干个相对独立的目标模块组成的。

每个目标模块装入内存时可以各放在一个存储区域，这些存储区域可以不是顺序相邻的，只要各个模块有自己对应的重定位寄存器即可。

## 链接

实现链接的方法有3种，分别为静态链接、装入时动态链接和运行时动态链接

### 静态链接

* 相对地址的修改
* 外部符号引用的变化

### 装入时动态链接

优点：

* 便于软件版本的更新
* 便于实现目标模块的共享

### 运行时动态链接

* 程序的整个运行期间，装入模块是不改变的
* 每次运行时的装入模块是相同的



# 连续分配存储管理方式

连续分配是指为用户程序分配一个连续的内存空间。

## 单一连续分区

它只能适用于单用户、单任务的操作系统中，如CP/M和MS-DOS操作系统用的就是这一方案。

在其中，整个内存区域被分为系统区域和用户区域两部分。其采用了**静态重定位**的方式实现地址映射。

* 系统区域

提供给操作系统使用，它可以驻留在内存的低地址部分，也可以驻留在内存的高地址部分。

* 用户区域

供应用程序使用的内存区域。（任何时刻最多只存在一个用户作业）

## 固定分区

在进程装入内存之前，由操作员或操作系统把内存划分为若干个大小不等的分区。一旦划分好，在系统运行期间就不能再重新划分。其采用了**静态重定位**的方式实现地址映射。

每个分区只分配给一个作业使用，作业必须一次性连续装入一个分区内。

采用这种内存分配技术，虽使多个用户进程共驻内存，但一个进程的大小刚好等于某个分区大小的情况非常少，于是每个分区中总有一部分被浪费。

固定分区技术简单，但内存利用率不高，适用于进程的大小及数量事先能够预知的系统中。

## 可变分区

可变分区是指在进程装入内存时，把可用的内存空间“切出“一个连续的区域分配给进程，以适应进程大小的需要。

其采用了**动态重定位**的方式来实现地址映射。

整个内存分区的大小和分区的个数不是固定不变的，而是根据装入进程的大小动态划分，因此也称为动态分区。

随着进程的撤销和新进程的不断装入，原来整块的内存区域就形成了空闲分区和已分配分区相间的局面。

### 可变分区中的数据结构

* 空闲分区表
* 空闲分区链

### 可变分区分配算法、

* 首次适应算法
* 下次适应算法
* 最佳适应算法
* 最坏适应算法

## 动态重定位分区

由于空闲分区分散，大进程无法进入；为了解决这一问题，采用了紧凑的方法。



以上问题：一个进程必须存放在一个连续的内存空间中。故出现了离散式的分配方式。

页式、段式存储管理技术 都是 离散式分配方式。

# 页式存储管理

## 基本原理

将进程的逻辑地址空间分成若干个与内存块大小相等的页，在为进程分配内存空间时，以页为单位进行。进程中的若干个页分别装入多个不相邻的存储块。

进程的最后一页经常装不满一个存储块，而形成不可利用的碎片，成为页内碎片。

### 页表

在页式管理系统中，进程的若干个页被离散地存储在内存的多个存储块中，为了能找到每个页所对应的存储块，系统为每个进程建立一张页表。

页表的作用：<font color=red>实现从页号到存储块号的地址映射</font>

除此之外，系统还建立一张空闲块表，该表按存储块号从小到大的次序记录内存未分配存储块的块号。

即：**每个进程建一张表+空闲块表**

### 页的大小

页的大小要适中，太大增加页内碎片；太小页表长度增大，占用内存空间。

## 页式存储管理的地址变换机构

一旦确定了分页地址结构，也即定义了内存中块大小和最大用户作业大小。

## 页表的硬件实现

页表是存放在内存中的，这使CPU每次要存取一个数据时都要**访问两次内存**。第一次是访问内存中的页表，从页表中找到该页的存储块号，将此块号与页内位移形成物理地址。第二次访问内存时才真正从得到的物理地址存取数据。

为了提高系统的地址变换速度，在地址变换机构中设置一组由高速寄存器组成的小容量联想存储器（快速存储器），构成一张快表，用来存放当前访问最频繁的少量活动页。

如果用户要找的页在快表中能找到，即可得到相应页的块号，从而形成物理地址；如果找不到，就必须访问页表。

地址变换过程如下：

1. 在处理机得到进程的逻辑地址后，将改地址分为页号和页内位移两部分；
2. 由地址变换机构自动将页号与快表中的所有页进行比较，若与其中某页相匹配，则从快表中查出相应页的存储块号，并转4；如在快表中没有找到，则转3；
3. 访问内存中的页表，找到后读出存储块号。同时将页表项内容存入快表中的一个单元，即修改快表。如果联想存储器已满，将快表中被认为不再需要的页换出；
4. 由存储块号与页内位移得到物理地址。

## 页表的组织

* 两级页表
* 多级页表
* 反置页表



# 段式存储管理

段式存储管理方式的引入，主要是为了满足用户在编程和使用上的要求。

* 方便编程

* 段的共享

  段是信息的逻辑单元，实现段信息的共享更有意义。

* 段的保护

* 动态链接

  程序运行过程中调用某段时，才将该段调入内存并进行链接。可见，动态链接也要求以段为存储管理单位。

* 动态增长

## 段的共享与保护

* 段的共享

段式存储管理系统突出的优点：易于实现段共享，即允许多个进程共享一个或多个段。

* 段的保护

段式存储管理系统另一个突出的优点：便于对段的保护。



## <font color=red>※分段和分页的区别※</font>

* 页是信息的物理单位，分页式为了实现进程在内存的有效离散存放，以减少碎片，提供内存的利用率；

  段是信息的逻辑单位，段是一组有意义的相对完整的信息。

  **即分页是系统管理的需要，而分段的目的是为了满足用户的需要。**

* 页的大小是固定的，把逻辑地址分成页号和页内位移两部分，是由机器硬件实现的，因而一个系统只能有一种大小的页；

  段的长度是可变的，由用户所编写的程序决定。

* 页的逻辑地址空间是一维的，给出页的逻辑地址时只给出一个地址；

  段的逻辑地址空间时二维的，在给出段的逻辑地址时既要给出段号，又要给出段内地址。



# 段页式存储管理

段页式存储管理系统是段式系统和页式系统的组合。先将进程分段，再将每个段分成若干个页。

**在段页式存储管理系统中，为了获得一条指令或数据，需要3次访问内存。**

第一次访问内存中的段表，从中得到页表始址。第二次访问内存中的页表，从中获得该也所对应的存储块号，并将存储块号与页内位移一起形成指令或数据的物理地址。第三次用得到的物理地址真正访问指令或数据。





# 例题

页式存储管理系统是否产生碎片？如何应对此现象？

​	页式存储管理系统产生的碎片，称为内碎片，它是指一个进程的最后一页没有沾满一个存储块而被浪费的存储空间。减少内碎片的办法是减少页的大小。









