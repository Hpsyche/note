# 程序的装入与链接

对用户程序的处理步骤：

* 编译
* 链接
* 装入

## 链接

实现链接的方法有3种，分别为静态链接、装入时动态链接和运行时动态链接

### 静态链接

在程序的运行之前完成链接，形成可执行文件。

* **相对地址**的修改
* 外部符号引用的变化

### 装入时动态链接

在装入内存时，边装入边链接。

优点：

* 便于软件版本的更新
* 便于实现目标模块的共享

### 运行时动态链接

* 程序的整个运行期间，装入模块是不改变的
* 每次运行时的装入模块是相同的

## 重定位

地址变换机构的任务就是将**地址空间中的（逻辑地址）**变换为**内存空间中的（物理地址 ）**。

地址重定位（地址映射）完成的是相对地址转换（逻辑地址）成内存的绝对地址（物理地址）的工作。

源程序经编译链接后形成的程序模块中的地址称为逻辑地址（相对地址）。

要将程序装入内存中执行，就要确定装入内存的实际物理单元编号，这些物理单元的编号称为物理地址（绝对地址）。

按照重定位的时机，可分为静态重定位和动态重定位。

### 静态重定位

静态重定位就是**在程序执行之前进行重定位**。它根据装入模块将要装入的内存起始地址修改装入模块中有关使用地址的代码。

优点：

- 无须硬件支持

缺点：

- 程序重定位之后不能再在内存中移动
- 要求程序的存储空间是连续的，不能把程序放在若干个不连续的存储区域内。

### 动态重定位

动态重定位是指程序在执行过程中进行地址重定位。更确切地说是在每次访问每个地址单元前再进行地址变换。**动态重定位需要硬件----重定位寄存器的支持**。

当该程序运行时，CPU每取一条访问内存的指令，地址变换硬件逻辑就自动将指令中的相对地址与重定位寄存器中的值相加，再将此值作为内存绝对地址去访问该单元中的数据。

优点：

- 目标模块装入内存时无须任何修改，因此装入后可以再搬迁
- 一个程序是由若干个相对独立的目标模块组成的。

每个目标模块装入内存时可以各放在一个存储区域，这些存储区域可以不是顺序相邻的，只要各个模块有自己对应的重定位寄存器即可。



# 连续分配存储管理方式

连续分配是指为用户程序分配一个连续的内存空间。

## 单一连续分区

它只能适用于单用户、单任务的操作系统中，如CP/M和MS-DOS操作系统用的就是这一方案。

在其中，整个内存区域被分为系统区域和用户区域两部分。其采用了**静态重定位**的方式实现地址映射。

* 系统区域

提供给操作系统使用，它可以驻留在内存的低地址部分，也可以驻留在内存的高地址部分。

* 用户区域

供应用程序使用的内存区域。（任何时刻最多只存在一个用户作业）

## 固定分区

在进程装入内存之前，由操作员或操作系统把内存划分为若干个大小不等的分区。一旦划分好，在系统运行期间就不能再重新划分。其采用了**静态重定位**的方式实现地址映射。

每个分区只分配给一个作业使用，作业必须一次性连续装入一个分区内。

采用这种内存分配技术，虽使多个用户进程共驻内存，但一个进程的大小刚好等于某个分区大小的情况非常少，于是每个分区中总有一部分被浪费。

固定分区技术简单，但内存利用率不高，适用于进程的大小及数量事先能够预知的系统中。

## 可变分区

可变分区是指在进程装入内存时，把可用的内存空间“切出“一个连续的区域分配给进程，以适应进程大小的需要。

其采用了**动态重定位**的方式来实现地址映射。

整个内存分区的大小和分区的个数不是固定不变的，而是根据装入进程的大小动态划分，因此也称为动态分区。

随着进程的撤销和新进程的不断装入，原来整块的内存区域就形成了空闲分区和已分配分区相间的局面。

### 可变分区中的数据结构

* 空闲分区表
* 空闲分区链

### 可变分区（空闲分区）分配算法

* 首次适应算法
* 下次适应算法
* 最佳适应算法
* 最坏适应算法

### 内存回收

回收的分区与前面一个（低地址）空闲分区F1相邻接，修改F1大小（加上回收区的大小）；

回收分区与后面一个（高地址）空闲分区F2相邻接，修改F2的起始地址为回收区的起始地址。

回收分区与前、后两个空闲分区F1和F2均相邻，修改F1的大小（三个相邻区的大小之和）

## 动态重定位分区

由于空闲分区分散，大进程无法进入；为了解决这一问题，采用了**紧凑**的方法。

以上问题：一个进程必须存放在一个连续的内存空间中，连续分配方式会在存储空间中产生许多“碎片”，故出现了离散式的分配方式。

页式、段式存储管理技术 都是 离散式分配方式。

# 页式存储管理

## 基本原理

将进程的逻辑地址空间分成若干个与内存块大小相等的页，在为进程分配内存空间时，以页为单位进行。进程中的若干个页分别装入多个不相邻的存储块。

进程的最后一页经常装不满一个存储块，而形成不可利用的碎片，成为页内碎片。

### 页表

在页式管理系统中，进程的若干个页被离散地存储在内存的多个存储块中，为了能找到每个页所对应的存储块，系统**为每个进程建立一张页表。**

页表的作用：<font color=red> </font>

除此之外，系统还建立一张空闲块表，该表按存储块号从小到大的次序记录内存未分配存储块的块号。

即：**每个进程建一张表 + 空闲块表**

### 页的大小

页的大小要适中，太大增加页内碎片；太小页表长度增大，占用内存空间。

## 页式存储管理的地址变换机构

**一旦确定了分页地址结构，也即定义了内存中块大小和最大用户作业大小。**

例如：若在分页地址结构中，地址的总长度为16位，其中页内地址长度为10位，页号长度为6位。
​            则页的大小：2^10=1KB，即块的大小也为1KB；
​            页框数：2^6=64，即每个作业最多可分成64个页。因此，最大的用户作业大小为：1KB * 64 =64KB 。 

### 地址映射

<font color=blue>逻辑地址是一维地址，要计算才得到页号和页内地址。</font>

这将使系统整体运行速度有所降低。为了提高查表速度，可在地址变换机构中加入一个速度比内存更快的小容量的**快速存储器**，存放作业运行过程中最常用的页号和对应的块号，该**快速页表称为快表**。

## 页表的硬件实现

### 快表

页表是存放在内存中的，这使CPU每次要存取一个数据时都要**访问两次内存**。

* 第一次是访问内存中的页表，从页表中找到该页的存储块号，将此块号与页内位移形成物理地址。
* 第二次访问内存时才真正从得到的物理地址存取数据。

为了提高系统的地址变换速度，在地址变换机构中设置一组由高速寄存器组成的小容量联想存储器（快速存储器），构成一张快表，用来存放当前访问最频繁的少量活动页。

如果用户要找的页在快表中能找到，即可得到相应页的块号，从而形成物理地址；如果找不到，就必须访问页表。

**<font color=red>地址变换过程如下：</font>**

1. 在处理机得到进程的逻辑地址后，将该地址分为页号和页内位移两部分；
2. 由地址变换机构自动将页号与快表中的所有页进行比较，若与其中某页相匹配，则从快表中查出相应页的存储块号，并转4；如在快表中没有找到，则转3；
3. 访问内存中的页表，找到后读出存储块号。同时将页表项内容存入快表中的一个单元，即修改快表。如果联想存储器已满，将快表中被认为不再需要的页换出；
4. 由存储块号与页内位移得到物理地址。

## 页表的组织

现代的计算机系统都支持大的逻辑地址空间，当地址空间较大，页表也就相应很大：

例如：逻辑地址为32位时，若页面大小为4KB=212B，那就得有页表项目220=1M个，又因为每个页表项占4B，故每张页表要占用4MB内存。

1.地址空间采用离散分配方式来解决： 两级和多级页表。

2.将当前需要的部分页表项调入内存，其余的页表项仍驻留在磁盘上，需要时再调入内存。

* 两级页表
* 多级页表
* 反置页表

## 页式存储管理优缺点

优点：

   不要求作业的程序段和数据在内存中连续存放，从而**有效地解决了内存碎片问题**。

缺点：

  由于页面的划分未考虑作业空间的逻辑意义，所以不容易实现存储共享。



# 段式存储管理

段式存储管理方式的引入，主要是为了满足用户在编程和使用上的要求。

* 方便编程

* 段的共享

  段是信息的逻辑单元，实现段信息的共享更有意义。

* 段的保护

* 动态链接

  程序运行过程中调用某段时，才将该段调入内存并进行链接。可见，动态链接也要求以段为存储管理单位。

* 动态增长

## 基本思想

* 将作业地址空间按逻辑意义划分成段，每个段定义一个完整逻辑信息，从“0”开始编址；

  每个段有唯一的名字，以段为单位分配内存。

* 内存空间使用动态分区的管理方式，每段分配在连续的区域，各段可以不连续存放。

## 分段地址转换

<font color=blue>逻辑地址是真正的二维地址，直接体现段号和段内地址。</font>

## 段的共享与保护

由于段是信息的逻辑单位，用户易于实现对段的共享，也容易对段进行保护。

* 段的共享

段式存储管理系统突出的优点：易于实现段共享，即允许多个进程共享一个或多个段。

如果用户作业或进程需要共享内存中的某段程序或数据，只要用户<font color=red>使用相同的段名</font>，系统则在段表中填入已经在内存中的段的起始地址，就可以实现共享一个逻辑上功能完整的段。

* 段的保护

段式存储管理系统另一个突出的优点：便于对段的保护。

### 页共享与段共享的比较

在分页系统，要求共享页的页码必须要相同；

使用分段系统，不要求段号一定相同；

## <font color=red>※分段和分页的区别※</font>

* 页是信息的物理单位，分页式为了实现进程在内存的有效离散存放，以减少碎片，提高内存的利用率；

  段是信息的逻辑单位，段是一组有意义的相对完整的信息。

  **即分页是系统管理的需要，而分段的目的是为了满足用户的需要。**

* 页的大小是固定且由系统决定的，把逻辑地址分成页号和页内位移两部分，是由机器硬件实现的，因而一个系统只能有一种大小的页；

  段的长度是可变的，由用户所编写的程序决定。

* 页的逻辑地址空间是一维的，给出页的逻辑地址时只给出一个地址；

  段的逻辑地址空间时二维的，在给出段的逻辑地址时既要给出段号，又要给出段内地址。



# 段页式存储管理

## 产生原因：

*  分页系统能有效地提高内存的利用率——解决外部碎片问题。
*  分段系统则能更好地满足用户编程的需要——解决段的共享、动态连接等问题。
*  将两者结合起来，汲取两着的优点，产生段页式存储管理。

段页式存储管理系统是段式系统和页式系统的组合。先将进程分段，再将每个段分成若干个页。

**在段页式存储管理系统中，为了获得一条指令或数据，需要3次访问内存。**

<font color=red>第一次访问内存中的**段表**，从中得到**页表始址**。第二次访问内存中的**页表**，从中获得该也所对应的**存储块号**，并将存储块号与页内位移一起形成指令或数据的**物理地址**。第三次用得到的**物理地址**真正访问**指令或数据**。</font>





# 例题

页式存储管理系统是否产生碎片？如何应对此现象？

​	页式存储管理系统产生的碎片，称为内碎片，它是指一个进程的最后一页没有沾满一个存储块而被浪费的存储空间。减少内碎片的办法是减少页的大小。



<font color=red>**固定分区存在内部碎片，可变式分区分配会存在外部碎片；**</font>

**<font color=red>页式虚拟存储系统存在内部碎片；段式虚拟存储系统存在外部碎片</font>**

![](D:\Work\TyporaNotes\note\操作系统\pict\第五章课后习题1.png)

![](D:\Work\TyporaNotes\note\操作系统\pict\第五章课后习题2.png)

![](D:\Work\TyporaNotes\note\操作系统\pict\第五章课后习题3.png)

![](D:\Work\TyporaNotes\note\操作系统\pict\第五章课后习题4.png)



