# 运行时数据区域

![](D:\Work\TyporaNotes\note\JVM\pict\jvm运行时内存区域.png)

以以下代码为例，

```java
public class A{
	public int i=1;
}
public static void mian(String args[]){
    A a=new A();
}
```

![](D:\Work\TyporaNotes\note\JVM\pict\java内存区域.jpg)

1.加载class文件到class内容区域，加载静态方法和静态变量到静态区（同时加载的）
2.调用main方法到栈内存
3.在栈内存中为a变量（A对象的引用）开辟空间
4.在堆内存为A对象申请空间
5.给成员变量进行默认初始化（此时 i=0），同时有一个方法标记，在方法区中创建一个A的方法区，将A的方法区的地址0x01给方法标记
6.给成员变量进行显示初始化（此时 i=1）
7.将A对象的地址值给变量a

## 程序计数器

程序计数器是一块较小的内存空间，它可以当做是当前线程所执行的字节码的行号指示器。

字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

由于JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式了爱实现的，在任何一个确定的时刻，一个处理器（多核处理器为一个内核）都只会执行一条程序中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空。此内存区域是唯一一个在JVM规范中没有规定任何OutOfMemoryError情况的区域。

* *何为Native方法？*
  注：Java调用非Java代码的接口，如让Java去调用一个C的函数

## Java虚拟机栈

与程序计数器一样，<font color=red>Java虚拟机栈也是线程私有的</font>，它的生命周期与线程相同。

每个Java方法在执行的同时都会创建一个栈帧用于存储<font color=red>局部变量表、操作数栈、动态链接、方法接口</font>等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

### 局部变量表

局部变量表中存放了编译器可知的各种<font color=red>基本数据类型、对象引用、returnAddress类型</font>

* *基本数据类型？*

  注：（四种整数类型：byte（8位）、short（16位）、int（32位）、long（64位）；两种浮点类型：float（32位）、double（64位）、一种字符类型（char（16位））、一种布尔类型（boolean）（看虚拟机规范：1个字节、4个字节都有可能））、

* *对象引用？*

  reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

* *java有指针？*

  java有指针，在java中称为引用。所谓的引用就是内存地址的值。拿到该引用相当于得到了该内存处的对象。
  java中可以使用指针（我们称之为引用），但不能修改引用。

* 句柄与指针的区别？

  句柄实际上是一种指向某种资源的指针，但与指针又有所不同：指针对应着一个数据在内存中的地址，得到了指针就可以自由的修改该数据。但Windows并不希望一般程序修改其内存数据结构，故给每个使用GlobalAlloc等函数声明的内存区域指定一个句柄，平时你只是在调用API函数时利用这个句柄来说明要操作哪些内存。
  句柄：句柄只能调用系统提供的服务，windows靠句柄来找到要引用的对象，但是句柄的权限等都受操作系统所管理；且句柄是对象生成时系统指定的，是为了区别系统中存在的各个对象，这个句柄不是由程序员给的。

* *returnAddress类型？*

  指向了一条字节码指令的地址。

其中64位长度的long和double类型的数据会占用2个局部变量空间，其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间时完全确定的，在方法运行期间不会改变局部变量表的大小。

### 异常情况

* 线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常；
* 如果扩展时无法申请到足够的内存，就会抛出OutMemoryError异常；

* *栈扩展？*

  虚拟机栈也可以动态扩展（当前大部分的虚拟机都可动态扩展，只不过也允许设置固定长度的虚拟机栈）

## 本地方法栈

本地方法栈与虚拟机栈所发挥的作用是非常相似的，他们之间的区别是：

* 虚拟机栈虚拟机执行Java方法服务；
* 本地方法栈则为虚拟机使用到的Native方法服务。

## Java堆

Java堆是JVM所管理的内存中最大的一块。

Java堆是<font color=red>被所有线程共享</font>的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是<font color=red>存放对象实例</font>，几乎所有的对象实例都在这里分配内存。

* *几乎所有的对象实例都在这里分配内存，哪些不是？*

  随着发展，逃逸分析技术、栈上分配技术逐渐成熟，所有对象都分配在堆上也渐渐变得不是那么绝对了。

* *逃逸分析？*

  逃逸是指在某个方法之内创建的对象，除了在方法体之内被引用之外，还在方法体之外被其它变量引用到；这样带来的后果是由于其被其它变量引用，在该方法执行完毕之后，该方法中创建的对象将无法被GC回收。
  由于无法回收，即成为逃逸。

  ```java
  	String test2;
      /**
       * 逃逸
       */
      void test02() {
          test2 = "test2";
      }
  ```

* *栈上分配？*

  java对象一般是在堆里分配的，当对象不再使用后，需要依靠GC来遍历引用树并回收内存，如果对象数量较多，将给GC带来较大压力，也间接影响了应用的性能。
  因此，需要减少临时对象在堆内分配的数量，可以通过“栈上分配”方法实现。分析找到未逃逸的变量，将变量类的实例化内存直接在栈里分配(无需进入堆)，分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。

* Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆"；
* Java堆可细分为：新生代和老年代；新生代还可分为Eden空间、From Survivor空间、To Survivor空间(8:1:1)。
* Java堆可以处于物理上不连续的内存空间中，只要逻辑上（程序员接触地址）是连续的即可。

## 方法区（Non-Heap非堆）

方法区与Java堆一样，是<font color=red>各个线程共享</font>的内存区域，它用于存储已被虚拟机加载的<font color=red>类信息class、常量、静态变量static</font>、即时编译器编译后的代码等数据。

“永生代”：相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就“永久”存在性了，这个区域的垃圾收集主要是：收集常量池和对类型进行卸载，只是收集效率比较低。

* 常量的回收比较容易
* 类信息的回收需要满足的条件：
  * 该类所有的实例已经被回收，JVM中没有任何类的实例；
  * 加载该类的ClassLoader被回收；
  * 该类对应的java.lang.class没有地方引用

### 运行时常量池

运行时常量池是方法区的一部分。

用于存放编译期生产的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

JDK1.7之前运行时常量池逻辑包含<font color=red>字符串常量池存放在方法区</font>
在JDK1.7<font color=red>字符串常量池被从方法区拿到了堆中, 运行时常量池剩下的东西还在方法区</font>, 也就是hotspot中的永久代.

* *常量池的优点？*
  java中的常量池技术，是为了方便快捷地创建某些对象而出现的，当需要一个对象时，就可以从池中取一个出来（如果池中没有则创建一个），则在需要重复重复创建相等变量时节省了很多时间。

运行时常量池的一个重要特征是具备动态性，并非预置如Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。

```java
 public class Test {
        Integer i1 = new Integer(1);
        Integer i2 = new Integer(1);
        //i1,i2分别位于堆中不同的内存空间
        System.out.println(i1==i2);//输出false
        Integer i3 = 1;
        Integer i4 = 1;
        //i3,i4指向常量池中同一个内存空间
        System.out.println(i3==i4);//输出true
         //很显然，i1,i3位于不同的内存空间
        System.out.println(i1==i3);//输出false
    }
```

* 注意：java中基本类型的包装类的大部分都实现了常量池技术，这些类是Byte, Short, Integer, Long, Character, Boolean,另外两种浮点数类型的包装类则没有实现。另外Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值<font color=red>小于等于127时才可使用对象池</font>，也即对象不负责创建和管理大于127的这些类的对象。

```java
public class Test{
        public static void main(String[] args){
            //5种整形的包装类Byte,Short,Integer,Long,Character的对象，
            //在值小于127时可以使用常量池
            Integer i1=127;
            Integer i2=127;
            System.out.println(i1==i2)//输出true
            //值大于127时，不会从常量池中取对象
            Integer i3=128;
            Integer i4=128;
            System.out.println(i3==i4)//输出false
            //Boolean类也实现了常量池技术
            Boolean bool1=true;
            Boolean bool2=true;
            System.out.println(bool1==bool2);//输出true
            //浮点类型的包装类没有实现常量池技术
            Double d1=1.0;
            Double d2=1.0;
            System.out.println(d1==d2)//输出false
        }
    }
```



# Java堆中对象的创建等

## 对象的创建

虚拟机遇到一条new指令时：

* 首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。
* 如果没有，那么必须先执行相应的类加载过程（类加载过程见"Java类加载过程"）
* 在类加载检查通过后，虚拟机将会为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。
  * 假设Java堆中内存时绝对规整的，则分配内存仅仅是把作为分界点的指针向空闲空间挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”；
  * 注意到：对象创建在JVM中是很频繁的，仅仅修改一个指针所指向的位置，在并发情况下不是线程安全的，此时有两种解决方法：
    * 对分配内存空间的动作进行同步处理
    * 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲。

## 对象的内存布局

对象在内存中存储的布局可以分为3块区域：对象头、实例数据和对其填充。

### 对象头

包括两部分信息：第一部分用于存储对象自身的运行时数据，另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
换句话说，查找对象的元数据信息并不一定要经过对象本身。

* *元数据？*如i=1中的i

  元数据就是用来定义数据的数据。比如，有一条学生信息记录，其中包括字段姓名（name）、年龄（age）、性别（male）、班级（class）等，那么name、age、male、class就是元数据。通过它们的描述，一条关于学生信息的数据记录就产生；

注意：如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通对象的元数据信息确定Java对象的大小，但是从数据的元数据中却无法确定数组的大小。

### 实例数据

实例数据是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。

### 对齐填充

不是必然存在的，要求对象其实地址时8字节的整数倍，当对象实例数据部分没有对齐时，通过对齐填充来补全。

## 对象的访问定位

reference类型（存于JVM栈中）在JVM规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位，访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机决定的。

目前主流的访问方式有使用句柄和直接指针两种。

* 如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息

  ![](D:\Work\TyporaNotes\note\JVM\pict\通过句柄访问对象.jpg)

* 如果使用直接指针访问，那么Java堆对象的布局汇总就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。

  ![](D:\Work\TyporaNotes\note\JVM\pict\通过直接指针访问对象.jpg)

  这两种访问方式各有优势：

  使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改

  使用直接指针访问方式的最大好处就是速度快，它节省了一次指针定位的时间开销。



# OutOfMemoryError异常

## 堆溢出

Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。

## 虚拟机栈和本地方法栈溢出

- 线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常；
- 如果扩展时无法申请到足够的内存，就会抛出OutMemoryError异常；

## 方法区和运行时常量池溢出

```java
public class RuntimeConstantPoolOOM{
    public static void main(String[] args){
        String str1=new StringBuilder("计算机").append("软件").toString();
        System.out.print(str1.intern()==str1);
        String str2=new StringBuilder("ja").append("va").toString();
        System.out.print(str2.intern()==str2);
    }
}
```

这段代码在JDK1.6中获得两个False，在JDK1.7中运行获得true和false。

原因：

* 在JDK1.6中，intern()方法会把首次遇到的字符串实例复制到永生代中，返回的也是永生代中这个字符串实例的引用，而由Stringbuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false；
* 而在JDK1.7中，inern()实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因而返回的是同一个实例；
* str2比较返回false是因为“java”这个字符串在执行StringBuilder.toString()之前已经出现过，字符串常量池也有它的引用了，不符合“首次出现”的原则，因此为“false”。