# 运行时数据区域

![](D:\Work\TyporaNotes\note\JVM\pict\jvm运行时内存区域.png)

以以下代码为例，

```java
public class A{
	public int i=1;
}
public static void main(String args[]){
    A a=new A();
}
```

![](D:\Work\TyporaNotes\note\JVM\pict\java内存区域.jpg)

1.加载class文件到class内容区域，加载静态方法和静态变量到静态区（同时加载的）
2.调用main方法到栈内存
3.在栈内存中为a变量（A对象的引用）开辟空间
4.在堆内存为A对象申请空间
5.给成员变量进行默认初始化（此时 i=0），同时有一个方法标记，在方法区中创建一个A的方法区，将A的方法区的地址0x01给方法标记
6.给成员变量进行显示初始化（此时 i=1）
7.将A对象的地址值给变量a

## 程序计数器

程序计数器是一块较小的内存空间，它可以当做是当前线程所执行的字节码的行号指示器。

字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

由于JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式了实现的，在任何一个确定的时刻，一个处理器（多核处理器为一个内核）都只会执行一条程序中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空。此内存区域是唯一一个在JVM规范中没有规定任何OutOfMemoryError情况的区域。

* *何为Native方法？*
  注：Java调用非Java代码的接口，如让Java去调用一个C的函数

## Java虚拟机栈

与程序计数器一样，<font color=red>Java虚拟机栈也是线程私有的</font>，它的生命周期与线程相同。

每个Java方法在执行的同时都会创建一个栈帧用于存储<font color=red>局部变量表、操作数栈、动态连接、方法接口</font>等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

JVM是基于栈的体系结构来执行class字节码的。线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。

![](D:\Work\TyporaNotes\note\JVM\pict\栈.jpg)

### 局部变量表

局部变量表中存放了编译器可知的各种<font color=red>基本数据类型、对象引用、returnAddress类型</font>，通过索引来访问。

* *基本数据类型？*

  注：（四种整数类型：byte（8位）、short（16位）、int（32位）、long（64位）；两种浮点类型：float（32位）、double（64位）、一种字符类型（char（16位））、一种布尔类型（boolean）（看虚拟机规范：1个字节、4个字节都有可能））	

* *对象引用？*

  reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

* *java有指针？*

  java有指针，在java中称为引用。所谓的引用就是内存地址的值。拿到该引用相当于得到了该内存处的对象。
  java中可以使用指针（我们称之为引用），但不能修改引用。

* 句柄与指针的区别？

  句柄实际上是一种指向某种资源的指针，但与指针又有所不同：指针对应着一个数据在内存中的地址，得到了指针就可以自由的修改该数据。但Windows并不希望一般程序修改其内存数据结构，故给每个使用GlobalAlloc等函数声明的内存区域指定一个句柄，平时你只是在调用API函数时利用这个句柄来说明要操作哪些内存。
  句柄：**句柄只能调用系统提供的服务，windows靠句柄来找到要引用的对象，但是句柄的权限等都受操作系统所管理；且句柄是对象生成时系统指定的，是为了区别系统中存在的各个对象，这个句柄不是由程序员给的。**

* *returnAddress类型？*

  指向了一条字节码指令的地址。

局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放一个32位以内的数据类型（boolean、byte、char、short、int、float、reference和returnAddress八种）。其中64位长度的long和double类型的数据会占用2个局部变量空间，其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法**需要在帧中分配多大的局部变量空间时完全确定的，在方法运行期间不会改变局部变量表的大小。**

### 操作数栈

​	和局部变量区一样，操作数栈也是被组织成一个以字长为单位的数组。但是和前者不同的是，它不是通过索引来访问，而是<font color=red>通过标准的栈操作—压栈和出栈—来访问的</font>。比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。

​	虚拟机在操作数栈中存储数据的方式和在局部变量区中是一样的：如int、long、float、double、reference和returnType的存储。对于byte、short以及char类型的值在压入到操作数栈之前，也会被转换为int。

​	虚拟机把操作数栈作为它的工作区——大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。比如，iadd指令就要从操作数栈中弹出两个整数，执行加法运算，其结果又压回到操作数栈中，看看下面的示例，它演示了虚拟机是如何把两个int类型的局部变量相加，再把结果保存到第三个局部变量的：

```tex
begin
iload_0 // push the int in local variable 0 onto the stack
iload_1 // push the int in local variable 1 onto the stack
iadd // pop two ints, add them, push result
istore_2 // pop int, store into local variable 2
end
```

在这个字节码序列里，前两个指令iload_0和iload_1将存储在局部变量中索引为0和1的整数压入操作数栈中，其后iadd指令从操作数栈中弹出那两个整数相加，再将结果压入操作数栈。第四条指令istore_2则从操作数栈中弹出结果，并把它存储到局部变量区索引为2的位置。图5-10详细表述了这个过程中局部变量和操作数栈的状态变化，图中没有使用的局部变量区和操作数栈区域以空白表示。

![](D:\Work\TyporaNotes\note\JVM\操作数栈.jpg)

比如 a = 1 + 2 
iload_0 //将 1 压入操作数栈 
iload_1 //将 2 压入操作数栈 
iadd //从操作数栈中弹出 1、2，将算出的值 3 压入操作数栈 
istore_2 //把 3 从操作数栈中弹出，保存到本地变量区

### 动态连接

​	每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如final、static域等），称为静态解析，另一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。

### 异常情况

* 线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常；
* 如果扩展时无法申请到足够的内存，就会抛出OutMemoryError异常；

* *栈扩展？*

  虚拟机栈也可以动态扩展（当前大部分的虚拟机都可动态扩展，只不过也允许设置固定长度的虚拟机栈）

## 本地方法栈

本地方法栈与虚拟机栈所发挥的作用是非常相似的，他们之间的区别是：

* 虚拟机栈为虚拟机执行Java方法服务；
* 本地方法栈则为虚拟机使用到的Native方法服务。

## Java堆

Java堆是JVM所管理的内存中最大的一块。

Java堆是<font color=red>被所有线程共享</font>的一块内存区域，在虚拟机启动时创建，此内存区域的唯一目的就是<font color=red>存放对象实例</font>，几乎所有的对象实例都在这里分配内存。

* *几乎所有的对象实例都在这里分配内存，哪些不是？*

  随着发展，逃逸分析技术、栈上分配技术逐渐成熟，所有对象都分配在堆上也渐渐变得不是那么绝对了。

* *逃逸分析？*

  逃逸是指在某个方法之内创建的对象，除了在方法体之内被引用之外，还在方法体之外被其它变量引用到；这样带来的后果是由于其被其它变量引用，在该方法执行完毕之后，该方法中创建的对象将无法被GC回收。
  由于无法回收，即成为逃逸。

  常见的逃逸场景：全局变量赋值、方法返回值、实例引用传递

  ```java
  	String test2;
      /**
       * 逃逸
       */
      void test02() {
          test2 = "test2";
      }
  ```

* *栈上分配？*

  java对象一般是在堆里分配的，当对象不再使用后，需要依靠GC来遍历引用树并回收内存，如果对象数量较多，将给GC带来较大压力，也间接影响了应用的性能。
  因此，需要减少临时对象在堆内分配的数量，可以通过“栈上分配”方法实现。分析找到未逃逸的变量，将变量类的实例化内存直接在栈里分配(无需进入堆)，分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。

* Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆"；

* Java堆可细分为：新生代和老年代；新生代还可分为Eden空间、From Survivor空间、To Survivor空间(8:1:1)。

* Java堆可以处于物理上不连续的内存空间中，只要逻辑上（程序员接触地址）是连续的即可。

## 方法区（Non-Heap非堆）

方法区与Java堆一样，是<font color=red>各个线程共享</font>的内存区域，它用于存储已被虚拟机加载的<font color=red>类信息class、常量、静态变量static</font>、即时编译器编译后的代码等数据。

“永生代”：相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就“永久”存在性了，这个区域的垃圾收集主要是：收集常量池和对类型进行卸载，只是收集效率比较低。

由于永久代内存经常不够用或发生内存泄露，为了更容易管理方法区，<font color=red>从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</font>

* *为什么叫元空间，是因为这里面存储的是类的元数据信息？*

  元数据（Meta Date），关于数据的数据或者叫做用来描述数据的数据或者叫做信息的信息。

* 常量的回收比较容易
* 类信息的回收需要满足的条件：
  * 该类所有的实例已经被回收，JVM中没有任何类的实例；
  * 加载该类的ClassLoader被回收；
  * 该类对应的java.lang.class没有地方引用

### 运行时常量池

运行时常量池是方法区的一部分。

用于存放编译期生产的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

JDK1.7之前运行时常量池逻辑包含<font color=red>字符串常量池存放在方法区</font>
在JDK1.7<font color=red>字符串常量池被从方法区拿到了堆中, 运行时常量池剩下的东西还在方法区</font>, 也就是hotspot中的永久代.
而JDK1.8<font color=red>移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</font>

* *常量池的优点？*
  java中的常量池技术，是为了方便快捷地创建某些对象而出现的，当需要一个对象时，就可以从池中取一个出来（如果池中没有则创建一个），则在需要重复重复创建相等变量时节省了很多时间。

运行时常量池的一个重要特征是具备动态性，并非预置如Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。

```java
 public class Test {
        Integer i1 = new Integer(1);
        Integer i2 = new Integer(1);
        //i1,i2分别位于堆中不同的内存空间
        System.out.println(i1==i2);//输出false
        Integer i3 = 1;
        Integer i4 = 1;
        //i3,i4指向常量池中同一个内存空间
        System.out.println(i3==i4);//输出true
         //很显然，i1,i3位于不同的内存空间
        System.out.println(i1==i3);//输出false
    }
```

* 注意：java中基本类型的包装类的大部分都实现了常量池技术，这些类是Byte, Short, Integer, Long, Character, Boolean,另外两种浮点数类型的包装类则没有实现。另外Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值<font color=red>小于等于127时才可使用对象池</font>，也即对象不负责创建和管理大于127的这些类的对象。

```java
public class Test{
        public static void main(String[] args){
            //5种整形的包装类Byte,Short,Integer,Long,Character的对象，
            //在值小于127时可以使用常量池
            Integer i1=127;
            Integer i2=127;
            System.out.println(i1==i2)//输出true
            //值大于127时，不会从常量池中取对象
            Integer i3=128;
            Integer i4=128;
            System.out.println(i3==i4)//输出false
            //Boolean类也实现了常量池技术
            Boolean bool1=true;
            Boolean bool2=true;
            System.out.println(bool1==bool2);//输出true
            //浮点类型的包装类没有实现常量池技术
            Double d1=1.0;
            Double d2=1.0;
            System.out.println(d1==d2)//输出false
        }
    }
```



# Java堆中对象的创建等

## 对象的创建

虚拟机遇到一条new指令时：

* 首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。
* 如果没有，那么必须先执行相应的类加载过程（类加载过程见"Java类加载过程"）
* **在类加载检查通过后，虚拟机将会为<font color=red>新生对象分配内存</font>。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。**
  * 假设Java堆中内存时绝对规整的，则分配内存仅仅是把作为分界点的指针向空闲空间挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”；
  * 注意到：对象创建在JVM中是很频繁的，仅仅修改一个指针所指向的位置，在并发情况下不是线程安全的，此时有两种解决方法：
    * 对分配内存空间的动作进行同步处理
    * 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲。

## 对象的内存布局

对象在内存中存储的布局可以分为3块区域：对象头、实例数据和对齐填充。

### 对象头

包括两部分信息：第一部分用于存储对象自身的运行时数据，另一部分是类型指针，<font color=red>即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</font>
换句话说，查找对象的元数据信息并不一定要经过对象本身。

* *元数据？*如i=1中的i

  元数据就是用来定义数据的数据。比如，有一条学生信息记录，其中包括字段姓名（name）、年龄（age）、性别（male）、班级（class）等，那么name、age、male、class就是元数据。通过它们的描述，一条关于学生信息的数据记录就产生；

注意：如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通对象的元数据信息确定Java对象的大小，但是从数据的元数据中却无法确定数组的大小。

### 实例数据

实例数据是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。

### 对齐填充

不是必然存在的，要求对象起始地址时8字节的整数倍，**当对象实例数据部分没有对齐时，通过对齐填充来补全。**

## 对象的访问定位

reference类型（存于JVM栈中）在JVM规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位，访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机决定的。

目前主流的访问方式有使用句柄和直接指针两种。

* 如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息

  ![](D:\Work\TyporaNotes\note\JVM\pict\通过句柄访问对象.jpg)

* 如果使用直接指针访问，那么Java堆对象的布局汇总就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。

  ![](D:\Work\TyporaNotes\note\JVM\pict\通过直接指针访问对象.jpg)

  这两种访问方式各有优势：

  使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改

  使用直接指针访问方式的最大好处就是速度快，它节省了一次指针定位的时间开销。



# OutOfMemoryError异常

## 堆溢出

Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。

## 虚拟机栈和本地方法栈溢出

- 线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常；
- 如果扩展时无法申请到足够的内存，就会抛出OutMemoryError异常；

## 方法区和运行时常量池溢出

```java
public class RuntimeConstantPoolOOM{
    public static void main(String[] args){
        String str1=new StringBuilder("计算机").append("软件").toString();
        System.out.print(str1.intern()==str1);
        String str2=new StringBuilder("ja").append("va").toString();
        System.out.print(str2.intern()==str2);
    }
}
```

这段代码在JDK1.6中获得两个False，在JDK1.7中运行获得true和false。

原因：

* 在JDK1.6中，intern()方法会把首次遇到的字符串实例复制到永生代中，返回的也是永生代中这个字符串实例的引用，而由Stringbuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false；
* 而在JDK1.7中，inern()实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因而返回的是同一个实例；
* str2比较返回false是因为“java”这个字符串在执行StringBuilder.toString()之前已经出现过，字符串常量池也有它的引用了，不符合“首次出现”的原则，因此为“false”。

## Intern

**String.intern()** 方法可以使得所有含相同内容的字符串都共享同一个内存对象，减少内存中相同字符串的数量，节省一些内存空间。

JDK1.6 和 JDK1.7 在 intern() 方法的实现上，有相同，也有不同。

相同点：  先去查看字符串常量池是否有该字符串，如果有，则返回字符串常量池中的引用。  

不同点：  如果是 JDK1.7，当字符串常量池中找不到对应的字符串时，不会将字符串拷贝到字符串常量池，而只是生成一个对该字符串的引用在字符串常量池。而 JDK1.6 会拷贝字符串至字符串常量池。

JDK1.6 中，常量池在方法区。JDK1.7 中，常量池移到堆区了。

![img](https://ask.qcloudimg.com/http-save/yehe-2073418/8t9bclo45m.gif)

第一段代码：

```
String s = new String("1");
s.intern();
String s2 = "1";
System.out.println(s == s2);

String s3 = new String("1") + new String("1");
s3.intern();
String s4 = "11";
System.out.println(s3 == s4);
```

　　jdk1.6中输出结果为 false fals

　　解释：

　　　　String s = new String("1"); 在字符串常量池中创建"1"对象，在堆中创建s对象。

　　　　s.intern(); 由于字符串常量池中已经有"1"对象，因此该句并无实际意义。 s2指向字符串常量池中"1"对象。

　　　　因此s指向堆中的引用，s2指向字符串常量池中的引用，返回 false。

　　　　String s3 = new String("1") + new String("1"); 在堆中创建s3对象。

　　　　s3.intern(); 将字符串"11"复制到字符串常量池中。s4指向字符串常量池中"11"对象。

　　　　因此s3指向堆中的引用，s4指向字符串常量池中的引用，返回 false。

![img](https://img2018.cnblogs.com/blog/1399084/201903/1399084-20190316140611047-2128507065.png)

​        jdk1.7中输出结果为 false true

　　解释：

　　　　s与s2的情况与jdk1.6中一样，返回 false。

　　　　s3与s4有所不同的是s3.intern(); 先在字符串常量池中查找是否存在"11"，再从堆中查找，

　　　　然后将堆中s3的引用存储到字符串常量池中。

　　　　String s4 = "11"; 创建的时候发现字符串常量池中有了“11”（s3），然后指向s3引用的对象。

　　　　因此s3与s4的引用相同，返回 true。

![img](https://img2018.cnblogs.com/blog/1399084/201903/1399084-20190316140635659-1582684768.png)



注意：字符串常量池中的 String 对象，也是可以被 GC 回收的，只要它不再被引用了。

总结：jdk1.6的环境下使用intern()方法后，String对象只会引用或创建在字符串常量池中的对象。

　　　jdk1,7的环境下使用intern()方法后，String对象需要注意所引用的是字符串常量池中的还是堆中的对象。

　　　然后intern()方法的作用上，用一句话概括的话就是：intern()方法设计的初衷就是为了重用String对象，以节省内存消耗。

