# JVM执行方法调用过程

## 静态绑定、动态绑定

* 在JVM中，静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。
* 在class文件中，Java编译器会用符号引用指代目标方法。在执行调用指令时前，它所附带的符号引用需要被解析成实际引用。
  * 对于可以静态绑定的方法调用而言，实际引用为目标方法的指针；
  * 对于需要动态绑定的方法调用而言，实际引用为辅助动态绑定的信息，（方法表的索引值等）。
* Java虚拟机采取了一种用空间换取时间的策略来实现动态绑定。它为每个类生成一张方法表，用以快速定位目标方法。

## 方法表的实现

在Java类加载过程中提到，在类链接的准备阶段，它除了为静态字段分配内存之外，还会构造与该类相关联的方法表。

方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法。

方法表满足两个特质：一，子类方法表中包含父类方法表中的所有方法；二，子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。

在执行过程中,JAVA虚拟机将获取调用者的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法。这个过程便是动态绑定。

* 虚方法：方法重写的方法，可以认为就是虚方法。

如下：

![](D:\Work\TyporaNotes\note\JVM\pict\方法调用例.jpg)

JVM的工作可以类似于导航员，当乘客需要出境时，导航员会先问是中国人还是外国人（获取动态类型），然后翻出中国人 / 外国人对应的小册子（获取动态类型的方法表），小册子的第1页便写着往哪走（用1作为索引来查找方法表所对应的目标方法）。

实际上，使用了方法表的动态绑定与静态绑定相比，仅仅多出几个内存解引用操作：

* 访问栈上的调用者；
* 读者调用者的动态类型；
* 读取该类型的方法表；
* 读取方法表中某个索引值所对应的目标方法。

相比于创建并初始化Java栈帧来说，这几个内存解引用操作的开销几乎可以忽略不计。

*但即时编译其实还拥有两种性能更好的优化手段：内联缓存与方法内联。*

## 内联缓存

内联缓存是一种加快动态绑定的优化技术。它能够<font color=red>缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法</font>。在之后的执行过程中，如果碰到已缓存的类型，内联缓存便会直接调用该类型所对应的目标方法。如果没有碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定。

在我们的例子中，相当于导航员记住了上一个出境乘客的国籍和对应的通道，例如中国人，走了左边通道出境，那么下一个乘客出境的时候，导航员会先问是不是中国人，是的话就直接走左边，不是的话，只好拿出小册子，翻到第1页，再告知查询结果。

在针对多态的优化手段中，我们通常会提高以下三个术语。

* 单态（仅有一种状态）
* 多态（有限数量的状态的情况）
* 超多态（更多种状态的情况，与多态以一个数值隔开）

对于缓存而言，而有对于的单态内存缓存、多态内存缓存、超多态内存缓存。

* 单态内存缓存：只缓存一种动态类型以及它所对应的目标方法。实现非常简单：比较所缓存的动态类型，如果命中，则直接调用对应的目标方法；
* 多态内存缓存：与多个缓存的动态类型逐一比较；

（一般来说，我们会将热门的动态类型放在前面；在实践中，大部分的虚方法调用均是单态的）

前面提到，内联缓存会缓存前一个调用者的信息，这对数据的局部性有要求，即在替换内联缓存之后的一段时间内，方法调用的调用者的动态类型应保持一致，从而能够有效地利用内联缓存。（当两种不同类型的调用者轮流执行某方法调用时，该方法缓存完全没有利用到）
另一种选择是，劣化为超多态状态，实际上放弃了优化的机会，直接访问方法表，来动态绑定目标方法，它牺牲了优化的机会，但是节省了写缓存的额外开销。



