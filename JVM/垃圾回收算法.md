##  标记清除算法

遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。就是我们图中所标记的a,b,c,d.•清除：清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。 也就是说，如果内存不够，GC线程就会被触发然后将程序暂停，随后将依旧存活的对象标记一遍，最后再将堆中所有没被标记的对象全部清除掉，接下来便让程序继续恢复运行。 

流程图就想这个样子的 初始下的老年代中的对象状态。

![](D:\Work\TyporaNotes\note\JVM\pict\3-1.png)

这时候都是没有被标记的状态，接下来内存不够，GC线程停止，开始进行标记了

![](D:\Work\TyporaNotes\note\JVM\pict\3-2.png)

按照根节点开始遍历 标记的abcdeh都是存活的对象，接下来开始标记。

![](D:\Work\TyporaNotes\note\JVM\pict\3-3.png)

接下来就是清除数据了，这个就更加的简单了

![](D:\Work\TyporaNotes\note\JVM\pict\3-4.png)

遍历堆，把未被标记的对象回收，清除完成之后还有就是把标记去除掉，可以下次进行标记清除的时候继续清除

![](D:\Work\TyporaNotes\note\JVM\pict\3-5.png)

这样标记清除就执行完毕了，剩下还有两个要说的地方，

 **一是在进行标记清楚算法的时候为什么要让程序停止，（stop the world）。**

 二是标记清除算法的优点和缺点又是什么？（Stop the World）

### 为什么STW

程序停止其实可以理解，因为如果说不停止程序的话，我们在标记完成这个b对象之后，我们new出一个新的对象J，可以从B指向J，也就是说，这时候J应该是被标记的状态，但是实际情况肯定不是，这个对象在B标记完之后，马上都要结束了，我们又new出来一个对象，可想而知，他肯定是没有被标记的，所以在第二阶段进行清除的时候，这个苦命的J将会被清除掉， 那这样肯定是不符合我们的实际情况的。

你想呀这刚刚new出来的对象结果被清除了，忽然变成了空值，那就不符合我们的要求了。所以他会让程序先停止，然后不会再出现这种情况，然后进行开始标记阶段。

### 优缺点

首先我们可以先看缺点，他的缺点非常明显，

因为他会递归遍历Root，这样的话 Stop the World的**时间就比较长了**，这样一直让人等待的滋味可不是那么好受。

第二个就是这种清除方式清除出来的**内存空间是不连续**的，你看这个图。

![](D:\Work\TyporaNotes\note\JVM\pict\3-6.png)

死亡的上下分成了2部分，是不连续的，这样给JVM又造成了一种额外的负担，他需要去维持一个内存的空闲列表，如果说我们在这时候去new一个数组，你想想他去找这个连续的内存空间的话，是不是就要困难很多呢?

### 优点

比如说不会出现循环引用， 我们可以想想 两个类 互相引用，A中newB，B中newA,那这样岂不是a.b=b ,b.a = a ,是吧 ，而标记清除算法在走完了之后，是可以回收a,和b的，因为他是从根元素开始遍历标记，也就是从ab开始，那么单一的a和单一的b就是没有被标记的，所以，这样就**避免了循环引用的问题；**

①**实现简单**
说到 GC 标记 - 清除算法的优点，那当然要数算法简单，实现容易了。
另外，如果算法实现简单，那么它与其他算法的组合也就相应地简单。

②**与保守式 GC 算法兼容**
后面介绍的保守式 GC 算法中，对象是不能被移动的。因此保守式 GC 算法跟把 对象从现在的场所复制到其他场所的 GC 复制算法与标记 - 压缩算法不兼容。

### 缺点

①碎片化

②**效率比较低（递归与全堆对象遍历），而且在进行GC的时候，需要停止应用程序，这会导致用户体验非常差劲**

## 标记整理算法

**原理**：分为标记和整理两个阶段：首先标记出所有需要存活的对象，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

清除（红色）的向右边去，不用清除的向左边去，最后清除掉右边的块。

![](D:\Work\TyporaNotes\note\JVM\pict\标记整理算法.png)

### 优点

不会产生空间碎片；

### 缺点

但是整理会花一定的时间。（整理阶段，由于移动了可用对象，需要去更新引用）

## 复制算法

为了解决标记-清除算法的效率不高的问题，产生了复制算法。它把内存空间划分为两个相等的区域，每次只使用其中一个区域。**在垃圾收集时，遍历当前使用的区域，把存活对象复制到另一个区域中，最后将当前使用的区域的可回收的对象进行回收。**

![](D:\Work\TyporaNotes\note\JVM\pict\3-7.png)

这种算法每次都对整个半区进行内存回收，不需要考虑内存碎片的问题，代价就是使用内存为原来的一半。复制算法的效率与存活对象的数目多少有很大的关系，如果存活对象很少，复制算法的效率就会很高。由于绝大多数对象的生命周期很短，并且这些生命周期很短的对象都存于新生代中，所以复制算法被广泛应用于新生代中。

反复执行这个过程，虽然效率问题解决，但出现新的问题。内存区域只用一半，导致严重浪费为了解决浪费，所以JVM把**新生代**分为三部分。

![](D:\Work\TyporaNotes\note\JVM\pict\堆空间的回收图.png)

### 优点

①优秀的吞吐量

GC 复制算法只搜索并复制活动对象，所以跟一般的 GC 标记 - 清除算 法相比，它能在较短时间内完成 GC。也就是说，其吞吐量优秀。

尤其是堆越大，差距越明显。GC 标记 - 清除算法在清除阶段所花费的时间会不断增加， 但 GC 复制算法就不会产生这种消耗。毕竟它消耗的时间是与活动对象的数量成比例的。

②可实现高速分配

GC 复制算法不使用空闲链表。这是因为分块是一个连续的内存空间。比起 GC 标记 - 清除算法和引用计数法等使用空闲链表的分配，GC 复制算法明显快得多。

③不会发生碎片化
基于算法性质，活动对象被集中安排在 From 空间的开头对吧。像这 样把对象重新集中，放在堆的一端的行为就叫作压缩。在 GC 复制算法中，每次运行 GC 时 都会执行压缩。

因此 GC 复制算法有个非常优秀的特点，就是不会发生碎片化。也就是说，可以安排分 块允许范围内大小的对象。

④与缓存兼容
在 GC 复制算法中有引用关系的对象会被安排在堆里离彼此较近的位置。这种情况有一个优点，那就是 mutator 执行速度极快。这也是借助压缩来完成的，通过压缩来把有引用关系的对 象安排在堆中较近的位置。

### 缺点

①堆使用效率低下

GC 复制算法把堆二等分，通常只能利用其中的一半来安排对象。也就是说，只有一半 堆能被使用。相比其他能使用整个堆的 GC 算法而言，可以说这是 GC 复制算法的一个重大的缺陷。

②不兼容保守式 GC 算法
GC 标记 - 清除算法有着跟保守式 GC 算法相兼容的优点。因 为 GC 标记 - 清除算法不用移动对象。

另一方面，GC 复制算法必须移动对象重写指针，所以有着跟保守式 GC 算法不相容的 性质。

③递归调用函数
在这里介绍的算法中，复制某个对象时要递归复制它的子对象。因此在每次进行复制的 时候都要调用函数，由此带来的额外负担不容忽视。大家都知道比起这种递归算法，迭代算 法更能高速地执行

此外，因为在每次递归调用时都会消耗栈，所以还有栈溢出的可能。

## CyC2018

### 标记清除算法

![](D:\Work\TyporaNotes\note\JVM\pict\C-1.png)

在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。

在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。

在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。

不足：

- 标记和清除过程效率都不高；
- 会产生大量不连续的内存碎片，导致无法给大对象分配内存。

### 标记整理算法

![](D:\Work\TyporaNotes\note\JVM\pict\C-2.png)

<font color=red>“标记－整理－清除”</font>

让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动(美团面试题目，记住是完成标记之后，先不清理，先移动再清理回收对象)，然后清理掉端边界以外的内存(美团问过)。

类似与标记清除法一样，第一步先把需要回收的对象标记，不同的是第二步把活动的对象(幸存)往内存一边移动。堆内存就像一列队伍，把所有要留下的对象都往前靠，后面剩下的都是即将回收的对象(垃圾)。

优点:

- 不会产生内存碎片

不足:

- 需要移动大量对象，处理效率比较低。

### 复制算法

![](D:\Work\TyporaNotes\note\JVM\pict\C-3.png)

将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。

主要不足是只使用了内存的一半。

现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。

HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。

### 分代算法

现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。

一般将堆分为新生代和老年代。

- 新生代使用：复制算法
- 老年代使用：标记 - 清除 或者 标记 - 整理（较多） 算法



* 为什么新生代使用“复制算法”，老年代使用“标记-整理法”？

  因为在Java程序中，大部分对象都是“朝生夕死”，很快会被回收的，所以新生代的minorGC的触发频率要远大于老年代的majorGC，这就需要效率更高的“复制算法”，而老年代由于majorGC触发频率比较低，所以可以选择效率较低的“标记整理法”**来节约内存。**

  此外，值得一提的是新生代的eden内存要大于Survivor内存，这样就会出现一个问题：当eden中有一部分对象生命周期一样并且占用的内存大于Survivors时，执行minorGC仍然幸存，Survivor将无法存放这么多的对象。这时老年代就会起到“担保”作用，那些存活的对象将直接晋升到老年代。同理“复制算法”需要有人来做担保，这也是老年代使用“标记整理法”的原因之一。