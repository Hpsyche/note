* 计算机网络：

  七层协议：ok

  三次握手、四次挥手：ok

  

  四次挥手最后B给A请求的等待时间（是什么时间）
  
  ```tex
  TCP四次挥手中,主动关闭方最后为什么要等待2MSL之后才能关闭连接?
  
  和TCP三次同步握手不一样的是，TCP关闭连接用四次握手来实现，即A--->B Fin, B--->A ACK, B--->A Fin, A--->B ACK，为什么要这样？
  
  A--->B Fin, B--->A ACK ，A属于主动关闭方，收到B的ACK后，A到B的方向连接关闭，即half shutown ，这时A不能再发送数据了。
  
  这种状态下B还是可以单向发送数据的，B的数据发送完毕，也做关闭动作了：
  
  B--->A Fin, A--->B ACK
  
  B收到ACK，关闭连接。但是A无法知道ACK是否已经到达B，于是开始等待？等待什么呢？假如ACK没有到达B，B会为FIN这个消息超时重传 timeout retransmit ，那如果A等待时间足够，又收到FIN消息，说明ACK没有到达B，于是再发送ACK，直到在足够的时间内没有收到FIN，说明ACK成功到达。这个等待时间至少是：B的timeout + FIN的传输时间，为了保证可靠，采用更加保守的等待时间2MSL。
  
  **MSL，Maximum Segment Life，这是TCP 对TCP Segment 生存时间的限制。**
  
  **TTL， Time To Live ，IP对IP Datagram 生存时间的限制，255 秒，所以 MSL一般 = TTL = 255秒**
  
  A发出ACK，等待ACK到达对方的超时时间 MSL，等待FIN的超时重传，也是MSL，所以如果2MSL时间内没有收到FIN，说明对方安全收到FIN。
  
  综上所述，等待2MSL的目的是为了A最后发送的ACK能最终到达B端。
  
  ```
  
  https
  
  （大概说了下，但是答得不太好）
  
  慢启动算法
  
  
  
  滑动窗口
  
  
  
  一个请求包含什么信息
  
  请求方式（Get/Post） url 协议名 请求头部 空行 请求体
  
  
  
  响应码状态有什么？
  
  200 204 206 301 302 303 304 400 404 500 501 503 
  
  415（不支持的媒体类型，说错成了“514”）



* 操作系统：

  线程及进程区别：ok

  

  查看CPU状态命令：不懂

  top命令：真不懂（一开始还听成了tail)
  
  
  
  管道命令
  
  ps -ef|grep 
  
  netstat -anp |grep 3306*
  
  
  
  配置网络的一些指令
  
  协程



* 数据结构：

  栈和队列

  

  hash原理

  

  hash扩容

  大于 size*加载因子扩容（扩容为两倍）

  各种map区别

  红黑树特征

  为什么使用红黑树

  

  快排

  快排是稳定排序吗？

  ```tex
  所谓排序的稳定性，就是指在排序过程中，在对a关键字排序后会不会改变其他关键字的顺序。
  自己都可以试试，在比较有相同关键字序列的情况下，稳定的排序会将较早出现的元素排在前面，而不会是后面。
  比如：对（49，38，49，20，97，76）排序，就是不稳定排序
  ```

  

  跳表

  链表+hash

  HashMap：如果树深度太大，怎么改进？

  

  

  

* 数据库：

  常用sql命令

  innodb和MySan区别

  

  
  
  
  
  访问浏览器www.taobao.com过程
  
  * dns域名解析，`浏览器缓存 -> 系统 host 缓存 -> 本地域名服务器 LDNS -> Root Server -> 
    .com域名服务器 -> 返回 ip 地址`
    
  * 三次握手建立tcp连接。浏览器开始向该 IP 地址发起 HTTP/HTTPS 会话请求，而  HTTP/HTTPS 协议皆基于 TCP 协议，因此，在进行 HTTP 请求之前，浏览器还需要与百度服务器进行三次握手，建立 TCP 连接。
  
  * 建立了HTTP连接后，（DNS、HTTP、HTTPS 所在的层我们称为应用层。）用户的应用层封装http头-->发送请求携带url、http、。。。正文格式等等；
  
  * 运输层封装tcp头（端口）、序号（确保ip报文的顺序）、校验和（判断数据是否被损坏）等
  
  * 网络层封装源地址目的地址等；
  
  * 数据链路层（本地ip --》ARP--》MAC地址）、通过交换机上的学习的结果，转发表，找到网关的mac地址，将源 MAC 和网关的 MAC 放入 MAC 头中，发送出去。网关所在的端口，例如 192.168.1.1/24 将网络包收进来，然后接下来怎么做，就完全看网关的了。
  
  * 网关拿出ip头，（路由表）（动态路由协议：fold、djske）算法，找到最终目的路由器，其网关；
  
    * 帧经过交换机时，其源、目标MAC是不会变的，一句话：二层转发不改变帧的MAC地址、IP地址；
  
    * 帧经过路由器时，进行路由转发，IP地址是不会变的，但MAC地址必定会变
  
      举个例子：
  
      A----B----C-----D 四个路由器
  
      比如A发送报文给D，
  
      1）A发出的是：源、目标IP是AD，源目标MAC是AB相对接口的MAC
  
      2）B转发给C的是：源目标IP是AD，原目标MAC是BC相对接口的MAC
  
      3）C转发给D的是：源目标IP是AD，原目标MAC是CD相对接口的MAC
  
      4）D收到的帧是：源目标IP是AD，源目标MAC是CD相对接口的MAC
  
      对帧当中的IP地址的理解：发货人、收货人
  
      对帧当中的MAC地址的理解：
  
      源MAC：货物中途所经过的上一个驿站
  
      目标MAC：货物中途所要到达的下一个驿站  
  
  * 到达网关后，取出ip头，arp协议找到ip地址对应的mac地址；
  
  * 取得mac地址后，拿掉头，交给网络层，找到对应的ip；
  
  * 取得ip地址后，拿掉头，交给运输层，找到对应的tcp层；（在tcp层，对于收到的每个包，都会有一个回复的包说明收到了，报平安，TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。）
  
  * 当网络包平安到达 TCP 层之后，TCP 头中有目标端口号，通过这个端口号，可以找到电商网站的进程正在监听这个端口号，假设一个 Tomcat，将这个包发给电商网站。
  
  * 电商网站的进程得到 HTTP 请求的内容，服务器接收后，返回json数据，就按刚才的过程走回用户的主机；
  
  * 用户主机接收到数据，层层解析最终进入浏览器中，显示交互成功。
  
  

